# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkIndexPython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkIndexPython', [dirname(__file__)])
        except ImportError:
            import _itkIndexPython
            return _itkIndexPython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkIndexPython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkIndexPython = swig_import_helper()
    del swig_import_helper
else:
    import _itkIndexPython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import itkOffsetPython
import itkSizePython
import pyBasePython
class itkIndex1(object):
    """


    Represent a n-dimensional index in a n-dimensional image.

    Index is a templated class to represent a multi-dimensional index,
    i.e. (i,j,k,...). Index is templated over the dimension of the index.
    ITK assumes the first element of an index is the fastest moving index.

    For efficiency sake, Index does not define a default constructor, a
    copy constructor, or an operator=. We rely on the compiler to provide
    efficient bitwise copies.

    Index is an "aggregate" class. Its data is public (m_Index) allowing
    for fast and convenient instantiations/assignments.

    The following syntax for assigning an index is allowed/suggested:

    Index<3> index = {{5, 2, 7}};

    The double braces {{ and }} are needed to prevent a compiler warning
    about a partly bracketed initializer.

    Should there be an itkBoundedIndex to handle bounds checking? Or
    should there be an API to perform bounded increments in the iterator.
    Wiki Examples:  All Examples

    https://www.itk.org/Wiki/ITK/Examples/SimpleOperations/DistanceBetween
    Indices Distance between two indices

    https://www.itk.org/Wiki/ITK/Examples/Images/Index An object which
    holds the index of a pixel

    C++ includes: itkIndex.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def GetIndexDimension() -> "unsigned int":
        """GetIndexDimension() -> unsigned int"""
        return _itkIndexPython.itkIndex1_GetIndexDimension()

    GetIndexDimension = staticmethod(GetIndexDimension)

    def __add__(self, *args) -> "itkIndex1 const":
        """
        __add__(itkIndex1 self, itkSize1 size) -> itkIndex1
        __add__(itkIndex1 self, itkOffset1 offset) -> itkIndex1
        """
        return _itkIndexPython.itkIndex1___add__(self, *args)


    def __iadd__(self, *args) -> "itkIndex1 const &":
        """
        __iadd__(itkIndex1 self, itkSize1 size) -> itkIndex1
        __iadd__(itkIndex1 self, itkOffset1 offset) -> itkIndex1
        """
        return _itkIndexPython.itkIndex1___iadd__(self, *args)


    def __isub__(self, *args) -> "itkIndex1 const &":
        """
        __isub__(itkIndex1 self, itkSize1 size) -> itkIndex1
        __isub__(itkIndex1 self, itkOffset1 offset) -> itkIndex1
        """
        return _itkIndexPython.itkIndex1___isub__(self, *args)


    def __sub__(self, *args) -> "itkOffset1 const":
        """
        __sub__(itkIndex1 self, itkSize1 size) -> itkIndex1
        __sub__(itkIndex1 self, itkOffset1 off) -> itkIndex1
        __sub__(itkIndex1 self, itkIndex1 vec) -> itkOffset1
        """
        return _itkIndexPython.itkIndex1___sub__(self, *args)


    def __mul__(self, vec: 'itkSize1') -> "itkIndex1 const":
        """__mul__(itkIndex1 self, itkSize1 vec) -> itkIndex1"""
        return _itkIndexPython.itkIndex1___mul__(self, vec)


    def __eq__(self, vec: 'itkIndex1') -> "bool":
        """__eq__(itkIndex1 self, itkIndex1 vec) -> bool"""
        return _itkIndexPython.itkIndex1___eq__(self, vec)


    def __ne__(self, vec: 'itkIndex1') -> "bool":
        """__ne__(itkIndex1 self, itkIndex1 vec) -> bool"""
        return _itkIndexPython.itkIndex1___ne__(self, vec)


    def GetIndex(self) -> "long const *":
        """
        GetIndex(itkIndex1 self) -> long const *

        Get the index. This
        provides a read only reference to the index. See:   SetIndex() 
        """
        return _itkIndexPython.itkIndex1_GetIndex(self)


    def SetIndex(self, val: 'long const *') -> "void":
        """
        SetIndex(itkIndex1 self, long const * val)

        Set the index. Try to
        prototype this function so that val has to point to a block of memory
        that is the appropriate size. See:   GetIndex() 
        """
        return _itkIndexPython.itkIndex1_SetIndex(self, val)


    def SetElement(self, element: 'unsigned long', val: 'long') -> "void":
        """
        SetElement(itkIndex1 self, unsigned long element, long val)

        Sets the value of one of
        the elements in the index. This method is mainly intended to
        facilitate the access to elements from Tcl and Python where C++
        notation is not very convenient. WARNING:  No bound checking is
        performed

        See:   SetIndex()

        See:   GetElement() 
        """
        return _itkIndexPython.itkIndex1_SetElement(self, element, val)


    def GetElement(self, element: 'unsigned long') -> "long":
        """
        GetElement(itkIndex1 self, unsigned long element) -> long

        Gets the value of one of
        the elements in the index. This method is mainly intended to
        facilitate the access to elements from Tcl and Python where C++
        notation is not very convenient. WARNING:  No bound checking is
        performed

        See:   GetIndex()

        See:   SetElement() 
        """
        return _itkIndexPython.itkIndex1_GetElement(self, element)


    def GetBasisIndex(dim: 'unsigned int') -> "itkIndex1":
        """GetBasisIndex(unsigned int dim) -> itkIndex1"""
        return _itkIndexPython.itkIndex1_GetBasisIndex(dim)

    GetBasisIndex = staticmethod(GetBasisIndex)

    def Fill(self, value: 'long') -> "void":
        """
        Fill(itkIndex1 self, long value)

        Set one value for the index in
        all dimensions. Useful for initializing an offset to zero. 
        """
        return _itkIndexPython.itkIndex1_Fill(self, value)


    def __init__(self, *args):
        """
        __init__(itkIndex1 self) -> itkIndex1
        __init__(itkIndex1 self, itkIndex1 arg0) -> itkIndex1



        Represent a n-dimensional index in a n-dimensional image.

        Index is a templated class to represent a multi-dimensional index,
        i.e. (i,j,k,...). Index is templated over the dimension of the index.
        ITK assumes the first element of an index is the fastest moving index.

        For efficiency sake, Index does not define a default constructor, a
        copy constructor, or an operator=. We rely on the compiler to provide
        efficient bitwise copies.

        Index is an "aggregate" class. Its data is public (m_Index) allowing
        for fast and convenient instantiations/assignments.

        The following syntax for assigning an index is allowed/suggested:

        Index<3> index = {{5, 2, 7}};

        The double braces {{ and }} are needed to prevent a compiler warning
        about a partly bracketed initializer.

        Should there be an itkBoundedIndex to handle bounds checking? Or
        should there be an API to perform bounded increments in the iterator.
        Wiki Examples:  All Examples

        https://www.itk.org/Wiki/ITK/Examples/SimpleOperations/DistanceBetween
        Indices Distance between two indices

        https://www.itk.org/Wiki/ITK/Examples/Images/Index An object which
        holds the index of a pixel

        C++ includes: itkIndex.h 
        """
        _itkIndexPython.itkIndex1_swiginit(self, _itkIndexPython.new_itkIndex1(*args))
    __swig_destroy__ = _itkIndexPython.delete_itkIndex1

    def __getitem__(self, d: 'unsigned long') -> "long":
        """__getitem__(itkIndex1 self, unsigned long d) -> long"""
        return _itkIndexPython.itkIndex1___getitem__(self, d)


    def __setitem__(self, d: 'unsigned long', v: 'long') -> "void":
        """__setitem__(itkIndex1 self, unsigned long d, long v)"""
        return _itkIndexPython.itkIndex1___setitem__(self, d, v)


    def __len__() -> "unsigned int":
        """__len__() -> unsigned int"""
        return _itkIndexPython.itkIndex1___len__()

    __len__ = staticmethod(__len__)

    def __repr__(self) -> "std::string":
        """__repr__(itkIndex1 self) -> std::string"""
        return _itkIndexPython.itkIndex1___repr__(self)

itkIndex1.__add__ = new_instancemethod(_itkIndexPython.itkIndex1___add__, None, itkIndex1)
itkIndex1.__iadd__ = new_instancemethod(_itkIndexPython.itkIndex1___iadd__, None, itkIndex1)
itkIndex1.__isub__ = new_instancemethod(_itkIndexPython.itkIndex1___isub__, None, itkIndex1)
itkIndex1.__sub__ = new_instancemethod(_itkIndexPython.itkIndex1___sub__, None, itkIndex1)
itkIndex1.__mul__ = new_instancemethod(_itkIndexPython.itkIndex1___mul__, None, itkIndex1)
itkIndex1.__eq__ = new_instancemethod(_itkIndexPython.itkIndex1___eq__, None, itkIndex1)
itkIndex1.__ne__ = new_instancemethod(_itkIndexPython.itkIndex1___ne__, None, itkIndex1)
itkIndex1.GetIndex = new_instancemethod(_itkIndexPython.itkIndex1_GetIndex, None, itkIndex1)
itkIndex1.SetIndex = new_instancemethod(_itkIndexPython.itkIndex1_SetIndex, None, itkIndex1)
itkIndex1.SetElement = new_instancemethod(_itkIndexPython.itkIndex1_SetElement, None, itkIndex1)
itkIndex1.GetElement = new_instancemethod(_itkIndexPython.itkIndex1_GetElement, None, itkIndex1)
itkIndex1.Fill = new_instancemethod(_itkIndexPython.itkIndex1_Fill, None, itkIndex1)
itkIndex1.__getitem__ = new_instancemethod(_itkIndexPython.itkIndex1___getitem__, None, itkIndex1)
itkIndex1.__setitem__ = new_instancemethod(_itkIndexPython.itkIndex1___setitem__, None, itkIndex1)
itkIndex1.__repr__ = new_instancemethod(_itkIndexPython.itkIndex1___repr__, None, itkIndex1)
itkIndex1_swigregister = _itkIndexPython.itkIndex1_swigregister
itkIndex1_swigregister(itkIndex1)

def itkIndex1_GetIndexDimension() -> "unsigned int":
    """itkIndex1_GetIndexDimension() -> unsigned int"""
    return _itkIndexPython.itkIndex1_GetIndexDimension()

def itkIndex1_GetBasisIndex(dim: 'unsigned int') -> "itkIndex1":
    """itkIndex1_GetBasisIndex(unsigned int dim) -> itkIndex1"""
    return _itkIndexPython.itkIndex1_GetBasisIndex(dim)

def itkIndex1___len__() -> "unsigned int":
    """itkIndex1___len__() -> unsigned int"""
    return _itkIndexPython.itkIndex1___len__()

class itkIndex2(object):
    """


    Represent a n-dimensional index in a n-dimensional image.

    Index is a templated class to represent a multi-dimensional index,
    i.e. (i,j,k,...). Index is templated over the dimension of the index.
    ITK assumes the first element of an index is the fastest moving index.

    For efficiency sake, Index does not define a default constructor, a
    copy constructor, or an operator=. We rely on the compiler to provide
    efficient bitwise copies.

    Index is an "aggregate" class. Its data is public (m_Index) allowing
    for fast and convenient instantiations/assignments.

    The following syntax for assigning an index is allowed/suggested:

    Index<3> index = {{5, 2, 7}};

    The double braces {{ and }} are needed to prevent a compiler warning
    about a partly bracketed initializer.

    Should there be an itkBoundedIndex to handle bounds checking? Or
    should there be an API to perform bounded increments in the iterator.
    Wiki Examples:  All Examples

    https://www.itk.org/Wiki/ITK/Examples/SimpleOperations/DistanceBetween
    Indices Distance between two indices

    https://www.itk.org/Wiki/ITK/Examples/Images/Index An object which
    holds the index of a pixel

    C++ includes: itkIndex.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def GetIndexDimension() -> "unsigned int":
        """GetIndexDimension() -> unsigned int"""
        return _itkIndexPython.itkIndex2_GetIndexDimension()

    GetIndexDimension = staticmethod(GetIndexDimension)

    def __add__(self, *args) -> "itkIndex2 const":
        """
        __add__(itkIndex2 self, itkSize2 size) -> itkIndex2
        __add__(itkIndex2 self, itkOffset2 offset) -> itkIndex2
        """
        return _itkIndexPython.itkIndex2___add__(self, *args)


    def __iadd__(self, *args) -> "itkIndex2 const &":
        """
        __iadd__(itkIndex2 self, itkSize2 size) -> itkIndex2
        __iadd__(itkIndex2 self, itkOffset2 offset) -> itkIndex2
        """
        return _itkIndexPython.itkIndex2___iadd__(self, *args)


    def __isub__(self, *args) -> "itkIndex2 const &":
        """
        __isub__(itkIndex2 self, itkSize2 size) -> itkIndex2
        __isub__(itkIndex2 self, itkOffset2 offset) -> itkIndex2
        """
        return _itkIndexPython.itkIndex2___isub__(self, *args)


    def __sub__(self, *args) -> "itkOffset2 const":
        """
        __sub__(itkIndex2 self, itkSize2 size) -> itkIndex2
        __sub__(itkIndex2 self, itkOffset2 off) -> itkIndex2
        __sub__(itkIndex2 self, itkIndex2 vec) -> itkOffset2
        """
        return _itkIndexPython.itkIndex2___sub__(self, *args)


    def __mul__(self, vec: 'itkSize2') -> "itkIndex2 const":
        """__mul__(itkIndex2 self, itkSize2 vec) -> itkIndex2"""
        return _itkIndexPython.itkIndex2___mul__(self, vec)


    def __eq__(self, vec: 'itkIndex2') -> "bool":
        """__eq__(itkIndex2 self, itkIndex2 vec) -> bool"""
        return _itkIndexPython.itkIndex2___eq__(self, vec)


    def __ne__(self, vec: 'itkIndex2') -> "bool":
        """__ne__(itkIndex2 self, itkIndex2 vec) -> bool"""
        return _itkIndexPython.itkIndex2___ne__(self, vec)


    def GetIndex(self) -> "long const *":
        """
        GetIndex(itkIndex2 self) -> long const *

        Get the index. This
        provides a read only reference to the index. See:   SetIndex() 
        """
        return _itkIndexPython.itkIndex2_GetIndex(self)


    def SetIndex(self, val: 'long const *') -> "void":
        """
        SetIndex(itkIndex2 self, long const * val)

        Set the index. Try to
        prototype this function so that val has to point to a block of memory
        that is the appropriate size. See:   GetIndex() 
        """
        return _itkIndexPython.itkIndex2_SetIndex(self, val)


    def SetElement(self, element: 'unsigned long', val: 'long') -> "void":
        """
        SetElement(itkIndex2 self, unsigned long element, long val)

        Sets the value of one of
        the elements in the index. This method is mainly intended to
        facilitate the access to elements from Tcl and Python where C++
        notation is not very convenient. WARNING:  No bound checking is
        performed

        See:   SetIndex()

        See:   GetElement() 
        """
        return _itkIndexPython.itkIndex2_SetElement(self, element, val)


    def GetElement(self, element: 'unsigned long') -> "long":
        """
        GetElement(itkIndex2 self, unsigned long element) -> long

        Gets the value of one of
        the elements in the index. This method is mainly intended to
        facilitate the access to elements from Tcl and Python where C++
        notation is not very convenient. WARNING:  No bound checking is
        performed

        See:   GetIndex()

        See:   SetElement() 
        """
        return _itkIndexPython.itkIndex2_GetElement(self, element)


    def GetBasisIndex(dim: 'unsigned int') -> "itkIndex2":
        """GetBasisIndex(unsigned int dim) -> itkIndex2"""
        return _itkIndexPython.itkIndex2_GetBasisIndex(dim)

    GetBasisIndex = staticmethod(GetBasisIndex)

    def Fill(self, value: 'long') -> "void":
        """
        Fill(itkIndex2 self, long value)

        Set one value for the index in
        all dimensions. Useful for initializing an offset to zero. 
        """
        return _itkIndexPython.itkIndex2_Fill(self, value)


    def __init__(self, *args):
        """
        __init__(itkIndex2 self) -> itkIndex2
        __init__(itkIndex2 self, itkIndex2 arg0) -> itkIndex2



        Represent a n-dimensional index in a n-dimensional image.

        Index is a templated class to represent a multi-dimensional index,
        i.e. (i,j,k,...). Index is templated over the dimension of the index.
        ITK assumes the first element of an index is the fastest moving index.

        For efficiency sake, Index does not define a default constructor, a
        copy constructor, or an operator=. We rely on the compiler to provide
        efficient bitwise copies.

        Index is an "aggregate" class. Its data is public (m_Index) allowing
        for fast and convenient instantiations/assignments.

        The following syntax for assigning an index is allowed/suggested:

        Index<3> index = {{5, 2, 7}};

        The double braces {{ and }} are needed to prevent a compiler warning
        about a partly bracketed initializer.

        Should there be an itkBoundedIndex to handle bounds checking? Or
        should there be an API to perform bounded increments in the iterator.
        Wiki Examples:  All Examples

        https://www.itk.org/Wiki/ITK/Examples/SimpleOperations/DistanceBetween
        Indices Distance between two indices

        https://www.itk.org/Wiki/ITK/Examples/Images/Index An object which
        holds the index of a pixel

        C++ includes: itkIndex.h 
        """
        _itkIndexPython.itkIndex2_swiginit(self, _itkIndexPython.new_itkIndex2(*args))
    __swig_destroy__ = _itkIndexPython.delete_itkIndex2

    def __getitem__(self, d: 'unsigned long') -> "long":
        """__getitem__(itkIndex2 self, unsigned long d) -> long"""
        return _itkIndexPython.itkIndex2___getitem__(self, d)


    def __setitem__(self, d: 'unsigned long', v: 'long') -> "void":
        """__setitem__(itkIndex2 self, unsigned long d, long v)"""
        return _itkIndexPython.itkIndex2___setitem__(self, d, v)


    def __len__() -> "unsigned int":
        """__len__() -> unsigned int"""
        return _itkIndexPython.itkIndex2___len__()

    __len__ = staticmethod(__len__)

    def __repr__(self) -> "std::string":
        """__repr__(itkIndex2 self) -> std::string"""
        return _itkIndexPython.itkIndex2___repr__(self)

itkIndex2.__add__ = new_instancemethod(_itkIndexPython.itkIndex2___add__, None, itkIndex2)
itkIndex2.__iadd__ = new_instancemethod(_itkIndexPython.itkIndex2___iadd__, None, itkIndex2)
itkIndex2.__isub__ = new_instancemethod(_itkIndexPython.itkIndex2___isub__, None, itkIndex2)
itkIndex2.__sub__ = new_instancemethod(_itkIndexPython.itkIndex2___sub__, None, itkIndex2)
itkIndex2.__mul__ = new_instancemethod(_itkIndexPython.itkIndex2___mul__, None, itkIndex2)
itkIndex2.__eq__ = new_instancemethod(_itkIndexPython.itkIndex2___eq__, None, itkIndex2)
itkIndex2.__ne__ = new_instancemethod(_itkIndexPython.itkIndex2___ne__, None, itkIndex2)
itkIndex2.GetIndex = new_instancemethod(_itkIndexPython.itkIndex2_GetIndex, None, itkIndex2)
itkIndex2.SetIndex = new_instancemethod(_itkIndexPython.itkIndex2_SetIndex, None, itkIndex2)
itkIndex2.SetElement = new_instancemethod(_itkIndexPython.itkIndex2_SetElement, None, itkIndex2)
itkIndex2.GetElement = new_instancemethod(_itkIndexPython.itkIndex2_GetElement, None, itkIndex2)
itkIndex2.Fill = new_instancemethod(_itkIndexPython.itkIndex2_Fill, None, itkIndex2)
itkIndex2.__getitem__ = new_instancemethod(_itkIndexPython.itkIndex2___getitem__, None, itkIndex2)
itkIndex2.__setitem__ = new_instancemethod(_itkIndexPython.itkIndex2___setitem__, None, itkIndex2)
itkIndex2.__repr__ = new_instancemethod(_itkIndexPython.itkIndex2___repr__, None, itkIndex2)
itkIndex2_swigregister = _itkIndexPython.itkIndex2_swigregister
itkIndex2_swigregister(itkIndex2)

def itkIndex2_GetIndexDimension() -> "unsigned int":
    """itkIndex2_GetIndexDimension() -> unsigned int"""
    return _itkIndexPython.itkIndex2_GetIndexDimension()

def itkIndex2_GetBasisIndex(dim: 'unsigned int') -> "itkIndex2":
    """itkIndex2_GetBasisIndex(unsigned int dim) -> itkIndex2"""
    return _itkIndexPython.itkIndex2_GetBasisIndex(dim)

def itkIndex2___len__() -> "unsigned int":
    """itkIndex2___len__() -> unsigned int"""
    return _itkIndexPython.itkIndex2___len__()

class itkIndex3(object):
    """


    Represent a n-dimensional index in a n-dimensional image.

    Index is a templated class to represent a multi-dimensional index,
    i.e. (i,j,k,...). Index is templated over the dimension of the index.
    ITK assumes the first element of an index is the fastest moving index.

    For efficiency sake, Index does not define a default constructor, a
    copy constructor, or an operator=. We rely on the compiler to provide
    efficient bitwise copies.

    Index is an "aggregate" class. Its data is public (m_Index) allowing
    for fast and convenient instantiations/assignments.

    The following syntax for assigning an index is allowed/suggested:

    Index<3> index = {{5, 2, 7}};

    The double braces {{ and }} are needed to prevent a compiler warning
    about a partly bracketed initializer.

    Should there be an itkBoundedIndex to handle bounds checking? Or
    should there be an API to perform bounded increments in the iterator.
    Wiki Examples:  All Examples

    https://www.itk.org/Wiki/ITK/Examples/SimpleOperations/DistanceBetween
    Indices Distance between two indices

    https://www.itk.org/Wiki/ITK/Examples/Images/Index An object which
    holds the index of a pixel

    C++ includes: itkIndex.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def GetIndexDimension() -> "unsigned int":
        """GetIndexDimension() -> unsigned int"""
        return _itkIndexPython.itkIndex3_GetIndexDimension()

    GetIndexDimension = staticmethod(GetIndexDimension)

    def __add__(self, *args) -> "itkIndex3 const":
        """
        __add__(itkIndex3 self, itkSize3 size) -> itkIndex3
        __add__(itkIndex3 self, itkOffset3 offset) -> itkIndex3
        """
        return _itkIndexPython.itkIndex3___add__(self, *args)


    def __iadd__(self, *args) -> "itkIndex3 const &":
        """
        __iadd__(itkIndex3 self, itkSize3 size) -> itkIndex3
        __iadd__(itkIndex3 self, itkOffset3 offset) -> itkIndex3
        """
        return _itkIndexPython.itkIndex3___iadd__(self, *args)


    def __isub__(self, *args) -> "itkIndex3 const &":
        """
        __isub__(itkIndex3 self, itkSize3 size) -> itkIndex3
        __isub__(itkIndex3 self, itkOffset3 offset) -> itkIndex3
        """
        return _itkIndexPython.itkIndex3___isub__(self, *args)


    def __sub__(self, *args) -> "itkOffset3 const":
        """
        __sub__(itkIndex3 self, itkSize3 size) -> itkIndex3
        __sub__(itkIndex3 self, itkOffset3 off) -> itkIndex3
        __sub__(itkIndex3 self, itkIndex3 vec) -> itkOffset3
        """
        return _itkIndexPython.itkIndex3___sub__(self, *args)


    def __mul__(self, vec: 'itkSize3') -> "itkIndex3 const":
        """__mul__(itkIndex3 self, itkSize3 vec) -> itkIndex3"""
        return _itkIndexPython.itkIndex3___mul__(self, vec)


    def __eq__(self, vec: 'itkIndex3') -> "bool":
        """__eq__(itkIndex3 self, itkIndex3 vec) -> bool"""
        return _itkIndexPython.itkIndex3___eq__(self, vec)


    def __ne__(self, vec: 'itkIndex3') -> "bool":
        """__ne__(itkIndex3 self, itkIndex3 vec) -> bool"""
        return _itkIndexPython.itkIndex3___ne__(self, vec)


    def GetIndex(self) -> "long const *":
        """
        GetIndex(itkIndex3 self) -> long const *

        Get the index. This
        provides a read only reference to the index. See:   SetIndex() 
        """
        return _itkIndexPython.itkIndex3_GetIndex(self)


    def SetIndex(self, val: 'long const *') -> "void":
        """
        SetIndex(itkIndex3 self, long const * val)

        Set the index. Try to
        prototype this function so that val has to point to a block of memory
        that is the appropriate size. See:   GetIndex() 
        """
        return _itkIndexPython.itkIndex3_SetIndex(self, val)


    def SetElement(self, element: 'unsigned long', val: 'long') -> "void":
        """
        SetElement(itkIndex3 self, unsigned long element, long val)

        Sets the value of one of
        the elements in the index. This method is mainly intended to
        facilitate the access to elements from Tcl and Python where C++
        notation is not very convenient. WARNING:  No bound checking is
        performed

        See:   SetIndex()

        See:   GetElement() 
        """
        return _itkIndexPython.itkIndex3_SetElement(self, element, val)


    def GetElement(self, element: 'unsigned long') -> "long":
        """
        GetElement(itkIndex3 self, unsigned long element) -> long

        Gets the value of one of
        the elements in the index. This method is mainly intended to
        facilitate the access to elements from Tcl and Python where C++
        notation is not very convenient. WARNING:  No bound checking is
        performed

        See:   GetIndex()

        See:   SetElement() 
        """
        return _itkIndexPython.itkIndex3_GetElement(self, element)


    def GetBasisIndex(dim: 'unsigned int') -> "itkIndex3":
        """GetBasisIndex(unsigned int dim) -> itkIndex3"""
        return _itkIndexPython.itkIndex3_GetBasisIndex(dim)

    GetBasisIndex = staticmethod(GetBasisIndex)

    def Fill(self, value: 'long') -> "void":
        """
        Fill(itkIndex3 self, long value)

        Set one value for the index in
        all dimensions. Useful for initializing an offset to zero. 
        """
        return _itkIndexPython.itkIndex3_Fill(self, value)


    def __init__(self, *args):
        """
        __init__(itkIndex3 self) -> itkIndex3
        __init__(itkIndex3 self, itkIndex3 arg0) -> itkIndex3



        Represent a n-dimensional index in a n-dimensional image.

        Index is a templated class to represent a multi-dimensional index,
        i.e. (i,j,k,...). Index is templated over the dimension of the index.
        ITK assumes the first element of an index is the fastest moving index.

        For efficiency sake, Index does not define a default constructor, a
        copy constructor, or an operator=. We rely on the compiler to provide
        efficient bitwise copies.

        Index is an "aggregate" class. Its data is public (m_Index) allowing
        for fast and convenient instantiations/assignments.

        The following syntax for assigning an index is allowed/suggested:

        Index<3> index = {{5, 2, 7}};

        The double braces {{ and }} are needed to prevent a compiler warning
        about a partly bracketed initializer.

        Should there be an itkBoundedIndex to handle bounds checking? Or
        should there be an API to perform bounded increments in the iterator.
        Wiki Examples:  All Examples

        https://www.itk.org/Wiki/ITK/Examples/SimpleOperations/DistanceBetween
        Indices Distance between two indices

        https://www.itk.org/Wiki/ITK/Examples/Images/Index An object which
        holds the index of a pixel

        C++ includes: itkIndex.h 
        """
        _itkIndexPython.itkIndex3_swiginit(self, _itkIndexPython.new_itkIndex3(*args))
    __swig_destroy__ = _itkIndexPython.delete_itkIndex3

    def __getitem__(self, d: 'unsigned long') -> "long":
        """__getitem__(itkIndex3 self, unsigned long d) -> long"""
        return _itkIndexPython.itkIndex3___getitem__(self, d)


    def __setitem__(self, d: 'unsigned long', v: 'long') -> "void":
        """__setitem__(itkIndex3 self, unsigned long d, long v)"""
        return _itkIndexPython.itkIndex3___setitem__(self, d, v)


    def __len__() -> "unsigned int":
        """__len__() -> unsigned int"""
        return _itkIndexPython.itkIndex3___len__()

    __len__ = staticmethod(__len__)

    def __repr__(self) -> "std::string":
        """__repr__(itkIndex3 self) -> std::string"""
        return _itkIndexPython.itkIndex3___repr__(self)

itkIndex3.__add__ = new_instancemethod(_itkIndexPython.itkIndex3___add__, None, itkIndex3)
itkIndex3.__iadd__ = new_instancemethod(_itkIndexPython.itkIndex3___iadd__, None, itkIndex3)
itkIndex3.__isub__ = new_instancemethod(_itkIndexPython.itkIndex3___isub__, None, itkIndex3)
itkIndex3.__sub__ = new_instancemethod(_itkIndexPython.itkIndex3___sub__, None, itkIndex3)
itkIndex3.__mul__ = new_instancemethod(_itkIndexPython.itkIndex3___mul__, None, itkIndex3)
itkIndex3.__eq__ = new_instancemethod(_itkIndexPython.itkIndex3___eq__, None, itkIndex3)
itkIndex3.__ne__ = new_instancemethod(_itkIndexPython.itkIndex3___ne__, None, itkIndex3)
itkIndex3.GetIndex = new_instancemethod(_itkIndexPython.itkIndex3_GetIndex, None, itkIndex3)
itkIndex3.SetIndex = new_instancemethod(_itkIndexPython.itkIndex3_SetIndex, None, itkIndex3)
itkIndex3.SetElement = new_instancemethod(_itkIndexPython.itkIndex3_SetElement, None, itkIndex3)
itkIndex3.GetElement = new_instancemethod(_itkIndexPython.itkIndex3_GetElement, None, itkIndex3)
itkIndex3.Fill = new_instancemethod(_itkIndexPython.itkIndex3_Fill, None, itkIndex3)
itkIndex3.__getitem__ = new_instancemethod(_itkIndexPython.itkIndex3___getitem__, None, itkIndex3)
itkIndex3.__setitem__ = new_instancemethod(_itkIndexPython.itkIndex3___setitem__, None, itkIndex3)
itkIndex3.__repr__ = new_instancemethod(_itkIndexPython.itkIndex3___repr__, None, itkIndex3)
itkIndex3_swigregister = _itkIndexPython.itkIndex3_swigregister
itkIndex3_swigregister(itkIndex3)

def itkIndex3_GetIndexDimension() -> "unsigned int":
    """itkIndex3_GetIndexDimension() -> unsigned int"""
    return _itkIndexPython.itkIndex3_GetIndexDimension()

def itkIndex3_GetBasisIndex(dim: 'unsigned int') -> "itkIndex3":
    """itkIndex3_GetBasisIndex(unsigned int dim) -> itkIndex3"""
    return _itkIndexPython.itkIndex3_GetBasisIndex(dim)

def itkIndex3___len__() -> "unsigned int":
    """itkIndex3___len__() -> unsigned int"""
    return _itkIndexPython.itkIndex3___len__()

class itkIndex4(object):
    """


    Represent a n-dimensional index in a n-dimensional image.

    Index is a templated class to represent a multi-dimensional index,
    i.e. (i,j,k,...). Index is templated over the dimension of the index.
    ITK assumes the first element of an index is the fastest moving index.

    For efficiency sake, Index does not define a default constructor, a
    copy constructor, or an operator=. We rely on the compiler to provide
    efficient bitwise copies.

    Index is an "aggregate" class. Its data is public (m_Index) allowing
    for fast and convenient instantiations/assignments.

    The following syntax for assigning an index is allowed/suggested:

    Index<3> index = {{5, 2, 7}};

    The double braces {{ and }} are needed to prevent a compiler warning
    about a partly bracketed initializer.

    Should there be an itkBoundedIndex to handle bounds checking? Or
    should there be an API to perform bounded increments in the iterator.
    Wiki Examples:  All Examples

    https://www.itk.org/Wiki/ITK/Examples/SimpleOperations/DistanceBetween
    Indices Distance between two indices

    https://www.itk.org/Wiki/ITK/Examples/Images/Index An object which
    holds the index of a pixel

    C++ includes: itkIndex.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def GetIndexDimension() -> "unsigned int":
        """GetIndexDimension() -> unsigned int"""
        return _itkIndexPython.itkIndex4_GetIndexDimension()

    GetIndexDimension = staticmethod(GetIndexDimension)

    def __add__(self, *args) -> "itkIndex4 const":
        """
        __add__(itkIndex4 self, itkSize4 size) -> itkIndex4
        __add__(itkIndex4 self, itkOffset4 offset) -> itkIndex4
        """
        return _itkIndexPython.itkIndex4___add__(self, *args)


    def __iadd__(self, *args) -> "itkIndex4 const &":
        """
        __iadd__(itkIndex4 self, itkSize4 size) -> itkIndex4
        __iadd__(itkIndex4 self, itkOffset4 offset) -> itkIndex4
        """
        return _itkIndexPython.itkIndex4___iadd__(self, *args)


    def __isub__(self, *args) -> "itkIndex4 const &":
        """
        __isub__(itkIndex4 self, itkSize4 size) -> itkIndex4
        __isub__(itkIndex4 self, itkOffset4 offset) -> itkIndex4
        """
        return _itkIndexPython.itkIndex4___isub__(self, *args)


    def __sub__(self, *args) -> "itkOffset4 const":
        """
        __sub__(itkIndex4 self, itkSize4 size) -> itkIndex4
        __sub__(itkIndex4 self, itkOffset4 off) -> itkIndex4
        __sub__(itkIndex4 self, itkIndex4 vec) -> itkOffset4
        """
        return _itkIndexPython.itkIndex4___sub__(self, *args)


    def __mul__(self, vec: 'itkSize4') -> "itkIndex4 const":
        """__mul__(itkIndex4 self, itkSize4 vec) -> itkIndex4"""
        return _itkIndexPython.itkIndex4___mul__(self, vec)


    def __eq__(self, vec: 'itkIndex4') -> "bool":
        """__eq__(itkIndex4 self, itkIndex4 vec) -> bool"""
        return _itkIndexPython.itkIndex4___eq__(self, vec)


    def __ne__(self, vec: 'itkIndex4') -> "bool":
        """__ne__(itkIndex4 self, itkIndex4 vec) -> bool"""
        return _itkIndexPython.itkIndex4___ne__(self, vec)


    def GetIndex(self) -> "long const *":
        """
        GetIndex(itkIndex4 self) -> long const *

        Get the index. This
        provides a read only reference to the index. See:   SetIndex() 
        """
        return _itkIndexPython.itkIndex4_GetIndex(self)


    def SetIndex(self, val: 'long const *') -> "void":
        """
        SetIndex(itkIndex4 self, long const * val)

        Set the index. Try to
        prototype this function so that val has to point to a block of memory
        that is the appropriate size. See:   GetIndex() 
        """
        return _itkIndexPython.itkIndex4_SetIndex(self, val)


    def SetElement(self, element: 'unsigned long', val: 'long') -> "void":
        """
        SetElement(itkIndex4 self, unsigned long element, long val)

        Sets the value of one of
        the elements in the index. This method is mainly intended to
        facilitate the access to elements from Tcl and Python where C++
        notation is not very convenient. WARNING:  No bound checking is
        performed

        See:   SetIndex()

        See:   GetElement() 
        """
        return _itkIndexPython.itkIndex4_SetElement(self, element, val)


    def GetElement(self, element: 'unsigned long') -> "long":
        """
        GetElement(itkIndex4 self, unsigned long element) -> long

        Gets the value of one of
        the elements in the index. This method is mainly intended to
        facilitate the access to elements from Tcl and Python where C++
        notation is not very convenient. WARNING:  No bound checking is
        performed

        See:   GetIndex()

        See:   SetElement() 
        """
        return _itkIndexPython.itkIndex4_GetElement(self, element)


    def GetBasisIndex(dim: 'unsigned int') -> "itkIndex4":
        """GetBasisIndex(unsigned int dim) -> itkIndex4"""
        return _itkIndexPython.itkIndex4_GetBasisIndex(dim)

    GetBasisIndex = staticmethod(GetBasisIndex)

    def Fill(self, value: 'long') -> "void":
        """
        Fill(itkIndex4 self, long value)

        Set one value for the index in
        all dimensions. Useful for initializing an offset to zero. 
        """
        return _itkIndexPython.itkIndex4_Fill(self, value)


    def __init__(self, *args):
        """
        __init__(itkIndex4 self) -> itkIndex4
        __init__(itkIndex4 self, itkIndex4 arg0) -> itkIndex4



        Represent a n-dimensional index in a n-dimensional image.

        Index is a templated class to represent a multi-dimensional index,
        i.e. (i,j,k,...). Index is templated over the dimension of the index.
        ITK assumes the first element of an index is the fastest moving index.

        For efficiency sake, Index does not define a default constructor, a
        copy constructor, or an operator=. We rely on the compiler to provide
        efficient bitwise copies.

        Index is an "aggregate" class. Its data is public (m_Index) allowing
        for fast and convenient instantiations/assignments.

        The following syntax for assigning an index is allowed/suggested:

        Index<3> index = {{5, 2, 7}};

        The double braces {{ and }} are needed to prevent a compiler warning
        about a partly bracketed initializer.

        Should there be an itkBoundedIndex to handle bounds checking? Or
        should there be an API to perform bounded increments in the iterator.
        Wiki Examples:  All Examples

        https://www.itk.org/Wiki/ITK/Examples/SimpleOperations/DistanceBetween
        Indices Distance between two indices

        https://www.itk.org/Wiki/ITK/Examples/Images/Index An object which
        holds the index of a pixel

        C++ includes: itkIndex.h 
        """
        _itkIndexPython.itkIndex4_swiginit(self, _itkIndexPython.new_itkIndex4(*args))
    __swig_destroy__ = _itkIndexPython.delete_itkIndex4

    def __getitem__(self, d: 'unsigned long') -> "long":
        """__getitem__(itkIndex4 self, unsigned long d) -> long"""
        return _itkIndexPython.itkIndex4___getitem__(self, d)


    def __setitem__(self, d: 'unsigned long', v: 'long') -> "void":
        """__setitem__(itkIndex4 self, unsigned long d, long v)"""
        return _itkIndexPython.itkIndex4___setitem__(self, d, v)


    def __len__() -> "unsigned int":
        """__len__() -> unsigned int"""
        return _itkIndexPython.itkIndex4___len__()

    __len__ = staticmethod(__len__)

    def __repr__(self) -> "std::string":
        """__repr__(itkIndex4 self) -> std::string"""
        return _itkIndexPython.itkIndex4___repr__(self)

itkIndex4.__add__ = new_instancemethod(_itkIndexPython.itkIndex4___add__, None, itkIndex4)
itkIndex4.__iadd__ = new_instancemethod(_itkIndexPython.itkIndex4___iadd__, None, itkIndex4)
itkIndex4.__isub__ = new_instancemethod(_itkIndexPython.itkIndex4___isub__, None, itkIndex4)
itkIndex4.__sub__ = new_instancemethod(_itkIndexPython.itkIndex4___sub__, None, itkIndex4)
itkIndex4.__mul__ = new_instancemethod(_itkIndexPython.itkIndex4___mul__, None, itkIndex4)
itkIndex4.__eq__ = new_instancemethod(_itkIndexPython.itkIndex4___eq__, None, itkIndex4)
itkIndex4.__ne__ = new_instancemethod(_itkIndexPython.itkIndex4___ne__, None, itkIndex4)
itkIndex4.GetIndex = new_instancemethod(_itkIndexPython.itkIndex4_GetIndex, None, itkIndex4)
itkIndex4.SetIndex = new_instancemethod(_itkIndexPython.itkIndex4_SetIndex, None, itkIndex4)
itkIndex4.SetElement = new_instancemethod(_itkIndexPython.itkIndex4_SetElement, None, itkIndex4)
itkIndex4.GetElement = new_instancemethod(_itkIndexPython.itkIndex4_GetElement, None, itkIndex4)
itkIndex4.Fill = new_instancemethod(_itkIndexPython.itkIndex4_Fill, None, itkIndex4)
itkIndex4.__getitem__ = new_instancemethod(_itkIndexPython.itkIndex4___getitem__, None, itkIndex4)
itkIndex4.__setitem__ = new_instancemethod(_itkIndexPython.itkIndex4___setitem__, None, itkIndex4)
itkIndex4.__repr__ = new_instancemethod(_itkIndexPython.itkIndex4___repr__, None, itkIndex4)
itkIndex4_swigregister = _itkIndexPython.itkIndex4_swigregister
itkIndex4_swigregister(itkIndex4)

def itkIndex4_GetIndexDimension() -> "unsigned int":
    """itkIndex4_GetIndexDimension() -> unsigned int"""
    return _itkIndexPython.itkIndex4_GetIndexDimension()

def itkIndex4_GetBasisIndex(dim: 'unsigned int') -> "itkIndex4":
    """itkIndex4_GetBasisIndex(unsigned int dim) -> itkIndex4"""
    return _itkIndexPython.itkIndex4_GetBasisIndex(dim)

def itkIndex4___len__() -> "unsigned int":
    """itkIndex4___len__() -> unsigned int"""
    return _itkIndexPython.itkIndex4___len__()



