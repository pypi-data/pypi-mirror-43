# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.8
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (3, 0, 0):
    new_instancemethod = lambda func, inst, cls: _itkMeshBasePython.SWIG_PyInstanceMethod_New(func)
else:
    from new import instancemethod as new_instancemethod
if version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_itkMeshBasePython', [dirname(__file__)])
        except ImportError:
            import _itkMeshBasePython
            return _itkMeshBasePython
        if fp is not None:
            try:
                _mod = imp.load_module('_itkMeshBasePython', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _itkMeshBasePython = swig_import_helper()
    del swig_import_helper
else:
    import _itkMeshBasePython
del version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.


def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr_nondynamic(self, class_type, name, static=1):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    if (not static):
        return object.__getattr__(self, name)
    else:
        raise AttributeError(name)

def _swig_getattr(self, class_type, name):
    return _swig_getattr_nondynamic(self, class_type, name, 0)


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object:
        pass
    _newclass = 0



def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


import itkMapContainerPython
import itkPointPython
import itkFixedArrayPython
import pyBasePython
import itkVectorPython
import vnl_vector_refPython
import stdcomplexPython
import vnl_vectorPython
import vnl_matrixPython
import ITKCommonBasePython
import itkBoundingBoxPython
import itkVectorContainerPython
import itkContinuousIndexPython
import itkIndexPython
import itkSizePython
import itkOffsetPython
import itkMatrixPython
import itkCovariantVectorPython
import vnl_matrix_fixedPython
import itkArrayPython
import itkPointSetPython

def itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_New():
  return itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3.New()


def itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_New():
  return itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.New()


def itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_New():
  return itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2.New()


def itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_New():
  return itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.New()


def itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_New():
  return itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.New()


def itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_New():
  return itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.New()


def itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_New():
  return itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.New()


def itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_New():
  return itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.New()


def itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_New():
  return itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.New()


def itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_New():
  return itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.New()


def itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_New():
  return itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.New()


def itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_New():
  return itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.New()


def itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_New():
  return itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.New()


def itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_New():
  return itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.New()


def itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_New():
  return itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.New()


def itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_New():
  return itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.New()


def itkMeshD3STD33DFD_New():
  return itkMeshD3STD33DFD.New()


def itkMeshD3DTD33DFD_New():
  return itkMeshD3DTD33DFD.New()


def itkMeshD2STD22DFD_New():
  return itkMeshD2STD22DFD.New()


def itkMeshD2DTD22DFD_New():
  return itkMeshD2DTD22DFD.New()


def itkMeshD3DTD33D_New():
  return itkMeshD3DTD33D.New()


def itkMeshD3STD33D_New():
  return itkMeshD3STD33D.New()


def itkMeshD3DTD33DD_New():
  return itkMeshD3DTD33DD.New()


def itkMeshD3STD33DD_New():
  return itkMeshD3STD33DD.New()


def itkMeshF3DTF33F_New():
  return itkMeshF3DTF33F.New()


def itkMeshF3STF33F_New():
  return itkMeshF3STF33F.New()


def itkMeshF3DTF33FF_New():
  return itkMeshF3DTF33FF.New()


def itkMeshF3STF33FF_New():
  return itkMeshF3STF33FF.New()


def itkMeshD2DTD22D_New():
  return itkMeshD2DTD22D.New()


def itkMeshD2STD22D_New():
  return itkMeshD2STD22D.New()


def itkMeshD2DTD22DD_New():
  return itkMeshD2DTD22DD.New()


def itkMeshD2STD22DD_New():
  return itkMeshD2STD22DD.New()


def itkMeshF2DTF22F_New():
  return itkMeshF2DTF22F.New()


def itkMeshF2STF22F_New():
  return itkMeshF2STF22F.New()


def itkMeshF2DTF22FF_New():
  return itkMeshF2DTF22FF.New()


def itkMeshF2STF22FF_New():
  return itkMeshF2STF22FF.New()

class itkCellInterfaceDCTI2DDULULULPD2MCULPD2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VERTEX_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_VERTEX_CELL
    LINE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_LINE_CELL
    TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_TRIANGLE_CELL
    QUADRILATERAL_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_QUADRILATERAL_CELL
    POLYGON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_POLYGON_CELL
    TETRAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_TETRAHEDRON_CELL
    HEXAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_HEXAHEDRON_CELL
    QUADRATIC_EDGE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_QUADRATIC_EDGE_CELL
    QUADRATIC_TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_QUADRATIC_TRIANGLE_CELL
    LAST_ITK_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_LAST_ITK_CELL
    MAX_ITK_CELLS = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_MAX_ITK_CELLS

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, unsigned long cellId, itkCellInterfaceDCTI2DDULULULPD2MCULPD2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI2DDULULULPD2MCULPD2::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> itkCellInterfaceDCTI2DDULULULPD2MCULPD2::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, int dimension, unsigned long arg1, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, double * arg0, bool * arg1, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkMapContainerULPD2', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, double * arg0, itkMapContainerULPD2 arg1, double * arg2, double * arg3, double * arg4, double * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayD') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, itkArrayD arg0, itkArrayD arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI2DDULULULPD2MCULPD2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI2DDULULULPD2MCULPD2
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_Accept, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetType, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_MakeCopy, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetDimension, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetInterpolationOrder, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetNumberOfPoints, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetBoundaryFeature, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetPointIds, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_SetPointIds, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_SetPointId, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_PointIdsBegin, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_PointIdsEnd, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetPointIdsContainer, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_SetPointIdsContainer, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetClosestBoundary, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_EvaluatePosition, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_EvaluateShapeFunctions, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_IntersectWithLine, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetBoundingBox, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_IsExplicitBoundary, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AddUsingCell, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_RemoveUsingCell, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_IsUsingCell, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetNumberOfUsingCells, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_GetNameOfClass, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_swigregister
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_swigregister(itkCellInterfaceDCTI2DDULULULPD2MCULPD2)

class itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer
        __init__(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer p) -> itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer
        __init__(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2 p, bool takeOwnership) -> itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceDCTI2DDULULULPD2MCULPD2 *":
        """__deref__(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DDULULULPD2MCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self)
        TakeOwnership(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2') -> "void":
        """TakeNoOwnership(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceDCTI2DDULULULPD2MCULPD2 *":
        """ReleaseOwnership(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DDULULULPD2MCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceDCTI2DDULULULPD2MCULPD2 *":
        """GetPointer(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DDULULULPD2MCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, unsigned long cellId, itkCellInterfaceDCTI2DDULULULPD2MCULPD2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI2DDULULULPD2MCULPD2::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DDULULULPD2MCULPD2::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, double * arg0, bool * arg1, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkMapContainerULPD2', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, double * arg0, itkMapContainerULPD2 arg1, double * arg2, double * arg3, double * arg4, double * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayD') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, itkArrayD arg0, itkArrayD arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___deref__, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_Reset, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_TakeOwnership, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_IsOwner, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetPointer, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___eq__, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___ne__, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___lt__, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___gt__, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___le__, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer___ge__, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_Accept, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetType, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_MakeCopy, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetDimension, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetPointIds, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_SetPointIds, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_SetPointId, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_PointIdsBegin, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_PointIdsEnd, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_EvaluatePosition, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_IntersectWithLine, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetBoundingBox, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_AddUsingCell, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_IsUsingCell, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_GetNameOfClass, None, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_swigregister
itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer_swigregister(itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer)

class itkCellInterfaceDCTI2DDULULULPD2VCULPD2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VERTEX_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_VERTEX_CELL
    LINE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_LINE_CELL
    TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_TRIANGLE_CELL
    QUADRILATERAL_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_QUADRILATERAL_CELL
    POLYGON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_POLYGON_CELL
    TETRAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_TETRAHEDRON_CELL
    HEXAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_HEXAHEDRON_CELL
    QUADRATIC_EDGE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_QUADRATIC_EDGE_CELL
    QUADRATIC_TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_QUADRATIC_TRIANGLE_CELL
    LAST_ITK_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_LAST_ITK_CELL
    MAX_ITK_CELLS = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_MAX_ITK_CELLS

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, unsigned long cellId, itkCellInterfaceDCTI2DDULULULPD2VCULPD2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI2DDULULULPD2VCULPD2::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> itkCellInterfaceDCTI2DDULULULPD2VCULPD2::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, int dimension, unsigned long arg1, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, double * arg0, bool * arg1, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkVectorContainerULPD2', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, double * arg0, itkVectorContainerULPD2 arg1, double * arg2, double * arg3, double * arg4, double * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayD') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, itkArrayD arg0, itkArrayD arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI2DDULULULPD2VCULPD2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI2DDULULULPD2VCULPD2
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_Accept, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetType, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_MakeCopy, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetDimension, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetInterpolationOrder, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetNumberOfPoints, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetBoundaryFeature, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetPointIds, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_SetPointIds, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_SetPointId, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_PointIdsBegin, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_PointIdsEnd, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetPointIdsContainer, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_SetPointIdsContainer, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetClosestBoundary, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_EvaluatePosition, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_EvaluateShapeFunctions, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_IntersectWithLine, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetBoundingBox, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_IsExplicitBoundary, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AddUsingCell, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_RemoveUsingCell, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_IsUsingCell, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetNumberOfUsingCells, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_GetNameOfClass, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_swigregister
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_swigregister(itkCellInterfaceDCTI2DDULULULPD2VCULPD2)

class itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer
        __init__(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer p) -> itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer
        __init__(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2 p, bool takeOwnership) -> itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceDCTI2DDULULULPD2VCULPD2 *":
        """__deref__(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DDULULULPD2VCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self)
        TakeOwnership(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2') -> "void":
        """TakeNoOwnership(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceDCTI2DDULULULPD2VCULPD2 *":
        """ReleaseOwnership(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DDULULULPD2VCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceDCTI2DDULULULPD2VCULPD2 *":
        """GetPointer(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DDULULULPD2VCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, unsigned long cellId, itkCellInterfaceDCTI2DDULULULPD2VCULPD2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI2DDULULULPD2VCULPD2::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DDULULULPD2VCULPD2::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, double * arg0, bool * arg1, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkVectorContainerULPD2', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, double * arg0, itkVectorContainerULPD2 arg1, double * arg2, double * arg3, double * arg4, double * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayD') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, itkArrayD arg0, itkArrayD arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___deref__, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_Reset, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_TakeOwnership, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_IsOwner, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetPointer, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___eq__, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___ne__, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___lt__, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___gt__, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___le__, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer___ge__, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_Accept, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetType, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_MakeCopy, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetDimension, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetPointIds, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_SetPointIds, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_SetPointId, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_PointIdsBegin, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_PointIdsEnd, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_EvaluatePosition, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_IntersectWithLine, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetBoundingBox, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_AddUsingCell, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_IsUsingCell, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_GetNameOfClass, None, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_swigregister
itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer_swigregister(itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer)

class itkCellInterfaceDCTI2DFULULULPD2MCULPD2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VERTEX_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_VERTEX_CELL
    LINE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_LINE_CELL
    TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_TRIANGLE_CELL
    QUADRILATERAL_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_QUADRILATERAL_CELL
    POLYGON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_POLYGON_CELL
    TETRAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_TETRAHEDRON_CELL
    HEXAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_HEXAHEDRON_CELL
    QUADRATIC_EDGE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_QUADRATIC_EDGE_CELL
    QUADRATIC_TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_QUADRATIC_TRIANGLE_CELL
    LAST_ITK_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_LAST_ITK_CELL
    MAX_ITK_CELLS = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_MAX_ITK_CELLS

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, unsigned long cellId, itkCellInterfaceDCTI2DFULULULPD2MCULPD2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI2DFULULULPD2MCULPD2::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> itkCellInterfaceDCTI2DFULULULPD2MCULPD2::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, int dimension, unsigned long arg1, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, double * arg0, bool * arg1, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkMapContainerULPD2', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, double * arg0, itkMapContainerULPD2 arg1, double * arg2, double * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, itkArrayD arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI2DFULULULPD2MCULPD2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI2DFULULULPD2MCULPD2
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_Accept, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetType, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_MakeCopy, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetDimension, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetInterpolationOrder, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetNumberOfPoints, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetBoundaryFeature, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetPointIds, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_SetPointIds, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_SetPointId, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_PointIdsBegin, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_PointIdsEnd, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetPointIdsContainer, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_SetPointIdsContainer, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetClosestBoundary, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_EvaluatePosition, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_EvaluateShapeFunctions, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_IntersectWithLine, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetBoundingBox, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_IsExplicitBoundary, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AddUsingCell, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_RemoveUsingCell, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_IsUsingCell, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetNumberOfUsingCells, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_GetNameOfClass, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_swigregister
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_swigregister(itkCellInterfaceDCTI2DFULULULPD2MCULPD2)

class itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer
        __init__(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer p) -> itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer
        __init__(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2 p, bool takeOwnership) -> itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceDCTI2DFULULULPD2MCULPD2 *":
        """__deref__(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DFULULULPD2MCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self)
        TakeOwnership(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2') -> "void":
        """TakeNoOwnership(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceDCTI2DFULULULPD2MCULPD2 *":
        """ReleaseOwnership(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DFULULULPD2MCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceDCTI2DFULULULPD2MCULPD2 *":
        """GetPointer(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DFULULULPD2MCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, unsigned long cellId, itkCellInterfaceDCTI2DFULULULPD2MCULPD2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI2DFULULULPD2MCULPD2::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DFULULULPD2MCULPD2::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, double * arg0, bool * arg1, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkMapContainerULPD2', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, double * arg0, itkMapContainerULPD2 arg1, double * arg2, double * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, itkArrayD arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___deref__, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_Reset, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_TakeOwnership, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_IsOwner, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetPointer, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___eq__, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___ne__, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___lt__, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___gt__, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___le__, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer___ge__, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_Accept, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetType, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_MakeCopy, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetDimension, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetPointIds, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_SetPointIds, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_SetPointId, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_PointIdsBegin, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_PointIdsEnd, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_EvaluatePosition, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_IntersectWithLine, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetBoundingBox, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_AddUsingCell, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_IsUsingCell, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_GetNameOfClass, None, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_swigregister
itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer_swigregister(itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer)

class itkCellInterfaceDCTI2DFULULULPD2VCULPD2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VERTEX_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_VERTEX_CELL
    LINE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_LINE_CELL
    TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_TRIANGLE_CELL
    QUADRILATERAL_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_QUADRILATERAL_CELL
    POLYGON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_POLYGON_CELL
    TETRAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_TETRAHEDRON_CELL
    HEXAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_HEXAHEDRON_CELL
    QUADRATIC_EDGE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_QUADRATIC_EDGE_CELL
    QUADRATIC_TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_QUADRATIC_TRIANGLE_CELL
    LAST_ITK_CELL = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_LAST_ITK_CELL
    MAX_ITK_CELLS = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_MAX_ITK_CELLS

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, unsigned long cellId, itkCellInterfaceDCTI2DFULULULPD2VCULPD2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI2DFULULULPD2VCULPD2::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> itkCellInterfaceDCTI2DFULULULPD2VCULPD2::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, int dimension, unsigned long arg1, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, double * arg0, bool * arg1, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkVectorContainerULPD2', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, double * arg0, itkVectorContainerULPD2 arg1, double * arg2, double * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, itkArrayD arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI2DFULULULPD2VCULPD2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI2DFULULULPD2VCULPD2
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_Accept, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetType, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_MakeCopy, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetDimension, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetInterpolationOrder, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetNumberOfPoints, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetBoundaryFeature, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetPointIds, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_SetPointIds, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_SetPointId, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_PointIdsBegin, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_PointIdsEnd, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetPointIdsContainer, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_SetPointIdsContainer, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetClosestBoundary, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_EvaluatePosition, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_EvaluateShapeFunctions, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_IntersectWithLine, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetBoundingBox, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_IsExplicitBoundary, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AddUsingCell, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_RemoveUsingCell, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_IsUsingCell, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetNumberOfUsingCells, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_GetNameOfClass, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_swigregister
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_swigregister(itkCellInterfaceDCTI2DFULULULPD2VCULPD2)

class itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer
        __init__(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer p) -> itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer
        __init__(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2 p, bool takeOwnership) -> itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceDCTI2DFULULULPD2VCULPD2 *":
        """__deref__(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DFULULULPD2VCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self)
        TakeOwnership(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2') -> "void":
        """TakeNoOwnership(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceDCTI2DFULULULPD2VCULPD2 *":
        """ReleaseOwnership(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DFULULULPD2VCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceDCTI2DFULULULPD2VCULPD2 *":
        """GetPointer(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DFULULULPD2VCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, unsigned long cellId, itkCellInterfaceDCTI2DFULULULPD2VCULPD2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI2DFULULULPD2VCULPD2::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> itkCellInterfaceDCTI2DFULULULPD2VCULPD2::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, double * arg0, bool * arg1, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkVectorContainerULPD2', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, double * arg0, itkVectorContainerULPD2 arg1, double * arg2, double * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, itkArrayD arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___deref__, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_Reset, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_TakeOwnership, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_IsOwner, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetPointer, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___eq__, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___ne__, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___lt__, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___gt__, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___le__, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer___ge__, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_Accept, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetType, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_MakeCopy, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetDimension, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetPointIds, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_SetPointIds, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_SetPointId, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_PointIdsBegin, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_PointIdsEnd, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_EvaluatePosition, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_IntersectWithLine, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetBoundingBox, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_AddUsingCell, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_IsUsingCell, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_GetNameOfClass, None, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_swigregister
itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer_swigregister(itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer)

class itkCellInterfaceDCTI3DDULULULPD3MCULPD3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VERTEX_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_VERTEX_CELL
    LINE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_LINE_CELL
    TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_TRIANGLE_CELL
    QUADRILATERAL_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_QUADRILATERAL_CELL
    POLYGON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_POLYGON_CELL
    TETRAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_TETRAHEDRON_CELL
    HEXAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_HEXAHEDRON_CELL
    QUADRATIC_EDGE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_QUADRATIC_EDGE_CELL
    QUADRATIC_TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_QUADRATIC_TRIANGLE_CELL
    LAST_ITK_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_LAST_ITK_CELL
    MAX_ITK_CELLS = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_MAX_ITK_CELLS

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, unsigned long cellId, itkCellInterfaceDCTI3DDULULULPD3MCULPD3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI3DDULULULPD3MCULPD3::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> itkCellInterfaceDCTI3DDULULULPD3MCULPD3::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, int dimension, unsigned long arg1, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, double * arg0, bool * arg1, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkMapContainerULPD3', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, double * arg0, itkMapContainerULPD3 arg1, double * arg2, double * arg3, double * arg4, double * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayD') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, itkArrayD arg0, itkArrayD arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI3DDULULULPD3MCULPD3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI3DDULULULPD3MCULPD3
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_Accept, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetType, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_MakeCopy, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetDimension, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetInterpolationOrder, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetNumberOfPoints, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetBoundaryFeature, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetPointIds, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_SetPointIds, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_SetPointId, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_PointIdsBegin, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_PointIdsEnd, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetPointIdsContainer, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_SetPointIdsContainer, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetClosestBoundary, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_EvaluatePosition, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_EvaluateShapeFunctions, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_IntersectWithLine, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetBoundingBox, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_IsExplicitBoundary, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AddUsingCell, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_RemoveUsingCell, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_IsUsingCell, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetNumberOfUsingCells, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_GetNameOfClass, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_swigregister
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_swigregister(itkCellInterfaceDCTI3DDULULULPD3MCULPD3)

class itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer
        __init__(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer p) -> itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer
        __init__(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3 p, bool takeOwnership) -> itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceDCTI3DDULULULPD3MCULPD3 *":
        """__deref__(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DDULULULPD3MCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self)
        TakeOwnership(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3') -> "void":
        """TakeNoOwnership(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceDCTI3DDULULULPD3MCULPD3 *":
        """ReleaseOwnership(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DDULULULPD3MCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceDCTI3DDULULULPD3MCULPD3 *":
        """GetPointer(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DDULULULPD3MCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, unsigned long cellId, itkCellInterfaceDCTI3DDULULULPD3MCULPD3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI3DDULULULPD3MCULPD3::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DDULULULPD3MCULPD3::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, double * arg0, bool * arg1, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkMapContainerULPD3', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, double * arg0, itkMapContainerULPD3 arg1, double * arg2, double * arg3, double * arg4, double * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayD') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, itkArrayD arg0, itkArrayD arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___deref__, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_Reset, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_TakeOwnership, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_IsOwner, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetPointer, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___eq__, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___ne__, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___lt__, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___gt__, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___le__, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer___ge__, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_Accept, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetType, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_MakeCopy, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetDimension, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetPointIds, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_SetPointIds, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_SetPointId, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_PointIdsBegin, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_PointIdsEnd, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_EvaluatePosition, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_IntersectWithLine, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetBoundingBox, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_AddUsingCell, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_IsUsingCell, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_GetNameOfClass, None, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_swigregister
itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer_swigregister(itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer)

class itkCellInterfaceDCTI3DDULULULPD3VCULPD3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VERTEX_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_VERTEX_CELL
    LINE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_LINE_CELL
    TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_TRIANGLE_CELL
    QUADRILATERAL_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_QUADRILATERAL_CELL
    POLYGON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_POLYGON_CELL
    TETRAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_TETRAHEDRON_CELL
    HEXAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_HEXAHEDRON_CELL
    QUADRATIC_EDGE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_QUADRATIC_EDGE_CELL
    QUADRATIC_TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_QUADRATIC_TRIANGLE_CELL
    LAST_ITK_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_LAST_ITK_CELL
    MAX_ITK_CELLS = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_MAX_ITK_CELLS

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, unsigned long cellId, itkCellInterfaceDCTI3DDULULULPD3VCULPD3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI3DDULULULPD3VCULPD3::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> itkCellInterfaceDCTI3DDULULULPD3VCULPD3::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, int dimension, unsigned long arg1, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, double * arg0, bool * arg1, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkVectorContainerULPD3', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, double * arg0, itkVectorContainerULPD3 arg1, double * arg2, double * arg3, double * arg4, double * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayD') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, itkArrayD arg0, itkArrayD arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI3DDULULULPD3VCULPD3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI3DDULULULPD3VCULPD3
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_Accept, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetType, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_MakeCopy, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetDimension, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetInterpolationOrder, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetNumberOfPoints, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetBoundaryFeature, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetPointIds, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_SetPointIds, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_SetPointId, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_PointIdsBegin, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_PointIdsEnd, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetPointIdsContainer, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_SetPointIdsContainer, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetClosestBoundary, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_EvaluatePosition, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_EvaluateShapeFunctions, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_IntersectWithLine, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetBoundingBox, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_IsExplicitBoundary, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AddUsingCell, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_RemoveUsingCell, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_IsUsingCell, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetNumberOfUsingCells, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_GetNameOfClass, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_swigregister
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_swigregister(itkCellInterfaceDCTI3DDULULULPD3VCULPD3)

class itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer
        __init__(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer p) -> itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer
        __init__(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3 p, bool takeOwnership) -> itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceDCTI3DDULULULPD3VCULPD3 *":
        """__deref__(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DDULULULPD3VCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self)
        TakeOwnership(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3') -> "void":
        """TakeNoOwnership(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceDCTI3DDULULULPD3VCULPD3 *":
        """ReleaseOwnership(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DDULULULPD3VCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceDCTI3DDULULULPD3VCULPD3 *":
        """GetPointer(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DDULULULPD3VCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, unsigned long cellId, itkCellInterfaceDCTI3DDULULULPD3VCULPD3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI3DDULULULPD3VCULPD3::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DDULULULPD3VCULPD3::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, double * arg0, bool * arg1, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkVectorContainerULPD3', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, double * arg0, itkVectorContainerULPD3 arg1, double * arg2, double * arg3, double * arg4, double * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayD') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, itkArrayD arg0, itkArrayD arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___deref__, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_Reset, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_TakeOwnership, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_IsOwner, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetPointer, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___eq__, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___ne__, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___lt__, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___gt__, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___le__, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer___ge__, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_Accept, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetType, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_MakeCopy, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetDimension, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetPointIds, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_SetPointIds, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_SetPointId, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_PointIdsBegin, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_PointIdsEnd, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_EvaluatePosition, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_IntersectWithLine, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetBoundingBox, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_AddUsingCell, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_IsUsingCell, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_GetNameOfClass, None, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_swigregister
itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer_swigregister(itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer)

class itkCellInterfaceDCTI3DFULULULPD3MCULPD3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VERTEX_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_VERTEX_CELL
    LINE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_LINE_CELL
    TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_TRIANGLE_CELL
    QUADRILATERAL_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_QUADRILATERAL_CELL
    POLYGON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_POLYGON_CELL
    TETRAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_TETRAHEDRON_CELL
    HEXAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_HEXAHEDRON_CELL
    QUADRATIC_EDGE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_QUADRATIC_EDGE_CELL
    QUADRATIC_TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_QUADRATIC_TRIANGLE_CELL
    LAST_ITK_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_LAST_ITK_CELL
    MAX_ITK_CELLS = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_MAX_ITK_CELLS

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, unsigned long cellId, itkCellInterfaceDCTI3DFULULULPD3MCULPD3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI3DFULULULPD3MCULPD3::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> itkCellInterfaceDCTI3DFULULULPD3MCULPD3::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, int dimension, unsigned long arg1, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, double * arg0, bool * arg1, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkMapContainerULPD3', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, double * arg0, itkMapContainerULPD3 arg1, double * arg2, double * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, itkArrayD arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI3DFULULULPD3MCULPD3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI3DFULULULPD3MCULPD3
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_Accept, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetType, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_MakeCopy, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetDimension, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetInterpolationOrder, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetNumberOfPoints, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetBoundaryFeature, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetPointIds, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_SetPointIds, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_SetPointId, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_PointIdsBegin, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_PointIdsEnd, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetPointIdsContainer, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_SetPointIdsContainer, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetClosestBoundary, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_EvaluatePosition, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_EvaluateShapeFunctions, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_IntersectWithLine, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetBoundingBox, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_IsExplicitBoundary, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AddUsingCell, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_RemoveUsingCell, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_IsUsingCell, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetNumberOfUsingCells, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_GetNameOfClass, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_swigregister
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_swigregister(itkCellInterfaceDCTI3DFULULULPD3MCULPD3)

class itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer
        __init__(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer p) -> itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer
        __init__(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3 p, bool takeOwnership) -> itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceDCTI3DFULULULPD3MCULPD3 *":
        """__deref__(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DFULULULPD3MCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self)
        TakeOwnership(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3') -> "void":
        """TakeNoOwnership(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceDCTI3DFULULULPD3MCULPD3 *":
        """ReleaseOwnership(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DFULULULPD3MCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceDCTI3DFULULULPD3MCULPD3 *":
        """GetPointer(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DFULULULPD3MCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, unsigned long cellId, itkCellInterfaceDCTI3DFULULULPD3MCULPD3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI3DFULULULPD3MCULPD3::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DFULULULPD3MCULPD3::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, double * arg0, bool * arg1, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkMapContainerULPD3', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, double * arg0, itkMapContainerULPD3 arg1, double * arg2, double * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, itkArrayD arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___deref__, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_Reset, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_TakeOwnership, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_IsOwner, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetPointer, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___eq__, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___ne__, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___lt__, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___gt__, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___le__, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer___ge__, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_Accept, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetType, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_MakeCopy, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetDimension, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetPointIds, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_SetPointIds, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_SetPointId, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_PointIdsBegin, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_PointIdsEnd, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_EvaluatePosition, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_IntersectWithLine, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetBoundingBox, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_AddUsingCell, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_IsUsingCell, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_GetNameOfClass, None, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_swigregister
itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer_swigregister(itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer)

class itkCellInterfaceDCTI3DFULULULPD3VCULPD3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VERTEX_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_VERTEX_CELL
    LINE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_LINE_CELL
    TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_TRIANGLE_CELL
    QUADRILATERAL_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_QUADRILATERAL_CELL
    POLYGON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_POLYGON_CELL
    TETRAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_TETRAHEDRON_CELL
    HEXAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_HEXAHEDRON_CELL
    QUADRATIC_EDGE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_QUADRATIC_EDGE_CELL
    QUADRATIC_TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_QUADRATIC_TRIANGLE_CELL
    LAST_ITK_CELL = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_LAST_ITK_CELL
    MAX_ITK_CELLS = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_MAX_ITK_CELLS

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, unsigned long cellId, itkCellInterfaceDCTI3DFULULULPD3VCULPD3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI3DFULULULPD3VCULPD3::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> itkCellInterfaceDCTI3DFULULULPD3VCULPD3::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, int dimension, unsigned long arg1, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, double * arg0, bool * arg1, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkVectorContainerULPD3', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, double * arg0, itkVectorContainerULPD3 arg1, double * arg2, double * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, itkArrayD arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI3DFULULULPD3VCULPD3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI3DFULULULPD3VCULPD3
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_Accept, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetType, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_MakeCopy, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetDimension, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetInterpolationOrder, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetNumberOfPoints, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetBoundaryFeature, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetPointIds, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_SetPointIds, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_SetPointId, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_PointIdsBegin, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_PointIdsEnd, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetPointIdsContainer, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_SetPointIdsContainer, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetClosestBoundary, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_EvaluatePosition, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_EvaluateShapeFunctions, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_IntersectWithLine, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetBoundingBox, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_IsExplicitBoundary, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AddUsingCell, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_RemoveUsingCell, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_IsUsingCell, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetNumberOfUsingCells, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_GetNameOfClass, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_swigregister
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_swigregister(itkCellInterfaceDCTI3DFULULULPD3VCULPD3)

class itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer
        __init__(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer p) -> itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer
        __init__(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3 p, bool takeOwnership) -> itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceDCTI3DFULULULPD3VCULPD3 *":
        """__deref__(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DFULULULPD3VCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self)
        TakeOwnership(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3') -> "void":
        """TakeNoOwnership(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceDCTI3DFULULULPD3VCULPD3 *":
        """ReleaseOwnership(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DFULULULPD3VCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceDCTI3DFULULULPD3VCULPD3 *":
        """GetPointer(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DFULULULPD3VCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, unsigned long cellId, itkCellInterfaceDCTI3DFULULULPD3VCULPD3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceDCTI3DFULULULPD3VCULPD3::CellGeometry":
        """
        GetType(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> itkCellInterfaceDCTI3DFULULULPD3VCULPD3::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'double *', arg1: 'bool *', arg2: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, double * arg0, bool * arg1, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'double *', arg1: 'itkVectorContainerULPD3', arg2: 'double *', arg3: 'double *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, double * arg0, itkVectorContainerULPD3 arg1, double * arg2, double * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayD', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, itkArrayD arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double', arg3: 'double *', arg4: 'double *', arg5: 'double *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, double * arg0, double * arg1, double arg2, double * arg3, double * arg4, double * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'double *') -> "double *":
        """
        GetBoundingBox(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, double * arg0) -> double *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "double":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> double

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'double *', arg1: 'double *', arg2: 'double *', arg3: 'double *', arg4: 'double *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, double * arg0, double * arg1, double * arg2, double * arg3, double * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___deref__, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_Reset, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_TakeOwnership, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_IsOwner, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetPointer, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___eq__, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___ne__, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___lt__, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___gt__, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___le__, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer___ge__, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_Accept, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetType, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_MakeCopy, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetDimension, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetPointIds, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_SetPointIds, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_SetPointId, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_PointIdsBegin, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_PointIdsEnd, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_EvaluatePosition, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_IntersectWithLine, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetBoundingBox, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_AddUsingCell, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_IsUsingCell, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_GetNameOfClass, None, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_swigregister
itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer_swigregister(itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer)

class itkCellInterfaceFCTI2FFULULULPF2MCULPF2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VERTEX_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_VERTEX_CELL
    LINE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_LINE_CELL
    TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_TRIANGLE_CELL
    QUADRILATERAL_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_QUADRILATERAL_CELL
    POLYGON_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_POLYGON_CELL
    TETRAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_TETRAHEDRON_CELL
    HEXAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_HEXAHEDRON_CELL
    QUADRATIC_EDGE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_QUADRATIC_EDGE_CELL
    QUADRATIC_TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_QUADRATIC_TRIANGLE_CELL
    LAST_ITK_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_LAST_ITK_CELL
    MAX_ITK_CELLS = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_MAX_ITK_CELLS

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, unsigned long cellId, itkCellInterfaceFCTI2FFULULULPF2MCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, int dimension, unsigned long arg1, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, float * arg0, bool * arg1, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, float * arg0, itkMapContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI2FFULULULPF2MCULPF2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI2FFULULULPF2MCULPF2
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_Accept, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetType, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_MakeCopy, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetDimension, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetInterpolationOrder, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNumberOfPoints, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetBoundaryFeature, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_SetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_SetPointId, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_PointIdsBegin, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_PointIdsEnd, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_SetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetClosestBoundary, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_EvaluatePosition, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_EvaluateShapeFunctions, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IntersectWithLine, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetBoundingBox, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IsExplicitBoundary, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AddUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_RemoveUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_IsUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNumberOfUsingCells, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_GetNameOfClass, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_swigregister
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_swigregister(itkCellInterfaceFCTI2FFULULULPF2MCULPF2)

class itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer
        __init__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer p) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer
        __init__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 p, bool takeOwnership) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *":
        """__deref__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self)
        TakeOwnership(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2') -> "void":
        """TakeNoOwnership(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *":
        """ReleaseOwnership(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *":
        """GetPointer(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId, itkCellInterfaceFCTI2FFULULULPF2MCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, itkMapContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___deref__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_Reset, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_TakeOwnership, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IsOwner, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointer, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___eq__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___ne__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___lt__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___gt__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___le__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer___ge__, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_Accept, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetType, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_MakeCopy, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetDimension, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointId, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsBegin, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_PointIdsEnd, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluatePosition, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectWithLine, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBox, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_AddUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_IsUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_GetNameOfClass, None, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister
itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer_swigregister(itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer)

class itkCellInterfaceFCTI2FFULULULPF2VCULPF2(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VERTEX_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_VERTEX_CELL
    LINE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_LINE_CELL
    TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_TRIANGLE_CELL
    QUADRILATERAL_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_QUADRILATERAL_CELL
    POLYGON_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_POLYGON_CELL
    TETRAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_TETRAHEDRON_CELL
    HEXAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_HEXAHEDRON_CELL
    QUADRATIC_EDGE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_QUADRATIC_EDGE_CELL
    QUADRATIC_TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_QUADRATIC_TRIANGLE_CELL
    LAST_ITK_CELL = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_LAST_ITK_CELL
    MAX_ITK_CELLS = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_MAX_ITK_CELLS

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, unsigned long cellId, itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, int dimension, unsigned long arg1, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, float * arg0, bool * arg1, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, float * arg0, itkVectorContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI2FFULULULPF2VCULPF2 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI2FFULULULPF2VCULPF2
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_Accept, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetType, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_MakeCopy, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetDimension, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetInterpolationOrder, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNumberOfPoints, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetBoundaryFeature, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_SetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_SetPointId, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_PointIdsBegin, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_PointIdsEnd, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_SetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetClosestBoundary, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_EvaluatePosition, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_EvaluateShapeFunctions, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IntersectWithLine, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetBoundingBox, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IsExplicitBoundary, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AddUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_RemoveUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_IsUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNumberOfUsingCells, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_GetNameOfClass, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_swigregister
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_swigregister(itkCellInterfaceFCTI2FFULULULPF2VCULPF2)

class itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer
        __init__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer p) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer
        __init__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2 p, bool takeOwnership) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer

    def __deref__(self) -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *":
        """__deref__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self)
        TakeOwnership(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2') -> "void":
        """TakeNoOwnership(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *":
        """ReleaseOwnership(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *":
        """GetPointer(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId, itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF2', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, itkVectorContainerULPF2 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNameOfClass(self)

itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___deref__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_Reset, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_TakeOwnership, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_TakeNoOwnership, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IsOwner, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_ReleaseOwnership, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointer, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___eq__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___ne__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___lt__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___gt__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___le__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer___ge__, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_Accept, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetType, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_MakeCopy, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetDimension, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIds, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointId, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsBegin, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_PointIdsEnd, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetClosestBoundary, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluatePosition, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectWithLine, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBox, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_AddUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_RemoveUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_IsUsingCell, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_GetNameOfClass, None, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister
itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer_swigregister(itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer)

class itkCellInterfaceFCTI3FFULULULPF3MCULPF3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VERTEX_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_VERTEX_CELL
    LINE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_LINE_CELL
    TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_TRIANGLE_CELL
    QUADRILATERAL_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_QUADRILATERAL_CELL
    POLYGON_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_POLYGON_CELL
    TETRAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_TETRAHEDRON_CELL
    HEXAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_HEXAHEDRON_CELL
    QUADRATIC_EDGE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_QUADRATIC_EDGE_CELL
    QUADRATIC_TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_QUADRATIC_TRIANGLE_CELL
    LAST_ITK_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_LAST_ITK_CELL
    MAX_ITK_CELLS = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_MAX_ITK_CELLS

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, unsigned long cellId, itkCellInterfaceFCTI3FFULULULPF3MCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, int dimension, unsigned long arg1, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, float * arg0, bool * arg1, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, float * arg0, itkMapContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI3FFULULULPF3MCULPF3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI3FFULULULPF3MCULPF3
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_Accept, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetType, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_MakeCopy, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetDimension, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetInterpolationOrder, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNumberOfPoints, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetBoundaryFeature, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_SetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_SetPointId, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_PointIdsBegin, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_PointIdsEnd, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_SetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetClosestBoundary, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_EvaluatePosition, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_EvaluateShapeFunctions, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IntersectWithLine, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetBoundingBox, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IsExplicitBoundary, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AddUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_RemoveUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_IsUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNumberOfUsingCells, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_GetNameOfClass, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_swigregister
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_swigregister(itkCellInterfaceFCTI3FFULULULPF3MCULPF3)

class itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer
        __init__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer p) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer
        __init__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 p, bool takeOwnership) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *":
        """__deref__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self)
        TakeOwnership(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3') -> "void":
        """TakeNoOwnership(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *":
        """ReleaseOwnership(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *":
        """GetPointer(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId, itkCellInterfaceFCTI3FFULULULPF3MCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkMapContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, itkMapContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___deref__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_Reset, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_TakeOwnership, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IsOwner, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointer, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___eq__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___ne__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___lt__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___gt__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___le__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer___ge__, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_Accept, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetType, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_MakeCopy, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetDimension, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointId, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsBegin, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_PointIdsEnd, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluatePosition, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectWithLine, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBox, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_AddUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_IsUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_GetNameOfClass, None, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister
itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer_swigregister(itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer)

class itkCellInterfaceFCTI3FFULULULPF3VCULPF3(object):
    """


    An abstract interface for cells.

    Define an abstract interface for cells. Actual cell types derive from
    this class.

    Parameters:
    -----------

    TPixelType:  The type stored with an entity (cell, point, or
    boundary).

    TCellTraits:  Type information for cell.

    C++ includes: itkCellInterface.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VERTEX_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_VERTEX_CELL
    LINE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_LINE_CELL
    TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_TRIANGLE_CELL
    QUADRILATERAL_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_QUADRILATERAL_CELL
    POLYGON_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_POLYGON_CELL
    TETRAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_TETRAHEDRON_CELL
    HEXAHEDRON_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_HEXAHEDRON_CELL
    QUADRATIC_EDGE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_QUADRATIC_EDGE_CELL
    QUADRATIC_TRIANGLE_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_QUADRATIC_TRIANGLE_CELL
    LAST_ITK_CELL = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_LAST_ITK_CELL
    MAX_ITK_CELLS = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_MAX_ITK_CELLS

    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, unsigned long cellId, itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, int dimension, unsigned long arg1, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, float * arg0, bool * arg1, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, float * arg0, itkVectorContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI3FFULULULPF3VCULPF3 self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNameOfClass(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI3FFULULULPF3VCULPF3
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_Accept, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetType, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_MakeCopy, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetDimension, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetInterpolationOrder, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNumberOfPoints, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetBoundaryFeature, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_SetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_SetPointId, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_PointIdsBegin, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_PointIdsEnd, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_SetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetClosestBoundary, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_EvaluatePosition, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_EvaluateShapeFunctions, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IntersectWithLine, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetBoundingBox, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IsExplicitBoundary, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AddUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_RemoveUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_IsUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNumberOfUsingCells, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_GetNameOfClass, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_swigregister
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_swigregister(itkCellInterfaceFCTI3FFULULULPF3VCULPF3)

class itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer(object):
    """Proxy of C++ itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer
        __init__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer p) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer
        __init__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3 p, bool takeOwnership) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer
        """
        _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_swiginit(self, _itkMeshBasePython.new_itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer

    def __deref__(self) -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *":
        """__deref__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___deref__(self)


    def Reset(self) -> "void":
        """Reset(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_Reset(self)


    def TakeOwnership(self, *args) -> "void":
        """
        TakeOwnership(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self)
        TakeOwnership(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3 objectptr)
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_TakeOwnership(self, *args)


    def TakeNoOwnership(self, objectptr: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3') -> "void":
        """TakeNoOwnership(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3 objectptr)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_TakeNoOwnership(self, objectptr)


    def IsOwner(self) -> "bool":
        """IsOwner(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IsOwner(self)


    def ReleaseOwnership(self) -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *":
        """ReleaseOwnership(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_ReleaseOwnership(self)


    def GetPointer(self) -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *":
        """GetPointer(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointer(self)


    def __eq__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__eq__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___eq__(self, r)


    def __ne__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__ne__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___ne__(self, r)


    def __lt__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__lt__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___lt__(self, r)


    def __gt__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__gt__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___gt__(self, r)


    def __le__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__le__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___le__(self, r)


    def __ge__(self, r: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """__ge__(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer r) -> bool"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___ge__(self, r)


    def Accept(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId, itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor * arg1)

        This must be implemented by
        all sub-classes of CellInterface 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_Accept(self, cellId, arg1)


    def GetType(self) -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3::CellGeometry":
        """
        GetType(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3::CellGeometry

        Return the type of the cell
        (one of the CellGeometry enums listed above). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetType(self)


    def MakeCopy(self, arg0: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        MakeCopy(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg0)

        Create a new copy of this
        cell. This is provided so that a copy can be made without knowing the
        cell type. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_MakeCopy(self, arg0)


    def GetDimension(self) -> "unsigned int":
        """
        GetDimension(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the topological
        dimension of this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetDimension(self)


    def GetInterpolationOrder(self) -> "unsigned int":
        """
        GetInterpolationOrder(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the
        interpolation order of the cell. Usually linear. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetInterpolationOrder(self)


    def GetNumberOfPoints(self) -> "unsigned int":
        """
        GetNumberOfPoints(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the number of
        points required to define the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfPoints(self)


    def GetNumberOfBoundaryFeatures(self, dimension: 'int') -> "unsigned long":
        """
        GetNumberOfBoundaryFeatures(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, int dimension) -> unsigned long

        Get the
        number of boundary features of a given dimension on this cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfBoundaryFeatures(self, dimension)


    def GetBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetBoundaryFeature(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, int dimension, unsigned long arg1, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Get the boundary
        feature corresponding to the given dimension and Id. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundaryFeature(self, dimension, arg1, arg2)


    def GetPointIds(self) -> "unsigned long const *":
        """
        GetPointIds(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get the point id list
        used by the cell in a form suitable to pass to SetPointIds(first) on
        another cell. This is equivalent to PointIdsBegin() const. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIds(self)


    def SetPointIds(self, *args) -> "void":
        """
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long const * first)
        SetPointIds(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long const * first, unsigned long const * last)

        Set the point id list
        used by the cell. It is assumed that the range of iterators [first,
        last) contains the correct number of points needed to define the cell.
        The position *last is NOT referenced, so it can safely be one beyond
        the end of an array or other container. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIds(self, *args)


    def SetPointId(self, localId: 'int', arg1: 'unsigned long') -> "void":
        """
        SetPointId(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, int localId, unsigned long arg1)

        Set the point identifier
        for a given spot in the point list for the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointId(self, localId, arg1)


    def PointIdsBegin(self, *args) -> "unsigned long const *":
        """
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long
        PointIdsBegin(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get a const begin
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsBegin(self, *args)


    def PointIdsEnd(self, *args) -> "unsigned long const *":
        """
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long
        PointIdsEnd(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned long const *

        Get a const end
        iterator to the list of point identifiers used by the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsEnd(self, *args)


    def GetPointIdsContainer(self) -> "itkArrayUL":
        """GetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> itkArrayUL"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIdsContainer(self)


    def SetPointIdsContainer(self, arg0: 'itkArrayUL') -> "void":
        """SetPointIdsContainer(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkArrayUL arg0)"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIdsContainer(self, arg0)


    def GetClosestBoundary(self, arg0: 'float *', arg1: 'bool *', arg2: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetClosestBoundary(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, bool * arg1, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg2) -> bool

        Given the
        parametric coordinates of a point in the cell
        (pCoords[CellDimension]), get the closest cell boundary feature of
        topological dimension CellDimension-1. If the "inside" pointer is
        not ITK_NULLPTR, the flag is set to indicate whether the point is
        inside the cell. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetClosestBoundary(self, arg0, arg1, arg2)


    def EvaluatePosition(self, arg0: 'float *', arg1: 'itkVectorContainerULPF3', arg2: 'float *', arg3: 'float *', arg4: 'double *', arg5: 'float *') -> "bool":
        """
        EvaluatePosition(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, itkVectorContainerULPF3 arg1, float * arg2, float * arg3, double * arg4, float * arg5) -> bool

        Given the
        geometric coordinates of a point (coord[PointDimension]), return
        whether it is inside the cell. Also perform the following
        calculations, if the corresponding result pointers are not
        ITK_NULLPTR:

        Find the closest point in or on the cell to the given point (Returns
        through pointer to array: closestPoint[PointDimension]).

        Get the cell's parametric coordinates for the given point (Returns
        through pointer to array: pCoords[CellDimension]).

        Get the square of the distance between the point and the cell (this is
        the distance from the point to the closest point, returned through
        "dist2" pointer).

        Get the interpolation weights for the cell (Returns through pointer to
        array: weights[NumberOfPoints]). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluatePosition(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def EvaluateShapeFunctions(self, arg0: 'itkArrayF', arg1: 'itkArrayF') -> "void":
        """
        EvaluateShapeFunctions(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, itkArrayF arg0, itkArrayF arg1)

        Given the
        parametric coordinates of a point in the cell determine the value of
        its Shape Functions returned through an
        itkArray<InterpolationWeightType>). 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluateShapeFunctions(self, arg0, arg1)


    def IntersectWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float', arg3: 'float *', arg4: 'float *', arg5: 'float *') -> "bool":
        """
        IntersectWithLine(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, float * arg1, float arg2, float * arg3, float * arg4, float * arg5) -> bool

        Intersect the
        cell with a line given by an origin (origin[PointDimension]) and
        direction (direction[PointDimension]). The intersection point found
        will be within the given tolerance of the real intersection. Get the
        following results if the corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        The cell's parametric coordinates of the intersection point (returned
        through pointer to array: pCoords[CellDimension]).

        Returns whether an intersection exists within the given tolerance. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectWithLine(self, arg0, arg1, arg2, arg3, arg4, arg5)


    def GetBoundingBox(self, arg0: 'float *') -> "float *":
        """
        GetBoundingBox(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0) -> float *

        Compute cell
        bounding box and store in the user-provided array. Array is ordered
        (xmin, xmax, ymin, ymax, ....). A pointer to the array is returned for
        convenience. This allows code like: "CoordRep* bounds =
        cell->GetBoundingBox(new CoordRep[6]);". 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBox(self, arg0)


    def GetBoundingBoxDiagonalLength2(self) -> "float":
        """
        GetBoundingBoxDiagonalLength2(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> float

        Compute the square of the diagonal length of the bounding box. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2(self)


    def IntersectBoundingBoxWithLine(self, arg0: 'float *', arg1: 'float *', arg2: 'float *', arg3: 'float *', arg4: 'float *') -> "bool":
        """
        IntersectBoundingBoxWithLine(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, float * arg0, float * arg1, float * arg2, float * arg3, float * arg4) -> bool

        Intersect the given bounding box (bounds[PointDimension*2]) with a
        line given by an origin (origin[PointDimension]) and direction
        (direction[PointDimension]). Get the following results if the
        corresponding pointers are not ITK_NULLPTR:

        The intersection point's geometric coordinates (returned through
        pointer to array: coords[PointDimension]).

        The line's parametric coordinate of the intersection point (returned
        through "t" pointer).

        Returns whether an intersection exists. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectBoundingBoxWithLine(self, arg0, arg1, arg2, arg3, arg4)


    def IsExplicitBoundary(self) -> "bool":
        """
        IsExplicitBoundary(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> bool

        Interface to the
        boundary form of the cell to set/get UsingCells. See the boundary
        wrapper source for more information. Returns true if the cell has been
        explicitly assigned as a boundary, false otherwise. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IsExplicitBoundary(self)


    def AddUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        AddUsingCell(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId)

        Register the fact that
        this cell is a part of the boundary of the cell cellId, by adding
        cellId to the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_AddUsingCell(self, cellId)


    def RemoveUsingCell(self, cellId: 'unsigned long') -> "void":
        """
        RemoveUsingCell(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId)

        Remove a cell from
        the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_RemoveUsingCell(self, cellId)


    def IsUsingCell(self, cellId: 'unsigned long') -> "bool":
        """
        IsUsingCell(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self, unsigned long cellId) -> bool

        Test if a cell is in
        the UsingCellsContainer. A result of true indicates that this cell is
        part of the boundary of the cell cellId, assuming that boundary
        information has been recorded. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IsUsingCell(self, cellId)


    def GetNumberOfUsingCells(self) -> "unsigned int":
        """
        GetNumberOfUsingCells(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> unsigned int

        Get the
        number of cells in the UsingCellsContainer. 
        """
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfUsingCells(self)


    def GetNameOfClass(self) -> "char const *":
        """GetNameOfClass(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer self) -> char const *"""
        return _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNameOfClass(self)

itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__deref__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___deref__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.Reset = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_Reset, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.TakeOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_TakeOwnership, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.TakeNoOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_TakeNoOwnership, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.IsOwner = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IsOwner, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.ReleaseOwnership = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_ReleaseOwnership, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointer, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__eq__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___eq__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__ne__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___ne__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__lt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___lt__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__gt__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___gt__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__le__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___le__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.__ge__ = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer___ge__, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.Accept = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_Accept, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetType = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetType, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.MakeCopy = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_MakeCopy, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetDimension = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetDimension, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetInterpolationOrder = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetInterpolationOrder, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfPoints = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfPoints, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfBoundaryFeatures, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundaryFeature, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointIds = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIds, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointId, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.PointIdsBegin = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsBegin, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.PointIdsEnd = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_PointIdsEnd, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.SetPointIdsContainer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_SetPointIdsContainer, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetClosestBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetClosestBoundary, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.EvaluatePosition = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluatePosition, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.EvaluateShapeFunctions = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_EvaluateShapeFunctions, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.IntersectWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectWithLine, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBox, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetBoundingBoxDiagonalLength2 = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetBoundingBoxDiagonalLength2, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.IntersectBoundingBoxWithLine = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IntersectBoundingBoxWithLine, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.IsExplicitBoundary = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IsExplicitBoundary, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.AddUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_AddUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.RemoveUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_RemoveUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.IsUsingCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_IsUsingCell, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetNumberOfUsingCells = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNumberOfUsingCells, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer.GetNameOfClass = new_instancemethod(_itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_GetNameOfClass, None, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister = _itkMeshBasePython.itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister
itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer_swigregister(itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer)

class itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2 self, unsigned long cellId, itkCellInterfaceDCTI2DDULULULPD2MCULPD2 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "int":
        """
        GetCellTopologyId(itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2 self) -> int

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2 *":
        """GetPointer(itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2 self) -> itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2"""
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2

        Create a new object of the class itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_VisitFromCell, None, itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_GetCellTopologyId, None, itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_GetPointer, None, itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2)
itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_swigregister
itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_swigregister(itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2)

def itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2 *":
    """itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_cast(itkLightObject obj) -> itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2"""
    return _itkMeshBasePython.itkCellInterfaceVisitorDCTI2DDULULULPD2MCULPD2_cast(obj)

class itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3 self, unsigned long cellId, itkCellInterfaceDCTI3DDULULULPD3MCULPD3 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "int":
        """
        GetCellTopologyId(itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3 self) -> int

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3 *":
        """GetPointer(itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3 self) -> itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3"""
        return _itkMeshBasePython.itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3

        Create a new object of the class itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_VisitFromCell, None, itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_GetCellTopologyId, None, itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_GetPointer, None, itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3)
itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_swigregister
itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_swigregister(itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3)

def itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3 *":
    """itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_cast(itkLightObject obj) -> itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3"""
    return _itkMeshBasePython.itkCellInterfaceVisitorDCTI3DDULULULPD3MCULPD3_cast(obj)

class itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2 self, unsigned long cellId, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "int":
        """
        GetCellTopologyId(itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2 self) -> int

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2 *":
        """GetPointer(itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2 self) -> itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2

        Create a new object of the class itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_VisitFromCell, None, itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_GetCellTopologyId, None, itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_GetPointer, None, itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2)
itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_swigregister
itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_swigregister(itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2)

def itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2 *":
    """itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_cast(itkLightObject obj) -> itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2"""
    return _itkMeshBasePython.itkCellInterfaceVisitorFCTI2FFULULULPF2MCULPF2_cast(obj)

class itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3(ITKCommonBasePython.itkLightObject):
    """


    Abstract interface for a visitor class that can visit the cells in a
    Mesh.

    Define the abstract interface for a visitor class that can visit the
    cells in a Mesh. This follows the Visitor Design Pattern. To make this
    class easier to use, the CellInterfaceVisitorImplementation is
    provided as a templated class to implement the pure virtual functions
    of CellInterfaceVisitor.

    C++ includes: itkCellInterfaceVisitor.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def VisitFromCell(self, cellId: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3') -> "void":
        """
        VisitFromCell(itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3 self, unsigned long cellId, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 arg1)

        This method is called
        by each cell as it visits this visitor. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_VisitFromCell(self, cellId, arg1)


    def GetCellTopologyId(self) -> "int":
        """
        GetCellTopologyId(itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3 self) -> int

        Return the index
        of the CellTopology. 
        """
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_GetCellTopologyId(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3

    def cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3 *":
        """cast(itkLightObject obj) -> itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3 *":
        """GetPointer(itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3 self) -> itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3

        Create a new object of the class itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.VisitFromCell = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_VisitFromCell, None, itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.GetCellTopologyId = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_GetCellTopologyId, None, itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3.GetPointer = new_instancemethod(_itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_GetPointer, None, itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3)
itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_swigregister
itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_swigregister(itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3)

def itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_cast(obj: 'itkLightObject') -> "itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3 *":
    """itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_cast(itkLightObject obj) -> itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3"""
    return _itkMeshBasePython.itkCellInterfaceVisitorFCTI3FFULULULPF3MCULPF3_cast(obj)

class itkCellTraitsInfo2DDULULULPD2MCULPD2(object):
    """Proxy of C++ itkCellTraitsInfo2DDULULULPD2MCULPD2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo2DDULULULPD2MCULPD2 self) -> itkCellTraitsInfo2DDULULULPD2MCULPD2
        __init__(itkCellTraitsInfo2DDULULULPD2MCULPD2 self, itkCellTraitsInfo2DDULULULPD2MCULPD2 arg0) -> itkCellTraitsInfo2DDULULULPD2MCULPD2
        """
        _itkMeshBasePython.itkCellTraitsInfo2DDULULULPD2MCULPD2_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo2DDULULULPD2MCULPD2(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo2DDULULULPD2MCULPD2
itkCellTraitsInfo2DDULULULPD2MCULPD2_swigregister = _itkMeshBasePython.itkCellTraitsInfo2DDULULULPD2MCULPD2_swigregister
itkCellTraitsInfo2DDULULULPD2MCULPD2_swigregister(itkCellTraitsInfo2DDULULULPD2MCULPD2)

class itkCellTraitsInfo2DDULULULPD2VCULPD2(object):
    """Proxy of C++ itkCellTraitsInfo2DDULULULPD2VCULPD2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo2DDULULULPD2VCULPD2 self) -> itkCellTraitsInfo2DDULULULPD2VCULPD2
        __init__(itkCellTraitsInfo2DDULULULPD2VCULPD2 self, itkCellTraitsInfo2DDULULULPD2VCULPD2 arg0) -> itkCellTraitsInfo2DDULULULPD2VCULPD2
        """
        _itkMeshBasePython.itkCellTraitsInfo2DDULULULPD2VCULPD2_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo2DDULULULPD2VCULPD2(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo2DDULULULPD2VCULPD2
itkCellTraitsInfo2DDULULULPD2VCULPD2_swigregister = _itkMeshBasePython.itkCellTraitsInfo2DDULULULPD2VCULPD2_swigregister
itkCellTraitsInfo2DDULULULPD2VCULPD2_swigregister(itkCellTraitsInfo2DDULULULPD2VCULPD2)

class itkCellTraitsInfo2DFULULULPD2MCULPD2(object):
    """Proxy of C++ itkCellTraitsInfo2DFULULULPD2MCULPD2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo2DFULULULPD2MCULPD2 self) -> itkCellTraitsInfo2DFULULULPD2MCULPD2
        __init__(itkCellTraitsInfo2DFULULULPD2MCULPD2 self, itkCellTraitsInfo2DFULULULPD2MCULPD2 arg0) -> itkCellTraitsInfo2DFULULULPD2MCULPD2
        """
        _itkMeshBasePython.itkCellTraitsInfo2DFULULULPD2MCULPD2_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo2DFULULULPD2MCULPD2(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo2DFULULULPD2MCULPD2
itkCellTraitsInfo2DFULULULPD2MCULPD2_swigregister = _itkMeshBasePython.itkCellTraitsInfo2DFULULULPD2MCULPD2_swigregister
itkCellTraitsInfo2DFULULULPD2MCULPD2_swigregister(itkCellTraitsInfo2DFULULULPD2MCULPD2)

class itkCellTraitsInfo2DFULULULPD2VCULPD2(object):
    """Proxy of C++ itkCellTraitsInfo2DFULULULPD2VCULPD2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo2DFULULULPD2VCULPD2 self) -> itkCellTraitsInfo2DFULULULPD2VCULPD2
        __init__(itkCellTraitsInfo2DFULULULPD2VCULPD2 self, itkCellTraitsInfo2DFULULULPD2VCULPD2 arg0) -> itkCellTraitsInfo2DFULULULPD2VCULPD2
        """
        _itkMeshBasePython.itkCellTraitsInfo2DFULULULPD2VCULPD2_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo2DFULULULPD2VCULPD2(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo2DFULULULPD2VCULPD2
itkCellTraitsInfo2DFULULULPD2VCULPD2_swigregister = _itkMeshBasePython.itkCellTraitsInfo2DFULULULPD2VCULPD2_swigregister
itkCellTraitsInfo2DFULULULPD2VCULPD2_swigregister(itkCellTraitsInfo2DFULULULPD2VCULPD2)

class itkCellTraitsInfo2FFULULULPF2MCULPF2(object):
    """Proxy of C++ itkCellTraitsInfo2FFULULULPF2MCULPF2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo2FFULULULPF2MCULPF2 self) -> itkCellTraitsInfo2FFULULULPF2MCULPF2
        __init__(itkCellTraitsInfo2FFULULULPF2MCULPF2 self, itkCellTraitsInfo2FFULULULPF2MCULPF2 arg0) -> itkCellTraitsInfo2FFULULULPF2MCULPF2
        """
        _itkMeshBasePython.itkCellTraitsInfo2FFULULULPF2MCULPF2_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo2FFULULULPF2MCULPF2(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo2FFULULULPF2MCULPF2
itkCellTraitsInfo2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkCellTraitsInfo2FFULULULPF2MCULPF2_swigregister
itkCellTraitsInfo2FFULULULPF2MCULPF2_swigregister(itkCellTraitsInfo2FFULULULPF2MCULPF2)

class itkCellTraitsInfo2FFULULULPF2VCULPF2(object):
    """Proxy of C++ itkCellTraitsInfo2FFULULULPF2VCULPF2 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo2FFULULULPF2VCULPF2 self) -> itkCellTraitsInfo2FFULULULPF2VCULPF2
        __init__(itkCellTraitsInfo2FFULULULPF2VCULPF2 self, itkCellTraitsInfo2FFULULULPF2VCULPF2 arg0) -> itkCellTraitsInfo2FFULULULPF2VCULPF2
        """
        _itkMeshBasePython.itkCellTraitsInfo2FFULULULPF2VCULPF2_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo2FFULULULPF2VCULPF2(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo2FFULULULPF2VCULPF2
itkCellTraitsInfo2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkCellTraitsInfo2FFULULULPF2VCULPF2_swigregister
itkCellTraitsInfo2FFULULULPF2VCULPF2_swigregister(itkCellTraitsInfo2FFULULULPF2VCULPF2)

class itkCellTraitsInfo3DDULULULPD3MCULPD3(object):
    """Proxy of C++ itkCellTraitsInfo3DDULULULPD3MCULPD3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo3DDULULULPD3MCULPD3 self) -> itkCellTraitsInfo3DDULULULPD3MCULPD3
        __init__(itkCellTraitsInfo3DDULULULPD3MCULPD3 self, itkCellTraitsInfo3DDULULULPD3MCULPD3 arg0) -> itkCellTraitsInfo3DDULULULPD3MCULPD3
        """
        _itkMeshBasePython.itkCellTraitsInfo3DDULULULPD3MCULPD3_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo3DDULULULPD3MCULPD3(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo3DDULULULPD3MCULPD3
itkCellTraitsInfo3DDULULULPD3MCULPD3_swigregister = _itkMeshBasePython.itkCellTraitsInfo3DDULULULPD3MCULPD3_swigregister
itkCellTraitsInfo3DDULULULPD3MCULPD3_swigregister(itkCellTraitsInfo3DDULULULPD3MCULPD3)

class itkCellTraitsInfo3DDULULULPD3VCULPD3(object):
    """Proxy of C++ itkCellTraitsInfo3DDULULULPD3VCULPD3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo3DDULULULPD3VCULPD3 self) -> itkCellTraitsInfo3DDULULULPD3VCULPD3
        __init__(itkCellTraitsInfo3DDULULULPD3VCULPD3 self, itkCellTraitsInfo3DDULULULPD3VCULPD3 arg0) -> itkCellTraitsInfo3DDULULULPD3VCULPD3
        """
        _itkMeshBasePython.itkCellTraitsInfo3DDULULULPD3VCULPD3_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo3DDULULULPD3VCULPD3(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo3DDULULULPD3VCULPD3
itkCellTraitsInfo3DDULULULPD3VCULPD3_swigregister = _itkMeshBasePython.itkCellTraitsInfo3DDULULULPD3VCULPD3_swigregister
itkCellTraitsInfo3DDULULULPD3VCULPD3_swigregister(itkCellTraitsInfo3DDULULULPD3VCULPD3)

class itkCellTraitsInfo3DFULULULPD3MCULPD3(object):
    """Proxy of C++ itkCellTraitsInfo3DFULULULPD3MCULPD3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo3DFULULULPD3MCULPD3 self) -> itkCellTraitsInfo3DFULULULPD3MCULPD3
        __init__(itkCellTraitsInfo3DFULULULPD3MCULPD3 self, itkCellTraitsInfo3DFULULULPD3MCULPD3 arg0) -> itkCellTraitsInfo3DFULULULPD3MCULPD3
        """
        _itkMeshBasePython.itkCellTraitsInfo3DFULULULPD3MCULPD3_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo3DFULULULPD3MCULPD3(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo3DFULULULPD3MCULPD3
itkCellTraitsInfo3DFULULULPD3MCULPD3_swigregister = _itkMeshBasePython.itkCellTraitsInfo3DFULULULPD3MCULPD3_swigregister
itkCellTraitsInfo3DFULULULPD3MCULPD3_swigregister(itkCellTraitsInfo3DFULULULPD3MCULPD3)

class itkCellTraitsInfo3DFULULULPD3VCULPD3(object):
    """Proxy of C++ itkCellTraitsInfo3DFULULULPD3VCULPD3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo3DFULULULPD3VCULPD3 self) -> itkCellTraitsInfo3DFULULULPD3VCULPD3
        __init__(itkCellTraitsInfo3DFULULULPD3VCULPD3 self, itkCellTraitsInfo3DFULULULPD3VCULPD3 arg0) -> itkCellTraitsInfo3DFULULULPD3VCULPD3
        """
        _itkMeshBasePython.itkCellTraitsInfo3DFULULULPD3VCULPD3_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo3DFULULULPD3VCULPD3(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo3DFULULULPD3VCULPD3
itkCellTraitsInfo3DFULULULPD3VCULPD3_swigregister = _itkMeshBasePython.itkCellTraitsInfo3DFULULULPD3VCULPD3_swigregister
itkCellTraitsInfo3DFULULULPD3VCULPD3_swigregister(itkCellTraitsInfo3DFULULULPD3VCULPD3)

class itkCellTraitsInfo3FFULULULPF3MCULPF3(object):
    """Proxy of C++ itkCellTraitsInfo3FFULULULPF3MCULPF3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo3FFULULULPF3MCULPF3 self) -> itkCellTraitsInfo3FFULULULPF3MCULPF3
        __init__(itkCellTraitsInfo3FFULULULPF3MCULPF3 self, itkCellTraitsInfo3FFULULULPF3MCULPF3 arg0) -> itkCellTraitsInfo3FFULULULPF3MCULPF3
        """
        _itkMeshBasePython.itkCellTraitsInfo3FFULULULPF3MCULPF3_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo3FFULULULPF3MCULPF3(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo3FFULULULPF3MCULPF3
itkCellTraitsInfo3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkCellTraitsInfo3FFULULULPF3MCULPF3_swigregister
itkCellTraitsInfo3FFULULULPF3MCULPF3_swigregister(itkCellTraitsInfo3FFULULULPF3MCULPF3)

class itkCellTraitsInfo3FFULULULPF3VCULPF3(object):
    """Proxy of C++ itkCellTraitsInfo3FFULULULPF3VCULPF3 class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkCellTraitsInfo3FFULULULPF3VCULPF3 self) -> itkCellTraitsInfo3FFULULULPF3VCULPF3
        __init__(itkCellTraitsInfo3FFULULULPF3VCULPF3 self, itkCellTraitsInfo3FFULULULPF3VCULPF3 arg0) -> itkCellTraitsInfo3FFULULULPF3VCULPF3
        """
        _itkMeshBasePython.itkCellTraitsInfo3FFULULULPF3VCULPF3_swiginit(self, _itkMeshBasePython.new_itkCellTraitsInfo3FFULULULPF3VCULPF3(*args))
    __swig_destroy__ = _itkMeshBasePython.delete_itkCellTraitsInfo3FFULULULPF3VCULPF3
itkCellTraitsInfo3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkCellTraitsInfo3FFULULULPF3VCULPF3_swigregister
itkCellTraitsInfo3FFULULULPF3VCULPF3_swigregister(itkCellTraitsInfo3FFULULULPF3VCULPF3)

class itkMapContainerULCIDCTI2DDULULULPD2MCULPD2(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self) -> itkMapContainerULCIDCTI2DDULULULPD2MCULPD2
        __init__(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIDCTI2DDULULULPD2MCULPD2



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIDCTI2DDULULULPD2MCULPD2(*args))

    def __New_orig__() -> "itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Pointer":
        """__New_orig__() -> itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Pointer":
        """Clone(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self) -> itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceDCTI2DDULULULPD2MCULPD2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI2DDULULULPD2MCULPD2 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self) -> std::map< unsigned long,itkCellInterfaceDCTI2DDULULULPD2MCULPD2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI2DDULULULPD2MCULPD2 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceDCTI2DDULULULPD2MCULPD2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI2DDULULULPD2MCULPD2 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self) -> std::map< unsigned long,itkCellInterfaceDCTI2DDULULULPD2MCULPD2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI2DDULULULPD2MCULPD2 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceDCTI2DDULULULPD2MCULPD2 *const &":
        """
        ElementAt(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DDULULULPD2MCULPD2
        ElementAt(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DDULULULPD2MCULPD2

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI2DDULULULPD2MCULPD2 *&":
        """
        CreateElementAt(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DDULULULPD2MCULPD2 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI2DDULULULPD2MCULPD2 *":
        """
        GetElement(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DDULULULPD2MCULPD2

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2') -> "void":
        """
        SetElement(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self, unsigned long arg0, itkCellInterfaceDCTI2DDULULULPD2MCULPD2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2') -> "void":
        """
        InsertElement(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self, unsigned long arg0, itkCellInterfaceDCTI2DDULULULPD2MCULPD2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self, unsigned long arg0, itkCellInterfaceDCTI2DDULULULPD2MCULPD2 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIDCTI2DDULULULPD2MCULPD2

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIDCTI2DDULULULPD2MCULPD2"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 *":
        """GetPointer(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 self) -> itkMapContainerULCIDCTI2DDULULULPD2MCULPD2"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMapContainerULCIDCTI2DDULULULPD2MCULPD2

        Create a new object of the class itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Clone, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_CastToSTLContainer, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_CastToSTLConstContainer, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_ElementAt, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_CreateElementAt, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_GetElement, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_SetElement, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_InsertElement, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_IndexExists, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_GetElementIfIndexExists, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_CreateIndex, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_DeleteIndex, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Size, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Reserve, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Squeeze, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Initialize, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2.GetPointer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_GetPointer, None, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_swigregister = _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_swigregister
itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_swigregister(itkMapContainerULCIDCTI2DDULULULPD2MCULPD2)

def itkMapContainerULCIDCTI2DDULULULPD2MCULPD2___New_orig__() -> "itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Pointer":
    """itkMapContainerULCIDCTI2DDULULULPD2MCULPD2___New_orig__() -> itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2___New_orig__()

def itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_cast(obj: 'itkLightObject') -> "itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 *":
    """itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_cast(itkLightObject obj) -> itkMapContainerULCIDCTI2DDULULULPD2MCULPD2"""
    return _itkMeshBasePython.itkMapContainerULCIDCTI2DDULULULPD2MCULPD2_cast(obj)

class itkMapContainerULCIDCTI2DFULULULPD2MCULPD2(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self) -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2
        __init__(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIDCTI2DFULULULPD2MCULPD2(*args))

    def __New_orig__() -> "itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Pointer":
        """__New_orig__() -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Pointer":
        """Clone(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self) -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceDCTI2DFULULULPD2MCULPD2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI2DFULULULPD2MCULPD2 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self) -> std::map< unsigned long,itkCellInterfaceDCTI2DFULULULPD2MCULPD2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI2DFULULULPD2MCULPD2 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceDCTI2DFULULULPD2MCULPD2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI2DFULULULPD2MCULPD2 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self) -> std::map< unsigned long,itkCellInterfaceDCTI2DFULULULPD2MCULPD2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI2DFULULULPD2MCULPD2 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceDCTI2DFULULULPD2MCULPD2 *const &":
        """
        ElementAt(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DFULULULPD2MCULPD2
        ElementAt(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DFULULULPD2MCULPD2

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI2DFULULULPD2MCULPD2 *&":
        """
        CreateElementAt(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DFULULULPD2MCULPD2 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI2DFULULULPD2MCULPD2 *":
        """
        GetElement(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DFULULULPD2MCULPD2

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2') -> "void":
        """
        SetElement(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2MCULPD2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2') -> "void":
        """
        InsertElement(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2MCULPD2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2MCULPD2 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIDCTI2DFULULULPD2MCULPD2

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 *":
        """GetPointer(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 self) -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2

        Create a new object of the class itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Clone, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_CastToSTLContainer, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_CastToSTLConstContainer, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_ElementAt, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_CreateElementAt, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_GetElement, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_SetElement, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_InsertElement, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_IndexExists, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_GetElementIfIndexExists, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_CreateIndex, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_DeleteIndex, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Size, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Reserve, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Squeeze, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Initialize, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2.GetPointer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_GetPointer, None, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_swigregister = _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_swigregister
itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_swigregister(itkMapContainerULCIDCTI2DFULULULPD2MCULPD2)

def itkMapContainerULCIDCTI2DFULULULPD2MCULPD2___New_orig__() -> "itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Pointer":
    """itkMapContainerULCIDCTI2DFULULULPD2MCULPD2___New_orig__() -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2___New_orig__()

def itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_cast(obj: 'itkLightObject') -> "itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 *":
    """itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_cast(itkLightObject obj) -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2"""
    return _itkMeshBasePython.itkMapContainerULCIDCTI2DFULULULPD2MCULPD2_cast(obj)

class itkMapContainerULCIDCTI3DDULULULPD3MCULPD3(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self) -> itkMapContainerULCIDCTI3DDULULULPD3MCULPD3
        __init__(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIDCTI3DDULULULPD3MCULPD3



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIDCTI3DDULULULPD3MCULPD3(*args))

    def __New_orig__() -> "itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Pointer":
        """__New_orig__() -> itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Pointer":
        """Clone(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self) -> itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceDCTI3DDULULULPD3MCULPD3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI3DDULULULPD3MCULPD3 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self) -> std::map< unsigned long,itkCellInterfaceDCTI3DDULULULPD3MCULPD3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI3DDULULULPD3MCULPD3 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceDCTI3DDULULULPD3MCULPD3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI3DDULULULPD3MCULPD3 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self) -> std::map< unsigned long,itkCellInterfaceDCTI3DDULULULPD3MCULPD3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI3DDULULULPD3MCULPD3 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceDCTI3DDULULULPD3MCULPD3 *const &":
        """
        ElementAt(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DDULULULPD3MCULPD3
        ElementAt(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DDULULULPD3MCULPD3

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI3DDULULULPD3MCULPD3 *&":
        """
        CreateElementAt(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DDULULULPD3MCULPD3 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI3DDULULULPD3MCULPD3 *":
        """
        GetElement(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DDULULULPD3MCULPD3

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3') -> "void":
        """
        SetElement(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self, unsigned long arg0, itkCellInterfaceDCTI3DDULULULPD3MCULPD3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3') -> "void":
        """
        InsertElement(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self, unsigned long arg0, itkCellInterfaceDCTI3DDULULULPD3MCULPD3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self, unsigned long arg0, itkCellInterfaceDCTI3DDULULULPD3MCULPD3 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIDCTI3DDULULULPD3MCULPD3

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIDCTI3DDULULULPD3MCULPD3"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 *":
        """GetPointer(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 self) -> itkMapContainerULCIDCTI3DDULULULPD3MCULPD3"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMapContainerULCIDCTI3DDULULULPD3MCULPD3

        Create a new object of the class itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Clone, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_CastToSTLContainer, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_CastToSTLConstContainer, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_ElementAt, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_CreateElementAt, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_GetElement, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_SetElement, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_InsertElement, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_IndexExists, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_GetElementIfIndexExists, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_CreateIndex, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_DeleteIndex, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Size, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Reserve, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Squeeze, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Initialize, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3.GetPointer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_GetPointer, None, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_swigregister = _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_swigregister
itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_swigregister(itkMapContainerULCIDCTI3DDULULULPD3MCULPD3)

def itkMapContainerULCIDCTI3DDULULULPD3MCULPD3___New_orig__() -> "itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Pointer":
    """itkMapContainerULCIDCTI3DDULULULPD3MCULPD3___New_orig__() -> itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3___New_orig__()

def itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_cast(obj: 'itkLightObject') -> "itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 *":
    """itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_cast(itkLightObject obj) -> itkMapContainerULCIDCTI3DDULULULPD3MCULPD3"""
    return _itkMeshBasePython.itkMapContainerULCIDCTI3DDULULULPD3MCULPD3_cast(obj)

class itkMapContainerULCIDCTI3DFULULULPD3MCULPD3(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self) -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3
        __init__(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIDCTI3DFULULULPD3MCULPD3(*args))

    def __New_orig__() -> "itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Pointer":
        """__New_orig__() -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Pointer":
        """Clone(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self) -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceDCTI3DFULULULPD3MCULPD3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI3DFULULULPD3MCULPD3 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self) -> std::map< unsigned long,itkCellInterfaceDCTI3DFULULULPD3MCULPD3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI3DFULULULPD3MCULPD3 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceDCTI3DFULULULPD3MCULPD3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI3DFULULULPD3MCULPD3 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self) -> std::map< unsigned long,itkCellInterfaceDCTI3DFULULULPD3MCULPD3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceDCTI3DFULULULPD3MCULPD3 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceDCTI3DFULULULPD3MCULPD3 *const &":
        """
        ElementAt(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DFULULULPD3MCULPD3
        ElementAt(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DFULULULPD3MCULPD3

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI3DFULULULPD3MCULPD3 *&":
        """
        CreateElementAt(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DFULULULPD3MCULPD3 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI3DFULULULPD3MCULPD3 *":
        """
        GetElement(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DFULULULPD3MCULPD3

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3') -> "void":
        """
        SetElement(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3MCULPD3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3') -> "void":
        """
        InsertElement(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3MCULPD3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3MCULPD3 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIDCTI3DFULULULPD3MCULPD3

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 *":
        """GetPointer(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 self) -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3"""
        return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3

        Create a new object of the class itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Clone, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_CastToSTLContainer, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_CastToSTLConstContainer, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_ElementAt, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_CreateElementAt, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_GetElement, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_SetElement, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_InsertElement, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_IndexExists, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_GetElementIfIndexExists, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_CreateIndex, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_DeleteIndex, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Size, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Reserve, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Squeeze, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Initialize, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3.GetPointer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_GetPointer, None, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_swigregister = _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_swigregister
itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_swigregister(itkMapContainerULCIDCTI3DFULULULPD3MCULPD3)

def itkMapContainerULCIDCTI3DFULULULPD3MCULPD3___New_orig__() -> "itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Pointer":
    """itkMapContainerULCIDCTI3DFULULULPD3MCULPD3___New_orig__() -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3___New_orig__()

def itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_cast(obj: 'itkLightObject') -> "itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 *":
    """itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_cast(itkLightObject obj) -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3"""
    return _itkMeshBasePython.itkMapContainerULCIDCTI3DFULULULPD3MCULPD3_cast(obj)

class itkMapContainerULCIFCTI2FFULULULPF2MCULPF2(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2
        __init__(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIFCTI2FFULULULPF2MCULPF2(*args))

    def __New_orig__() -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Pointer":
        """__New_orig__() -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Pointer":
        """Clone(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self) -> std::map< unsigned long,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self) -> std::map< unsigned long,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI2FFULULULPF2MCULPF2 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *const &":
        """
        ElementAt(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2
        ElementAt(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *&":
        """
        CreateElementAt(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI2FFULULULPF2MCULPF2 *":
        """
        GetElement(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2MCULPF2

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2') -> "void":
        """
        SetElement(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2') -> "void":
        """
        InsertElement(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2MCULPF2 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIFCTI2FFULULULPF2MCULPF2

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 *":
        """GetPointer(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 self) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2

        Create a new object of the class itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Clone, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CastToSTLContainer, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CastToSTLConstContainer, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_ElementAt, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CreateElementAt, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_GetElement, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_SetElement, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_InsertElement, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_IndexExists, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_GetElementIfIndexExists, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_CreateIndex, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_DeleteIndex, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Size, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Reserve, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Squeeze, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Initialize, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2.GetPointer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_GetPointer, None, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_swigregister = _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_swigregister
itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_swigregister(itkMapContainerULCIFCTI2FFULULULPF2MCULPF2)

def itkMapContainerULCIFCTI2FFULULULPF2MCULPF2___New_orig__() -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Pointer":
    """itkMapContainerULCIFCTI2FFULULULPF2MCULPF2___New_orig__() -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2___New_orig__()

def itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_cast(obj: 'itkLightObject') -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 *":
    """itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_cast(itkLightObject obj) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2"""
    return _itkMeshBasePython.itkMapContainerULCIFCTI2FFULULULPF2MCULPF2_cast(obj)

class itkMapContainerULCIFCTI3FFULULULPF3MCULPF3(ITKCommonBasePython.itkObject):
    """


    A wrapper of the STL "map" container.

    Define a front-end to the STL "map" container that conforms to the
    IndexedContainerInterface. This is a full-fleged Object, so there are
    events, modification time, debug, and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  A type that shall be used to index the container.
    It must have a < operator defined for ordering.

    TElement:  The element type stored in the container.

    C++ includes: itkMapContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3
        __init__(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, std::less< unsigned long > const & comp) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3



        A wrapper of the STL "map" container.

        Define a front-end to the STL "map" container that conforms to the
        IndexedContainerInterface. This is a full-fleged Object, so there are
        events, modification time, debug, and reference count information.

        Parameters:
        -----------

        TElementIdentifier:  A type that shall be used to index the container.
        It must have a < operator defined for ordering.

        TElement:  The element type stored in the container.

        C++ includes: itkMapContainer.h 
        """
        _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_swiginit(self, _itkMeshBasePython.new_itkMapContainerULCIFCTI3FFULULULPF3MCULPF3(*args))

    def __New_orig__() -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Pointer":
        """__New_orig__() -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Pointer":
        """Clone(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Pointer"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Clone(self)


    def CastToSTLContainer(self) -> "std::map< unsigned long,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 * > > > &":
        """
        CastToSTLContainer(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self) -> std::map< unsigned long,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 * > > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::map< unsigned long,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 * > > > const &":
        """
        CastToSTLConstContainer(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self) -> std::map< unsigned long,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *,std::less< unsigned long >,std::allocator< std::pair< unsigned long const,itkCellInterfaceFCTI3FFULULULPF3MCULPF3 * > > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *const &":
        """
        ElementAt(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3
        ElementAt(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3

        Get a reference to the
        element at the given index. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *&":
        """
        CreateElementAt(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *&

        Get a reference to
        the element at the given index. If the index does not exist, it is
        created automatically.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI3FFULULULPF3MCULPF3 *":
        """
        GetElement(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3MCULPF3

        Get the element at the
        specified index. There is no check for existence performed. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3') -> "void":
        """
        SetElement(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3') -> "void":
        """
        InsertElement(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 arg1)

        Set the given index
        value to the given element. If the index doesn't exist, it is
        automatically created. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0) -> bool

        Check if the STL map
        has an entry corresponding to the given index. The count will be
        either 1 or 0. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3 **') -> "bool":
        """
        GetElementIfIndexExists(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3MCULPF3 ** arg1) -> bool

        If the
        given index doesn't exist in the map, return false. Otherwise, set the
        element through the pointer (if it isn't null), and return true. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        The map will create an
        entry for a given index through the indexing operator. Whether or not
        it is created, it will be assigned to the default element. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        Delete the entry in the
        STL map corresponding to the given identifier. If the entry does not
        exist, nothing happens. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self) -> unsigned long

        Get the number of elements
        currently stored in the map. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. This is NOT guaranteed to actually allocate any
        memory, but is useful if the implementation of the container allocates
        contiguous storage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self)

        Tell the container to
        release any memory it may have allocated and return itself to its
        initial state. 
        """
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMapContainerULCIFCTI3FFULULULPF3MCULPF3

    def cast(obj: 'itkLightObject') -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 *":
        """cast(itkLightObject obj) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 *":
        """GetPointer(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 self) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3"""
        return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3

        Create a new object of the class itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.Clone = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Clone, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CastToSTLContainer, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CastToSTLConstContainer, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.ElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_ElementAt, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CreateElementAt, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.GetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_GetElement, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.SetElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_SetElement, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.InsertElement = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_InsertElement, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.IndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_IndexExists, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_GetElementIfIndexExists, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_CreateIndex, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_DeleteIndex, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.Size = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Size, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.Reserve = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Reserve, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.Squeeze = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Squeeze, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.Initialize = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Initialize, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3.GetPointer = new_instancemethod(_itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_GetPointer, None, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_swigregister = _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_swigregister
itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_swigregister(itkMapContainerULCIFCTI3FFULULULPF3MCULPF3)

def itkMapContainerULCIFCTI3FFULULULPF3MCULPF3___New_orig__() -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Pointer":
    """itkMapContainerULCIFCTI3FFULULULPF3MCULPF3___New_orig__() -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_Pointer"""
    return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3___New_orig__()

def itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_cast(obj: 'itkLightObject') -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 *":
    """itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_cast(itkLightObject obj) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3"""
    return _itkMeshBasePython.itkMapContainerULCIFCTI3FFULULULPF3MCULPF3_cast(obj)

class itkMeshD2DTD22D(itkPointSetPython.itkPointSetD2DTD22DFD):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD2DTD22D_Pointer":
        """__New_orig__() -> itkMeshD2DTD22D_Pointer"""
        return _itkMeshBasePython.itkMeshD2DTD22D___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD2DTD22D_Pointer":
        """Clone(itkMeshD2DTD22D self) -> itkMeshD2DTD22D_Pointer"""
        return _itkMeshBasePython.itkMeshD2DTD22D_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshD2DTD22D_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshD2DTD22D_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshD2DTD22D_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshD2DTD22D_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD2DTD22D self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD2DTD22D') -> "void":
        """
        PassStructure(itkMeshD2DTD22D self, itkMeshD2DTD22D inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2DMCULPD2 const *":
        """
        GetBoundingBox(itkMeshD2DTD22D self) -> itkBoundingBoxUL2DMCULPD2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkMapContainerULSIT') -> "void":
        """
        SetCellLinks(itkMeshD2DTD22D self, itkMapContainerULSIT arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD2DTD22D_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkMapContainerULSIT const *":
        """
        GetCellLinks(itkMeshD2DTD22D self) -> itkMapContainerULSIT
        GetCellLinks(itkMeshD2DTD22D self) -> itkMapContainerULSIT
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkMapContainerULCIDCTI2DFULULULPD2MCULPD2') -> "void":
        """
        SetCells(itkMeshD2DTD22D self, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 const *":
        """
        GetCells(itkMeshD2DTD22D self) -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2
        GetCells(itkMeshD2DTD22D self) -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "void":
        """
        SetCell(itkMeshD2DTD22D self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """GetCell(itkMeshD2DTD22D self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD2DTD22D_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD2DTD22D self, itkMapContainerULD arg0)
        SetCellData(itkMeshD2DTD22D self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD2DTD22D self) -> itkMapContainerULD
        GetCellData(itkMeshD2DTD22D self) -> itkMapContainerULD
        GetCellData(itkMeshD2DTD22D self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD2DTD22D self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD2DTD22D self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD2DTD22D self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD2DTD22D_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD2DTD22D self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD2DTD22D self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD2DTD22D self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD2DTD22D self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshD2DTD22D_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD2DTD22D self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD2DTD22D self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD2DTD22D self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshD2DTD22D::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD2DTD22D self, itkMeshD2DTD22D::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22D_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshD2DTD22D::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshD2DTD22D self) -> itkMeshD2DTD22D::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshD2DTD22D_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD2DTD22D

    def cast(obj: 'itkLightObject') -> "itkMeshD2DTD22D *":
        """cast(itkLightObject obj) -> itkMeshD2DTD22D"""
        return _itkMeshBasePython.itkMeshD2DTD22D_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshD2DTD22D *":
        """GetPointer(itkMeshD2DTD22D self) -> itkMeshD2DTD22D"""
        return _itkMeshBasePython.itkMeshD2DTD22D_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshD2DTD22D

        Create a new object of the class itkMeshD2DTD22D and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD2DTD22D.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD2DTD22D.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD2DTD22D.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD2DTD22D.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_Clone, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetNumberOfCells, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_PassStructure, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetBoundingBox, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_SetCellLinks, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetCellLinks, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_SetCells, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetCells, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_SetCell, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetCell, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_SetCellData, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetCellData, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_SetBoundaryAssignment, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetBoundaryAssignment, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_RemoveBoundaryAssignment, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetNumberOfCellBoundaryFeatures, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetCellBoundaryFeature, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetCellBoundaryFeatureNeighbors, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetCellNeighbors, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetAssignedCellBoundaryIfOneExists, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_BuildCellLinks, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_Accept, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_SetCellsAllocationMethod, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetCellsAllocationMethod, None, itkMeshD2DTD22D)
itkMeshD2DTD22D.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22D_GetPointer, None, itkMeshD2DTD22D)
itkMeshD2DTD22D_swigregister = _itkMeshBasePython.itkMeshD2DTD22D_swigregister
itkMeshD2DTD22D_swigregister(itkMeshD2DTD22D)

def itkMeshD2DTD22D___New_orig__() -> "itkMeshD2DTD22D_Pointer":
    """itkMeshD2DTD22D___New_orig__() -> itkMeshD2DTD22D_Pointer"""
    return _itkMeshBasePython.itkMeshD2DTD22D___New_orig__()

def itkMeshD2DTD22D_cast(obj: 'itkLightObject') -> "itkMeshD2DTD22D *":
    """itkMeshD2DTD22D_cast(itkLightObject obj) -> itkMeshD2DTD22D"""
    return _itkMeshBasePython.itkMeshD2DTD22D_cast(obj)

class itkMeshD2DTD22DD(itkPointSetPython.itkPointSetD2DTD22DD):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD2DTD22DD_Pointer":
        """__New_orig__() -> itkMeshD2DTD22DD_Pointer"""
        return _itkMeshBasePython.itkMeshD2DTD22DD___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD2DTD22DD_Pointer":
        """Clone(itkMeshD2DTD22DD self) -> itkMeshD2DTD22DD_Pointer"""
        return _itkMeshBasePython.itkMeshD2DTD22DD_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshD2DTD22DD_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshD2DTD22DD_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshD2DTD22DD_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshD2DTD22DD_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD2DTD22DD self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD2DTD22DD') -> "void":
        """
        PassStructure(itkMeshD2DTD22DD self, itkMeshD2DTD22DD inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2DMCULPD2 const *":
        """
        GetBoundingBox(itkMeshD2DTD22DD self) -> itkBoundingBoxUL2DMCULPD2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkMapContainerULSIT') -> "void":
        """
        SetCellLinks(itkMeshD2DTD22DD self, itkMapContainerULSIT arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkMapContainerULSIT const *":
        """
        GetCellLinks(itkMeshD2DTD22DD self) -> itkMapContainerULSIT
        GetCellLinks(itkMeshD2DTD22DD self) -> itkMapContainerULSIT
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkMapContainerULCIDCTI2DDULULULPD2MCULPD2') -> "void":
        """
        SetCells(itkMeshD2DTD22DD self, itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkMapContainerULCIDCTI2DDULULULPD2MCULPD2 const *":
        """
        GetCells(itkMeshD2DTD22DD self) -> itkMapContainerULCIDCTI2DDULULULPD2MCULPD2
        GetCells(itkMeshD2DTD22DD self) -> itkMapContainerULCIDCTI2DDULULULPD2MCULPD2
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "void":
        """
        SetCell(itkMeshD2DTD22DD self, unsigned long arg0, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """GetCell(itkMeshD2DTD22DD self, unsigned long arg0, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD2DTD22DD self, itkMapContainerULD arg0)
        SetCellData(itkMeshD2DTD22DD self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD2DTD22DD self) -> itkMapContainerULD
        GetCellData(itkMeshD2DTD22DD self) -> itkMapContainerULD
        GetCellData(itkMeshD2DTD22DD self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD2DTD22DD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD2DTD22DD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD2DTD22DD self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD2DTD22DD_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD2DTD22DD self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD2DTD22DD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD2DTD22DD self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD2DTD22DD self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD2DTD22DD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2DDULULULPD2MCULPD2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD2DTD22DD self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI2DDULULULPD2MCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD2DTD22DD self, itkCellInterfaceDCTI2DDULULULPD2MCULPD2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshD2DTD22DD::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD2DTD22DD self, itkMeshD2DTD22DD::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DD_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshD2DTD22DD::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshD2DTD22DD self) -> itkMeshD2DTD22DD::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD2DTD22DD

    def cast(obj: 'itkLightObject') -> "itkMeshD2DTD22DD *":
        """cast(itkLightObject obj) -> itkMeshD2DTD22DD"""
        return _itkMeshBasePython.itkMeshD2DTD22DD_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshD2DTD22DD *":
        """GetPointer(itkMeshD2DTD22DD self) -> itkMeshD2DTD22DD"""
        return _itkMeshBasePython.itkMeshD2DTD22DD_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshD2DTD22DD

        Create a new object of the class itkMeshD2DTD22DD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD2DTD22DD.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD2DTD22DD.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD2DTD22DD.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD2DTD22DD.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_Clone, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetNumberOfCells, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_PassStructure, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetBoundingBox, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_SetCellLinks, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetCellLinks, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_SetCells, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetCells, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_SetCell, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetCell, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_SetCellData, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetCellData, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_SetBoundaryAssignment, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetBoundaryAssignment, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_RemoveBoundaryAssignment, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetNumberOfCellBoundaryFeatures, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetCellBoundaryFeature, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetCellBoundaryFeatureNeighbors, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetCellNeighbors, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetAssignedCellBoundaryIfOneExists, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_BuildCellLinks, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_Accept, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_SetCellsAllocationMethod, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetCellsAllocationMethod, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DD_GetPointer, None, itkMeshD2DTD22DD)
itkMeshD2DTD22DD_swigregister = _itkMeshBasePython.itkMeshD2DTD22DD_swigregister
itkMeshD2DTD22DD_swigregister(itkMeshD2DTD22DD)

def itkMeshD2DTD22DD___New_orig__() -> "itkMeshD2DTD22DD_Pointer":
    """itkMeshD2DTD22DD___New_orig__() -> itkMeshD2DTD22DD_Pointer"""
    return _itkMeshBasePython.itkMeshD2DTD22DD___New_orig__()

def itkMeshD2DTD22DD_cast(obj: 'itkLightObject') -> "itkMeshD2DTD22DD *":
    """itkMeshD2DTD22DD_cast(itkLightObject obj) -> itkMeshD2DTD22DD"""
    return _itkMeshBasePython.itkMeshD2DTD22DD_cast(obj)

class itkMeshD2DTD22DFD(itkPointSetPython.itkPointSetD2DTD22DFD):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD2DTD22D_Pointer":
        """__New_orig__() -> itkMeshD2DTD22D_Pointer"""
        return _itkMeshBasePython.itkMeshD2DTD22DFD___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD2DTD22D_Pointer":
        """Clone(itkMeshD2DTD22DFD self) -> itkMeshD2DTD22D_Pointer"""
        return _itkMeshBasePython.itkMeshD2DTD22DFD_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshD2DTD22DFD_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshD2DTD22DFD_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshD2DTD22DFD_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshD2DTD22DFD_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD2DTD22DFD self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD2DTD22D') -> "void":
        """
        PassStructure(itkMeshD2DTD22DFD self, itkMeshD2DTD22D inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2DMCULPD2 const *":
        """
        GetBoundingBox(itkMeshD2DTD22DFD self) -> itkBoundingBoxUL2DMCULPD2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkMapContainerULSIT') -> "void":
        """
        SetCellLinks(itkMeshD2DTD22DFD self, itkMapContainerULSIT arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkMapContainerULSIT const *":
        """
        GetCellLinks(itkMeshD2DTD22DFD self) -> itkMapContainerULSIT
        GetCellLinks(itkMeshD2DTD22DFD self) -> itkMapContainerULSIT
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkMapContainerULCIDCTI2DFULULULPD2MCULPD2') -> "void":
        """
        SetCells(itkMeshD2DTD22DFD self, itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkMapContainerULCIDCTI2DFULULULPD2MCULPD2 const *":
        """
        GetCells(itkMeshD2DTD22DFD self) -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2
        GetCells(itkMeshD2DTD22DFD self) -> itkMapContainerULCIDCTI2DFULULULPD2MCULPD2
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "void":
        """
        SetCell(itkMeshD2DTD22DFD self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """GetCell(itkMeshD2DTD22DFD self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD2DTD22DFD self, itkMapContainerULD arg0)
        SetCellData(itkMeshD2DTD22DFD self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD2DTD22DFD self) -> itkMapContainerULD
        GetCellData(itkMeshD2DTD22DFD self) -> itkMapContainerULD
        GetCellData(itkMeshD2DTD22DFD self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD2DTD22DFD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD2DTD22DFD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD2DTD22DFD self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD2DTD22DFD_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD2DTD22DFD self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD2DTD22DFD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD2DTD22DFD self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD2DTD22DFD self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD2DTD22DFD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2DFULULULPD2MCULPD2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD2DTD22DFD self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI2DFULULULPD2MCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD2DTD22DFD self, itkCellInterfaceDCTI2DFULULULPD2MCULPD2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshD2DTD22D::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD2DTD22DFD self, itkMeshD2DTD22D::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD2DTD22DFD_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshD2DTD22D::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshD2DTD22DFD self) -> itkMeshD2DTD22D::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD2DTD22DFD

    def cast(obj: 'itkLightObject') -> "itkMeshD2DTD22DFD *":
        """cast(itkLightObject obj) -> itkMeshD2DTD22DFD"""
        return _itkMeshBasePython.itkMeshD2DTD22DFD_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshD2DTD22DFD *":
        """GetPointer(itkMeshD2DTD22DFD self) -> itkMeshD2DTD22DFD"""
        return _itkMeshBasePython.itkMeshD2DTD22DFD_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshD2DTD22DFD

        Create a new object of the class itkMeshD2DTD22DFD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD2DTD22DFD.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD2DTD22DFD.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD2DTD22DFD.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD2DTD22DFD.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_Clone, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetNumberOfCells, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_PassStructure, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetBoundingBox, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_SetCellLinks, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetCellLinks, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_SetCells, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetCells, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_SetCell, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetCell, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_SetCellData, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetCellData, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_SetBoundaryAssignment, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetBoundaryAssignment, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_RemoveBoundaryAssignment, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetNumberOfCellBoundaryFeatures, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetCellBoundaryFeature, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetCellBoundaryFeatureNeighbors, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetCellNeighbors, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetAssignedCellBoundaryIfOneExists, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_BuildCellLinks, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_Accept, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_SetCellsAllocationMethod, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetCellsAllocationMethod, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshD2DTD22DFD_GetPointer, None, itkMeshD2DTD22DFD)
itkMeshD2DTD22DFD_swigregister = _itkMeshBasePython.itkMeshD2DTD22DFD_swigregister
itkMeshD2DTD22DFD_swigregister(itkMeshD2DTD22DFD)

def itkMeshD2DTD22DFD___New_orig__() -> "itkMeshD2DTD22D_Pointer":
    """itkMeshD2DTD22DFD___New_orig__() -> itkMeshD2DTD22D_Pointer"""
    return _itkMeshBasePython.itkMeshD2DTD22DFD___New_orig__()

def itkMeshD2DTD22DFD_cast(obj: 'itkLightObject') -> "itkMeshD2DTD22DFD *":
    """itkMeshD2DTD22DFD_cast(itkLightObject obj) -> itkMeshD2DTD22DFD"""
    return _itkMeshBasePython.itkMeshD2DTD22DFD_cast(obj)

class itkMeshD2STD22D(itkPointSetPython.itkPointSetD2STD22DFD):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD2STD22D_Pointer":
        """__New_orig__() -> itkMeshD2STD22D_Pointer"""
        return _itkMeshBasePython.itkMeshD2STD22D___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD2STD22D_Pointer":
        """Clone(itkMeshD2STD22D self) -> itkMeshD2STD22D_Pointer"""
        return _itkMeshBasePython.itkMeshD2STD22D_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshD2STD22D_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshD2STD22D_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshD2STD22D_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshD2STD22D_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD2STD22D self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD2STD22D') -> "void":
        """
        PassStructure(itkMeshD2STD22D self, itkMeshD2STD22D inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2DVCULPD2 const *":
        """
        GetBoundingBox(itkMeshD2STD22D self) -> itkBoundingBoxUL2DVCULPD2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshD2STD22D self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD2STD22D_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshD2STD22D self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshD2STD22D self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshD2STD22D_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2') -> "void":
        """
        SetCells(itkMeshD2STD22D self, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 const *":
        """
        GetCells(itkMeshD2STD22D self) -> itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2
        GetCells(itkMeshD2STD22D self) -> itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2
        """
        return _itkMeshBasePython.itkMeshD2STD22D_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "void":
        """
        SetCell(itkMeshD2STD22D self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """GetCell(itkMeshD2STD22D self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD2STD22D_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD2STD22D self, itkVectorContainerULD arg0)
        SetCellData(itkMeshD2STD22D self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD2STD22D self) -> itkVectorContainerULD
        GetCellData(itkMeshD2STD22D self) -> itkVectorContainerULD
        GetCellData(itkMeshD2STD22D self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD2STD22D_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD2STD22D self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD2STD22D self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD2STD22D self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD2STD22D_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD2STD22D self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD2STD22D self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD2STD22D self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD2STD22D self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshD2STD22D_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD2STD22D self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD2STD22D self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD2STD22D self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshD2STD22D::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD2STD22D self, itkMeshD2STD22D::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD2STD22D_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshD2STD22D::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshD2STD22D self) -> itkMeshD2STD22D::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshD2STD22D_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD2STD22D

    def cast(obj: 'itkLightObject') -> "itkMeshD2STD22D *":
        """cast(itkLightObject obj) -> itkMeshD2STD22D"""
        return _itkMeshBasePython.itkMeshD2STD22D_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshD2STD22D *":
        """GetPointer(itkMeshD2STD22D self) -> itkMeshD2STD22D"""
        return _itkMeshBasePython.itkMeshD2STD22D_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshD2STD22D

        Create a new object of the class itkMeshD2STD22D and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD2STD22D.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD2STD22D.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD2STD22D.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD2STD22D.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_Clone, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetNumberOfCells, None, itkMeshD2STD22D)
itkMeshD2STD22D.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_PassStructure, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetBoundingBox, None, itkMeshD2STD22D)
itkMeshD2STD22D.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_SetCellLinks, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetCellLinks, None, itkMeshD2STD22D)
itkMeshD2STD22D.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_SetCells, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetCells, None, itkMeshD2STD22D)
itkMeshD2STD22D.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_SetCell, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetCell, None, itkMeshD2STD22D)
itkMeshD2STD22D.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_SetCellData, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetCellData, None, itkMeshD2STD22D)
itkMeshD2STD22D.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_SetBoundaryAssignment, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetBoundaryAssignment, None, itkMeshD2STD22D)
itkMeshD2STD22D.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_RemoveBoundaryAssignment, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetNumberOfCellBoundaryFeatures, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetCellBoundaryFeature, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetCellBoundaryFeatureNeighbors, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetCellNeighbors, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetAssignedCellBoundaryIfOneExists, None, itkMeshD2STD22D)
itkMeshD2STD22D.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_BuildCellLinks, None, itkMeshD2STD22D)
itkMeshD2STD22D.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_Accept, None, itkMeshD2STD22D)
itkMeshD2STD22D.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_SetCellsAllocationMethod, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetCellsAllocationMethod, None, itkMeshD2STD22D)
itkMeshD2STD22D.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22D_GetPointer, None, itkMeshD2STD22D)
itkMeshD2STD22D_swigregister = _itkMeshBasePython.itkMeshD2STD22D_swigregister
itkMeshD2STD22D_swigregister(itkMeshD2STD22D)

def itkMeshD2STD22D___New_orig__() -> "itkMeshD2STD22D_Pointer":
    """itkMeshD2STD22D___New_orig__() -> itkMeshD2STD22D_Pointer"""
    return _itkMeshBasePython.itkMeshD2STD22D___New_orig__()

def itkMeshD2STD22D_cast(obj: 'itkLightObject') -> "itkMeshD2STD22D *":
    """itkMeshD2STD22D_cast(itkLightObject obj) -> itkMeshD2STD22D"""
    return _itkMeshBasePython.itkMeshD2STD22D_cast(obj)

class itkMeshD2STD22DD(itkPointSetPython.itkPointSetD2STD22DD):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD2STD22DD_Pointer":
        """__New_orig__() -> itkMeshD2STD22DD_Pointer"""
        return _itkMeshBasePython.itkMeshD2STD22DD___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD2STD22DD_Pointer":
        """Clone(itkMeshD2STD22DD self) -> itkMeshD2STD22DD_Pointer"""
        return _itkMeshBasePython.itkMeshD2STD22DD_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshD2STD22DD_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshD2STD22DD_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshD2STD22DD_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshD2STD22DD_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD2STD22DD self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD2STD22DD') -> "void":
        """
        PassStructure(itkMeshD2STD22DD self, itkMeshD2STD22DD inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2DVCULPD2 const *":
        """
        GetBoundingBox(itkMeshD2STD22DD self) -> itkBoundingBoxUL2DVCULPD2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshD2STD22DD self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD2STD22DD_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshD2STD22DD self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshD2STD22DD self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2') -> "void":
        """
        SetCells(itkMeshD2STD22DD self, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 const *":
        """
        GetCells(itkMeshD2STD22DD self) -> itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2
        GetCells(itkMeshD2STD22DD self) -> itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "void":
        """
        SetCell(itkMeshD2STD22DD self, unsigned long arg0, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """GetCell(itkMeshD2STD22DD self, unsigned long arg0, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD2STD22DD_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD2STD22DD self, itkVectorContainerULD arg0)
        SetCellData(itkMeshD2STD22DD self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD2STD22DD self) -> itkVectorContainerULD
        GetCellData(itkMeshD2STD22DD self) -> itkVectorContainerULD
        GetCellData(itkMeshD2STD22DD self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD2STD22DD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD2STD22DD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD2STD22DD self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD2STD22DD_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD2STD22DD self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD2STD22DD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD2STD22DD self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD2STD22DD self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshD2STD22DD_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD2STD22DD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2DDULULULPD2VCULPD2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD2STD22DD self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD2STD22DD self, itkCellInterfaceDCTI2DDULULULPD2VCULPD2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshD2STD22DD::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD2STD22DD self, itkMeshD2STD22DD::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DD_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshD2STD22DD::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshD2STD22DD self) -> itkMeshD2STD22DD::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshD2STD22DD_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD2STD22DD

    def cast(obj: 'itkLightObject') -> "itkMeshD2STD22DD *":
        """cast(itkLightObject obj) -> itkMeshD2STD22DD"""
        return _itkMeshBasePython.itkMeshD2STD22DD_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshD2STD22DD *":
        """GetPointer(itkMeshD2STD22DD self) -> itkMeshD2STD22DD"""
        return _itkMeshBasePython.itkMeshD2STD22DD_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshD2STD22DD

        Create a new object of the class itkMeshD2STD22DD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD2STD22DD.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD2STD22DD.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD2STD22DD.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD2STD22DD.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_Clone, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetNumberOfCells, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_PassStructure, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetBoundingBox, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_SetCellLinks, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetCellLinks, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_SetCells, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetCells, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_SetCell, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetCell, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_SetCellData, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetCellData, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_SetBoundaryAssignment, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetBoundaryAssignment, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_RemoveBoundaryAssignment, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetNumberOfCellBoundaryFeatures, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetCellBoundaryFeature, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetCellBoundaryFeatureNeighbors, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetCellNeighbors, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetAssignedCellBoundaryIfOneExists, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_BuildCellLinks, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_Accept, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_SetCellsAllocationMethod, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetCellsAllocationMethod, None, itkMeshD2STD22DD)
itkMeshD2STD22DD.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DD_GetPointer, None, itkMeshD2STD22DD)
itkMeshD2STD22DD_swigregister = _itkMeshBasePython.itkMeshD2STD22DD_swigregister
itkMeshD2STD22DD_swigregister(itkMeshD2STD22DD)

def itkMeshD2STD22DD___New_orig__() -> "itkMeshD2STD22DD_Pointer":
    """itkMeshD2STD22DD___New_orig__() -> itkMeshD2STD22DD_Pointer"""
    return _itkMeshBasePython.itkMeshD2STD22DD___New_orig__()

def itkMeshD2STD22DD_cast(obj: 'itkLightObject') -> "itkMeshD2STD22DD *":
    """itkMeshD2STD22DD_cast(itkLightObject obj) -> itkMeshD2STD22DD"""
    return _itkMeshBasePython.itkMeshD2STD22DD_cast(obj)

class itkMeshD2STD22DFD(itkPointSetPython.itkPointSetD2STD22DFD):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD2STD22D_Pointer":
        """__New_orig__() -> itkMeshD2STD22D_Pointer"""
        return _itkMeshBasePython.itkMeshD2STD22DFD___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD2STD22D_Pointer":
        """Clone(itkMeshD2STD22DFD self) -> itkMeshD2STD22D_Pointer"""
        return _itkMeshBasePython.itkMeshD2STD22DFD_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshD2STD22DFD_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshD2STD22DFD_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshD2STD22DFD_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshD2STD22DFD_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD2STD22DFD self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD2STD22D') -> "void":
        """
        PassStructure(itkMeshD2STD22DFD self, itkMeshD2STD22D inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2DVCULPD2 const *":
        """
        GetBoundingBox(itkMeshD2STD22DFD self) -> itkBoundingBoxUL2DVCULPD2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshD2STD22DFD self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshD2STD22DFD self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshD2STD22DFD self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2') -> "void":
        """
        SetCells(itkMeshD2STD22DFD self, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 const *":
        """
        GetCells(itkMeshD2STD22DFD self) -> itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2
        GetCells(itkMeshD2STD22DFD self) -> itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "void":
        """
        SetCell(itkMeshD2STD22DFD self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """GetCell(itkMeshD2STD22DFD self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD2STD22DFD self, itkVectorContainerULD arg0)
        SetCellData(itkMeshD2STD22DFD self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD2STD22DFD self) -> itkVectorContainerULD
        GetCellData(itkMeshD2STD22DFD self) -> itkVectorContainerULD
        GetCellData(itkMeshD2STD22DFD self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD2STD22DFD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD2STD22DFD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD2STD22DFD self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD2STD22DFD_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD2STD22DFD self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD2STD22DFD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD2STD22DFD self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD2STD22DFD self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD2STD22DFD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI2DFULULULPD2VCULPD2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD2STD22DFD self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD2STD22DFD self, itkCellInterfaceDCTI2DFULULULPD2VCULPD2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshD2STD22D::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD2STD22DFD self, itkMeshD2STD22D::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD2STD22DFD_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshD2STD22D::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshD2STD22DFD self) -> itkMeshD2STD22D::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD2STD22DFD

    def cast(obj: 'itkLightObject') -> "itkMeshD2STD22DFD *":
        """cast(itkLightObject obj) -> itkMeshD2STD22DFD"""
        return _itkMeshBasePython.itkMeshD2STD22DFD_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshD2STD22DFD *":
        """GetPointer(itkMeshD2STD22DFD self) -> itkMeshD2STD22DFD"""
        return _itkMeshBasePython.itkMeshD2STD22DFD_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshD2STD22DFD

        Create a new object of the class itkMeshD2STD22DFD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD2STD22DFD.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD2STD22DFD.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD2STD22DFD.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD2STD22DFD.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_Clone, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetNumberOfCells, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_PassStructure, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetBoundingBox, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_SetCellLinks, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetCellLinks, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_SetCells, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetCells, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_SetCell, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetCell, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_SetCellData, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetCellData, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_SetBoundaryAssignment, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetBoundaryAssignment, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_RemoveBoundaryAssignment, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetNumberOfCellBoundaryFeatures, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetCellBoundaryFeature, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetCellBoundaryFeatureNeighbors, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetCellNeighbors, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetAssignedCellBoundaryIfOneExists, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_BuildCellLinks, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_Accept, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_SetCellsAllocationMethod, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetCellsAllocationMethod, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshD2STD22DFD_GetPointer, None, itkMeshD2STD22DFD)
itkMeshD2STD22DFD_swigregister = _itkMeshBasePython.itkMeshD2STD22DFD_swigregister
itkMeshD2STD22DFD_swigregister(itkMeshD2STD22DFD)

def itkMeshD2STD22DFD___New_orig__() -> "itkMeshD2STD22D_Pointer":
    """itkMeshD2STD22DFD___New_orig__() -> itkMeshD2STD22D_Pointer"""
    return _itkMeshBasePython.itkMeshD2STD22DFD___New_orig__()

def itkMeshD2STD22DFD_cast(obj: 'itkLightObject') -> "itkMeshD2STD22DFD *":
    """itkMeshD2STD22DFD_cast(itkLightObject obj) -> itkMeshD2STD22DFD"""
    return _itkMeshBasePython.itkMeshD2STD22DFD_cast(obj)

class itkMeshD3DTD33D(itkPointSetPython.itkPointSetD3DTD33DFD):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD3DTD33D_Pointer":
        """__New_orig__() -> itkMeshD3DTD33D_Pointer"""
        return _itkMeshBasePython.itkMeshD3DTD33D___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD3DTD33D_Pointer":
        """Clone(itkMeshD3DTD33D self) -> itkMeshD3DTD33D_Pointer"""
        return _itkMeshBasePython.itkMeshD3DTD33D_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshD3DTD33D_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshD3DTD33D_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshD3DTD33D_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshD3DTD33D_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD3DTD33D self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD3DTD33D') -> "void":
        """
        PassStructure(itkMeshD3DTD33D self, itkMeshD3DTD33D inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3DMCULPD3 const *":
        """
        GetBoundingBox(itkMeshD3DTD33D self) -> itkBoundingBoxUL3DMCULPD3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkMapContainerULSIT') -> "void":
        """
        SetCellLinks(itkMeshD3DTD33D self, itkMapContainerULSIT arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD3DTD33D_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkMapContainerULSIT const *":
        """
        GetCellLinks(itkMeshD3DTD33D self) -> itkMapContainerULSIT
        GetCellLinks(itkMeshD3DTD33D self) -> itkMapContainerULSIT
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkMapContainerULCIDCTI3DFULULULPD3MCULPD3') -> "void":
        """
        SetCells(itkMeshD3DTD33D self, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 const *":
        """
        GetCells(itkMeshD3DTD33D self) -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3
        GetCells(itkMeshD3DTD33D self) -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "void":
        """
        SetCell(itkMeshD3DTD33D self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """GetCell(itkMeshD3DTD33D self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD3DTD33D_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD3DTD33D self, itkMapContainerULD arg0)
        SetCellData(itkMeshD3DTD33D self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD3DTD33D self) -> itkMapContainerULD
        GetCellData(itkMeshD3DTD33D self) -> itkMapContainerULD
        GetCellData(itkMeshD3DTD33D self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD3DTD33D self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD3DTD33D self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD3DTD33D self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD3DTD33D_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD3DTD33D self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD3DTD33D self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD3DTD33D self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD3DTD33D self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshD3DTD33D_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD3DTD33D self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD3DTD33D self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD3DTD33D self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshD3DTD33D::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD3DTD33D self, itkMeshD3DTD33D::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33D_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshD3DTD33D::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshD3DTD33D self) -> itkMeshD3DTD33D::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshD3DTD33D_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD3DTD33D

    def cast(obj: 'itkLightObject') -> "itkMeshD3DTD33D *":
        """cast(itkLightObject obj) -> itkMeshD3DTD33D"""
        return _itkMeshBasePython.itkMeshD3DTD33D_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshD3DTD33D *":
        """GetPointer(itkMeshD3DTD33D self) -> itkMeshD3DTD33D"""
        return _itkMeshBasePython.itkMeshD3DTD33D_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshD3DTD33D

        Create a new object of the class itkMeshD3DTD33D and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD3DTD33D.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD3DTD33D.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD3DTD33D.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD3DTD33D.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_Clone, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetNumberOfCells, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_PassStructure, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetBoundingBox, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_SetCellLinks, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetCellLinks, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_SetCells, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetCells, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_SetCell, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetCell, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_SetCellData, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetCellData, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_SetBoundaryAssignment, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetBoundaryAssignment, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_RemoveBoundaryAssignment, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetNumberOfCellBoundaryFeatures, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetCellBoundaryFeature, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetCellBoundaryFeatureNeighbors, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetCellNeighbors, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetAssignedCellBoundaryIfOneExists, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_BuildCellLinks, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_Accept, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_SetCellsAllocationMethod, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetCellsAllocationMethod, None, itkMeshD3DTD33D)
itkMeshD3DTD33D.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33D_GetPointer, None, itkMeshD3DTD33D)
itkMeshD3DTD33D_swigregister = _itkMeshBasePython.itkMeshD3DTD33D_swigregister
itkMeshD3DTD33D_swigregister(itkMeshD3DTD33D)

def itkMeshD3DTD33D___New_orig__() -> "itkMeshD3DTD33D_Pointer":
    """itkMeshD3DTD33D___New_orig__() -> itkMeshD3DTD33D_Pointer"""
    return _itkMeshBasePython.itkMeshD3DTD33D___New_orig__()

def itkMeshD3DTD33D_cast(obj: 'itkLightObject') -> "itkMeshD3DTD33D *":
    """itkMeshD3DTD33D_cast(itkLightObject obj) -> itkMeshD3DTD33D"""
    return _itkMeshBasePython.itkMeshD3DTD33D_cast(obj)

class itkMeshD3DTD33DD(itkPointSetPython.itkPointSetD3DTD33DD):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD3DTD33DD_Pointer":
        """__New_orig__() -> itkMeshD3DTD33DD_Pointer"""
        return _itkMeshBasePython.itkMeshD3DTD33DD___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD3DTD33DD_Pointer":
        """Clone(itkMeshD3DTD33DD self) -> itkMeshD3DTD33DD_Pointer"""
        return _itkMeshBasePython.itkMeshD3DTD33DD_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshD3DTD33DD_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshD3DTD33DD_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshD3DTD33DD_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshD3DTD33DD_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD3DTD33DD self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD3DTD33DD') -> "void":
        """
        PassStructure(itkMeshD3DTD33DD self, itkMeshD3DTD33DD inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3DMCULPD3 const *":
        """
        GetBoundingBox(itkMeshD3DTD33DD self) -> itkBoundingBoxUL3DMCULPD3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkMapContainerULSIT') -> "void":
        """
        SetCellLinks(itkMeshD3DTD33DD self, itkMapContainerULSIT arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkMapContainerULSIT const *":
        """
        GetCellLinks(itkMeshD3DTD33DD self) -> itkMapContainerULSIT
        GetCellLinks(itkMeshD3DTD33DD self) -> itkMapContainerULSIT
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkMapContainerULCIDCTI3DDULULULPD3MCULPD3') -> "void":
        """
        SetCells(itkMeshD3DTD33DD self, itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkMapContainerULCIDCTI3DDULULULPD3MCULPD3 const *":
        """
        GetCells(itkMeshD3DTD33DD self) -> itkMapContainerULCIDCTI3DDULULULPD3MCULPD3
        GetCells(itkMeshD3DTD33DD self) -> itkMapContainerULCIDCTI3DDULULULPD3MCULPD3
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "void":
        """
        SetCell(itkMeshD3DTD33DD self, unsigned long arg0, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """GetCell(itkMeshD3DTD33DD self, unsigned long arg0, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD3DTD33DD self, itkMapContainerULD arg0)
        SetCellData(itkMeshD3DTD33DD self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD3DTD33DD self) -> itkMapContainerULD
        GetCellData(itkMeshD3DTD33DD self) -> itkMapContainerULD
        GetCellData(itkMeshD3DTD33DD self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD3DTD33DD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD3DTD33DD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD3DTD33DD self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD3DTD33DD_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD3DTD33DD self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD3DTD33DD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD3DTD33DD self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD3DTD33DD self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD3DTD33DD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3DDULULULPD3MCULPD3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD3DTD33DD self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI3DDULULULPD3MCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD3DTD33DD self, itkCellInterfaceDCTI3DDULULULPD3MCULPD3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshD3DTD33DD::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD3DTD33DD self, itkMeshD3DTD33DD::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DD_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshD3DTD33DD::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshD3DTD33DD self) -> itkMeshD3DTD33DD::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD3DTD33DD

    def cast(obj: 'itkLightObject') -> "itkMeshD3DTD33DD *":
        """cast(itkLightObject obj) -> itkMeshD3DTD33DD"""
        return _itkMeshBasePython.itkMeshD3DTD33DD_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshD3DTD33DD *":
        """GetPointer(itkMeshD3DTD33DD self) -> itkMeshD3DTD33DD"""
        return _itkMeshBasePython.itkMeshD3DTD33DD_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshD3DTD33DD

        Create a new object of the class itkMeshD3DTD33DD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD3DTD33DD.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD3DTD33DD.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD3DTD33DD.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD3DTD33DD.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_Clone, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetNumberOfCells, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_PassStructure, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetBoundingBox, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_SetCellLinks, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetCellLinks, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_SetCells, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetCells, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_SetCell, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetCell, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_SetCellData, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetCellData, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_SetBoundaryAssignment, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetBoundaryAssignment, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_RemoveBoundaryAssignment, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetNumberOfCellBoundaryFeatures, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetCellBoundaryFeature, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetCellBoundaryFeatureNeighbors, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetCellNeighbors, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetAssignedCellBoundaryIfOneExists, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_BuildCellLinks, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_Accept, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_SetCellsAllocationMethod, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetCellsAllocationMethod, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DD_GetPointer, None, itkMeshD3DTD33DD)
itkMeshD3DTD33DD_swigregister = _itkMeshBasePython.itkMeshD3DTD33DD_swigregister
itkMeshD3DTD33DD_swigregister(itkMeshD3DTD33DD)

def itkMeshD3DTD33DD___New_orig__() -> "itkMeshD3DTD33DD_Pointer":
    """itkMeshD3DTD33DD___New_orig__() -> itkMeshD3DTD33DD_Pointer"""
    return _itkMeshBasePython.itkMeshD3DTD33DD___New_orig__()

def itkMeshD3DTD33DD_cast(obj: 'itkLightObject') -> "itkMeshD3DTD33DD *":
    """itkMeshD3DTD33DD_cast(itkLightObject obj) -> itkMeshD3DTD33DD"""
    return _itkMeshBasePython.itkMeshD3DTD33DD_cast(obj)

class itkMeshD3DTD33DFD(itkPointSetPython.itkPointSetD3DTD33DFD):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD3DTD33D_Pointer":
        """__New_orig__() -> itkMeshD3DTD33D_Pointer"""
        return _itkMeshBasePython.itkMeshD3DTD33DFD___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD3DTD33D_Pointer":
        """Clone(itkMeshD3DTD33DFD self) -> itkMeshD3DTD33D_Pointer"""
        return _itkMeshBasePython.itkMeshD3DTD33DFD_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshD3DTD33DFD_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshD3DTD33DFD_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshD3DTD33DFD_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshD3DTD33DFD_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD3DTD33DFD self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD3DTD33D') -> "void":
        """
        PassStructure(itkMeshD3DTD33DFD self, itkMeshD3DTD33D inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3DMCULPD3 const *":
        """
        GetBoundingBox(itkMeshD3DTD33DFD self) -> itkBoundingBoxUL3DMCULPD3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkMapContainerULSIT') -> "void":
        """
        SetCellLinks(itkMeshD3DTD33DFD self, itkMapContainerULSIT arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkMapContainerULSIT const *":
        """
        GetCellLinks(itkMeshD3DTD33DFD self) -> itkMapContainerULSIT
        GetCellLinks(itkMeshD3DTD33DFD self) -> itkMapContainerULSIT
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkMapContainerULCIDCTI3DFULULULPD3MCULPD3') -> "void":
        """
        SetCells(itkMeshD3DTD33DFD self, itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkMapContainerULCIDCTI3DFULULULPD3MCULPD3 const *":
        """
        GetCells(itkMeshD3DTD33DFD self) -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3
        GetCells(itkMeshD3DTD33DFD self) -> itkMapContainerULCIDCTI3DFULULULPD3MCULPD3
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "void":
        """
        SetCell(itkMeshD3DTD33DFD self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """GetCell(itkMeshD3DTD33DFD self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD3DTD33DFD self, itkMapContainerULD arg0)
        SetCellData(itkMeshD3DTD33DFD self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD3DTD33DFD self) -> itkMapContainerULD
        GetCellData(itkMeshD3DTD33DFD self) -> itkMapContainerULD
        GetCellData(itkMeshD3DTD33DFD self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD3DTD33DFD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD3DTD33DFD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD3DTD33DFD self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD3DTD33DFD_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD3DTD33DFD self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD3DTD33DFD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD3DTD33DFD self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD3DTD33DFD self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD3DTD33DFD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3DFULULULPD3MCULPD3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD3DTD33DFD self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI3DFULULULPD3MCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD3DTD33DFD self, itkCellInterfaceDCTI3DFULULULPD3MCULPD3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshD3DTD33D::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD3DTD33DFD self, itkMeshD3DTD33D::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD3DTD33DFD_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshD3DTD33D::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshD3DTD33DFD self) -> itkMeshD3DTD33D::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD3DTD33DFD

    def cast(obj: 'itkLightObject') -> "itkMeshD3DTD33DFD *":
        """cast(itkLightObject obj) -> itkMeshD3DTD33DFD"""
        return _itkMeshBasePython.itkMeshD3DTD33DFD_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshD3DTD33DFD *":
        """GetPointer(itkMeshD3DTD33DFD self) -> itkMeshD3DTD33DFD"""
        return _itkMeshBasePython.itkMeshD3DTD33DFD_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshD3DTD33DFD

        Create a new object of the class itkMeshD3DTD33DFD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD3DTD33DFD.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD3DTD33DFD.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD3DTD33DFD.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD3DTD33DFD.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_Clone, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetNumberOfCells, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_PassStructure, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetBoundingBox, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_SetCellLinks, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetCellLinks, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_SetCells, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetCells, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_SetCell, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetCell, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_SetCellData, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetCellData, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_SetBoundaryAssignment, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetBoundaryAssignment, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_RemoveBoundaryAssignment, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetNumberOfCellBoundaryFeatures, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetCellBoundaryFeature, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetCellBoundaryFeatureNeighbors, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetCellNeighbors, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetAssignedCellBoundaryIfOneExists, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_BuildCellLinks, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_Accept, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_SetCellsAllocationMethod, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetCellsAllocationMethod, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshD3DTD33DFD_GetPointer, None, itkMeshD3DTD33DFD)
itkMeshD3DTD33DFD_swigregister = _itkMeshBasePython.itkMeshD3DTD33DFD_swigregister
itkMeshD3DTD33DFD_swigregister(itkMeshD3DTD33DFD)

def itkMeshD3DTD33DFD___New_orig__() -> "itkMeshD3DTD33D_Pointer":
    """itkMeshD3DTD33DFD___New_orig__() -> itkMeshD3DTD33D_Pointer"""
    return _itkMeshBasePython.itkMeshD3DTD33DFD___New_orig__()

def itkMeshD3DTD33DFD_cast(obj: 'itkLightObject') -> "itkMeshD3DTD33DFD *":
    """itkMeshD3DTD33DFD_cast(itkLightObject obj) -> itkMeshD3DTD33DFD"""
    return _itkMeshBasePython.itkMeshD3DTD33DFD_cast(obj)

class itkMeshD3STD33D(itkPointSetPython.itkPointSetD3STD33DFD):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD3STD33D_Pointer":
        """__New_orig__() -> itkMeshD3STD33D_Pointer"""
        return _itkMeshBasePython.itkMeshD3STD33D___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD3STD33D_Pointer":
        """Clone(itkMeshD3STD33D self) -> itkMeshD3STD33D_Pointer"""
        return _itkMeshBasePython.itkMeshD3STD33D_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshD3STD33D_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshD3STD33D_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshD3STD33D_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshD3STD33D_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD3STD33D self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD3STD33D') -> "void":
        """
        PassStructure(itkMeshD3STD33D self, itkMeshD3STD33D inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3DVCULPD3 const *":
        """
        GetBoundingBox(itkMeshD3STD33D self) -> itkBoundingBoxUL3DVCULPD3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshD3STD33D self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD3STD33D_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshD3STD33D self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshD3STD33D self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshD3STD33D_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3') -> "void":
        """
        SetCells(itkMeshD3STD33D self, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 const *":
        """
        GetCells(itkMeshD3STD33D self) -> itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3
        GetCells(itkMeshD3STD33D self) -> itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3
        """
        return _itkMeshBasePython.itkMeshD3STD33D_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "void":
        """
        SetCell(itkMeshD3STD33D self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """GetCell(itkMeshD3STD33D self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD3STD33D_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD3STD33D self, itkVectorContainerULD arg0)
        SetCellData(itkMeshD3STD33D self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD3STD33D self) -> itkVectorContainerULD
        GetCellData(itkMeshD3STD33D self) -> itkVectorContainerULD
        GetCellData(itkMeshD3STD33D self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD3STD33D_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD3STD33D self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD3STD33D self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD3STD33D self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD3STD33D_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD3STD33D self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD3STD33D self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD3STD33D self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD3STD33D self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshD3STD33D_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD3STD33D self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD3STD33D self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD3STD33D self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshD3STD33D::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD3STD33D self, itkMeshD3STD33D::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD3STD33D_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshD3STD33D::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshD3STD33D self) -> itkMeshD3STD33D::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshD3STD33D_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD3STD33D

    def cast(obj: 'itkLightObject') -> "itkMeshD3STD33D *":
        """cast(itkLightObject obj) -> itkMeshD3STD33D"""
        return _itkMeshBasePython.itkMeshD3STD33D_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshD3STD33D *":
        """GetPointer(itkMeshD3STD33D self) -> itkMeshD3STD33D"""
        return _itkMeshBasePython.itkMeshD3STD33D_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshD3STD33D

        Create a new object of the class itkMeshD3STD33D and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD3STD33D.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD3STD33D.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD3STD33D.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD3STD33D.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_Clone, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetNumberOfCells, None, itkMeshD3STD33D)
itkMeshD3STD33D.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_PassStructure, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetBoundingBox, None, itkMeshD3STD33D)
itkMeshD3STD33D.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_SetCellLinks, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetCellLinks, None, itkMeshD3STD33D)
itkMeshD3STD33D.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_SetCells, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetCells, None, itkMeshD3STD33D)
itkMeshD3STD33D.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_SetCell, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetCell, None, itkMeshD3STD33D)
itkMeshD3STD33D.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_SetCellData, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetCellData, None, itkMeshD3STD33D)
itkMeshD3STD33D.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_SetBoundaryAssignment, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetBoundaryAssignment, None, itkMeshD3STD33D)
itkMeshD3STD33D.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_RemoveBoundaryAssignment, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetNumberOfCellBoundaryFeatures, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetCellBoundaryFeature, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetCellBoundaryFeatureNeighbors, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetCellNeighbors, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetAssignedCellBoundaryIfOneExists, None, itkMeshD3STD33D)
itkMeshD3STD33D.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_BuildCellLinks, None, itkMeshD3STD33D)
itkMeshD3STD33D.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_Accept, None, itkMeshD3STD33D)
itkMeshD3STD33D.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_SetCellsAllocationMethod, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetCellsAllocationMethod, None, itkMeshD3STD33D)
itkMeshD3STD33D.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33D_GetPointer, None, itkMeshD3STD33D)
itkMeshD3STD33D_swigregister = _itkMeshBasePython.itkMeshD3STD33D_swigregister
itkMeshD3STD33D_swigregister(itkMeshD3STD33D)

def itkMeshD3STD33D___New_orig__() -> "itkMeshD3STD33D_Pointer":
    """itkMeshD3STD33D___New_orig__() -> itkMeshD3STD33D_Pointer"""
    return _itkMeshBasePython.itkMeshD3STD33D___New_orig__()

def itkMeshD3STD33D_cast(obj: 'itkLightObject') -> "itkMeshD3STD33D *":
    """itkMeshD3STD33D_cast(itkLightObject obj) -> itkMeshD3STD33D"""
    return _itkMeshBasePython.itkMeshD3STD33D_cast(obj)

class itkMeshD3STD33DD(itkPointSetPython.itkPointSetD3STD33DD):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD3STD33DD_Pointer":
        """__New_orig__() -> itkMeshD3STD33DD_Pointer"""
        return _itkMeshBasePython.itkMeshD3STD33DD___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD3STD33DD_Pointer":
        """Clone(itkMeshD3STD33DD self) -> itkMeshD3STD33DD_Pointer"""
        return _itkMeshBasePython.itkMeshD3STD33DD_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshD3STD33DD_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshD3STD33DD_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshD3STD33DD_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshD3STD33DD_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD3STD33DD self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD3STD33DD') -> "void":
        """
        PassStructure(itkMeshD3STD33DD self, itkMeshD3STD33DD inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3DVCULPD3 const *":
        """
        GetBoundingBox(itkMeshD3STD33DD self) -> itkBoundingBoxUL3DVCULPD3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshD3STD33DD self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD3STD33DD_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshD3STD33DD self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshD3STD33DD self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3') -> "void":
        """
        SetCells(itkMeshD3STD33DD self, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 const *":
        """
        GetCells(itkMeshD3STD33DD self) -> itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3
        GetCells(itkMeshD3STD33DD self) -> itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "void":
        """
        SetCell(itkMeshD3STD33DD self, unsigned long arg0, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """GetCell(itkMeshD3STD33DD self, unsigned long arg0, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD3STD33DD_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD3STD33DD self, itkVectorContainerULD arg0)
        SetCellData(itkMeshD3STD33DD self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD3STD33DD self) -> itkVectorContainerULD
        GetCellData(itkMeshD3STD33DD self) -> itkVectorContainerULD
        GetCellData(itkMeshD3STD33DD self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD3STD33DD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD3STD33DD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD3STD33DD self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD3STD33DD_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD3STD33DD self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD3STD33DD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD3STD33DD self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD3STD33DD self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshD3STD33DD_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD3STD33DD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3DDULULULPD3VCULPD3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD3STD33DD self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD3STD33DD self, itkCellInterfaceDCTI3DDULULULPD3VCULPD3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshD3STD33DD::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD3STD33DD self, itkMeshD3STD33DD::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DD_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshD3STD33DD::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshD3STD33DD self) -> itkMeshD3STD33DD::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshD3STD33DD_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD3STD33DD

    def cast(obj: 'itkLightObject') -> "itkMeshD3STD33DD *":
        """cast(itkLightObject obj) -> itkMeshD3STD33DD"""
        return _itkMeshBasePython.itkMeshD3STD33DD_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshD3STD33DD *":
        """GetPointer(itkMeshD3STD33DD self) -> itkMeshD3STD33DD"""
        return _itkMeshBasePython.itkMeshD3STD33DD_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshD3STD33DD

        Create a new object of the class itkMeshD3STD33DD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD3STD33DD.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD3STD33DD.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD3STD33DD.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD3STD33DD.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_Clone, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetNumberOfCells, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_PassStructure, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetBoundingBox, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_SetCellLinks, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetCellLinks, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_SetCells, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetCells, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_SetCell, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetCell, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_SetCellData, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetCellData, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_SetBoundaryAssignment, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetBoundaryAssignment, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_RemoveBoundaryAssignment, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetNumberOfCellBoundaryFeatures, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetCellBoundaryFeature, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetCellBoundaryFeatureNeighbors, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetCellNeighbors, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetAssignedCellBoundaryIfOneExists, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_BuildCellLinks, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_Accept, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_SetCellsAllocationMethod, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetCellsAllocationMethod, None, itkMeshD3STD33DD)
itkMeshD3STD33DD.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DD_GetPointer, None, itkMeshD3STD33DD)
itkMeshD3STD33DD_swigregister = _itkMeshBasePython.itkMeshD3STD33DD_swigregister
itkMeshD3STD33DD_swigregister(itkMeshD3STD33DD)

def itkMeshD3STD33DD___New_orig__() -> "itkMeshD3STD33DD_Pointer":
    """itkMeshD3STD33DD___New_orig__() -> itkMeshD3STD33DD_Pointer"""
    return _itkMeshBasePython.itkMeshD3STD33DD___New_orig__()

def itkMeshD3STD33DD_cast(obj: 'itkLightObject') -> "itkMeshD3STD33DD *":
    """itkMeshD3STD33DD_cast(itkLightObject obj) -> itkMeshD3STD33DD"""
    return _itkMeshBasePython.itkMeshD3STD33DD_cast(obj)

class itkMeshD3STD33DFD(itkPointSetPython.itkPointSetD3STD33DFD):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshD3STD33D_Pointer":
        """__New_orig__() -> itkMeshD3STD33D_Pointer"""
        return _itkMeshBasePython.itkMeshD3STD33DFD___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshD3STD33D_Pointer":
        """Clone(itkMeshD3STD33DFD self) -> itkMeshD3STD33D_Pointer"""
        return _itkMeshBasePython.itkMeshD3STD33DFD_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshD3STD33DFD_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshD3STD33DFD_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshD3STD33DFD_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshD3STD33DFD_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshD3STD33DFD self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshD3STD33D') -> "void":
        """
        PassStructure(itkMeshD3STD33DFD self, itkMeshD3STD33D inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3DVCULPD3 const *":
        """
        GetBoundingBox(itkMeshD3STD33DFD self) -> itkBoundingBoxUL3DVCULPD3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshD3STD33DFD self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshD3STD33DFD self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshD3STD33DFD self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3') -> "void":
        """
        SetCells(itkMeshD3STD33DFD self, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 const *":
        """
        GetCells(itkMeshD3STD33DFD self) -> itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3
        GetCells(itkMeshD3STD33DFD self) -> itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "void":
        """
        SetCell(itkMeshD3STD33DFD self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """GetCell(itkMeshD3STD33DFD self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshD3STD33DFD self, itkVectorContainerULD arg0)
        SetCellData(itkMeshD3STD33DFD self, unsigned long arg0, double arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshD3STD33DFD self) -> itkVectorContainerULD
        GetCellData(itkMeshD3STD33DFD self) -> itkVectorContainerULD
        GetCellData(itkMeshD3STD33DFD self, unsigned long arg0, double * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshD3STD33DFD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshD3STD33DFD self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshD3STD33DFD self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshD3STD33DFD_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshD3STD33DFD self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshD3STD33DFD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshD3STD33DFD self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshD3STD33DFD self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshD3STD33DFD self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceDCTI3DFULULULPD3VCULPD3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshD3STD33DFD self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshD3STD33DFD self, itkCellInterfaceDCTI3DFULULULPD3VCULPD3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshD3STD33D::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshD3STD33DFD self, itkMeshD3STD33D::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshD3STD33DFD_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshD3STD33D::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshD3STD33DFD self) -> itkMeshD3STD33D::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshD3STD33DFD

    def cast(obj: 'itkLightObject') -> "itkMeshD3STD33DFD *":
        """cast(itkLightObject obj) -> itkMeshD3STD33DFD"""
        return _itkMeshBasePython.itkMeshD3STD33DFD_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshD3STD33DFD *":
        """GetPointer(itkMeshD3STD33DFD self) -> itkMeshD3STD33DFD"""
        return _itkMeshBasePython.itkMeshD3STD33DFD_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshD3STD33DFD

        Create a new object of the class itkMeshD3STD33DFD and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshD3STD33DFD.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshD3STD33DFD.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshD3STD33DFD.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshD3STD33DFD.Clone = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_Clone, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetNumberOfCells, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_PassStructure, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetBoundingBox, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_SetCellLinks, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetCellLinks, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_SetCells, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetCells, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_SetCell, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetCell, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_SetCellData, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetCellData, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_SetBoundaryAssignment, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetBoundaryAssignment, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_RemoveBoundaryAssignment, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetNumberOfCellBoundaryFeatures, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetCellBoundaryFeature, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetCellBoundaryFeatureNeighbors, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetCellNeighbors, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetAssignedCellBoundaryIfOneExists, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_BuildCellLinks, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.Accept = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_Accept, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_SetCellsAllocationMethod, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetCellsAllocationMethod, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshD3STD33DFD_GetPointer, None, itkMeshD3STD33DFD)
itkMeshD3STD33DFD_swigregister = _itkMeshBasePython.itkMeshD3STD33DFD_swigregister
itkMeshD3STD33DFD_swigregister(itkMeshD3STD33DFD)

def itkMeshD3STD33DFD___New_orig__() -> "itkMeshD3STD33D_Pointer":
    """itkMeshD3STD33DFD___New_orig__() -> itkMeshD3STD33D_Pointer"""
    return _itkMeshBasePython.itkMeshD3STD33DFD___New_orig__()

def itkMeshD3STD33DFD_cast(obj: 'itkLightObject') -> "itkMeshD3STD33DFD *":
    """itkMeshD3STD33DFD_cast(itkLightObject obj) -> itkMeshD3STD33DFD"""
    return _itkMeshBasePython.itkMeshD3STD33DFD_cast(obj)

class itkMeshF2DTF22F(itkPointSetPython.itkPointSetF2DTF22FF):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshF2DTF22FF_Pointer":
        """__New_orig__() -> itkMeshF2DTF22FF_Pointer"""
        return _itkMeshBasePython.itkMeshF2DTF22F___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshF2DTF22FF_Pointer":
        """Clone(itkMeshF2DTF22F self) -> itkMeshF2DTF22FF_Pointer"""
        return _itkMeshBasePython.itkMeshF2DTF22F_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshF2DTF22F_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshF2DTF22F_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshF2DTF22F_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshF2DTF22F_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshF2DTF22F self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshF2DTF22FF') -> "void":
        """
        PassStructure(itkMeshF2DTF22F self, itkMeshF2DTF22FF inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2FMCULPF2 const *":
        """
        GetBoundingBox(itkMeshF2DTF22F self) -> itkBoundingBoxUL2FMCULPF2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkMapContainerULSIT') -> "void":
        """
        SetCellLinks(itkMeshF2DTF22F self, itkMapContainerULSIT arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshF2DTF22F_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkMapContainerULSIT const *":
        """
        GetCellLinks(itkMeshF2DTF22F self) -> itkMapContainerULSIT
        GetCellLinks(itkMeshF2DTF22F self) -> itkMapContainerULSIT
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkMapContainerULCIFCTI2FFULULULPF2MCULPF2') -> "void":
        """
        SetCells(itkMeshF2DTF22F self, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 const *":
        """
        GetCells(itkMeshF2DTF22F self) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2
        GetCells(itkMeshF2DTF22F self) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        SetCell(itkMeshF2DTF22F self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """GetCell(itkMeshF2DTF22F self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshF2DTF22F_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshF2DTF22F self, itkMapContainerULF arg0)
        SetCellData(itkMeshF2DTF22F self, unsigned long arg0, float arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshF2DTF22F self) -> itkMapContainerULF
        GetCellData(itkMeshF2DTF22F self) -> itkMapContainerULF
        GetCellData(itkMeshF2DTF22F self, unsigned long arg0, float * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshF2DTF22F self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshF2DTF22F self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshF2DTF22F self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshF2DTF22F_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshF2DTF22F self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshF2DTF22F self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshF2DTF22F self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshF2DTF22F self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshF2DTF22F_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshF2DTF22F self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshF2DTF22F self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshF2DTF22F self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshF2DTF22FF::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshF2DTF22F self, itkMeshF2DTF22FF::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22F_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshF2DTF22FF::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshF2DTF22F self) -> itkMeshF2DTF22FF::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshF2DTF22F_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshF2DTF22F

    def cast(obj: 'itkLightObject') -> "itkMeshF2DTF22F *":
        """cast(itkLightObject obj) -> itkMeshF2DTF22F"""
        return _itkMeshBasePython.itkMeshF2DTF22F_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshF2DTF22F *":
        """GetPointer(itkMeshF2DTF22F self) -> itkMeshF2DTF22F"""
        return _itkMeshBasePython.itkMeshF2DTF22F_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshF2DTF22F

        Create a new object of the class itkMeshF2DTF22F and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshF2DTF22F.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshF2DTF22F.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshF2DTF22F.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshF2DTF22F.Clone = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_Clone, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetNumberOfCells, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_PassStructure, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetBoundingBox, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_SetCellLinks, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetCellLinks, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_SetCells, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetCells, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_SetCell, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetCell, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_SetCellData, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetCellData, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_SetBoundaryAssignment, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetBoundaryAssignment, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_RemoveBoundaryAssignment, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetNumberOfCellBoundaryFeatures, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetCellBoundaryFeature, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetCellBoundaryFeatureNeighbors, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetCellNeighbors, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetAssignedCellBoundaryIfOneExists, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_BuildCellLinks, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.Accept = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_Accept, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_SetCellsAllocationMethod, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetCellsAllocationMethod, None, itkMeshF2DTF22F)
itkMeshF2DTF22F.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22F_GetPointer, None, itkMeshF2DTF22F)
itkMeshF2DTF22F_swigregister = _itkMeshBasePython.itkMeshF2DTF22F_swigregister
itkMeshF2DTF22F_swigregister(itkMeshF2DTF22F)

def itkMeshF2DTF22F___New_orig__() -> "itkMeshF2DTF22FF_Pointer":
    """itkMeshF2DTF22F___New_orig__() -> itkMeshF2DTF22FF_Pointer"""
    return _itkMeshBasePython.itkMeshF2DTF22F___New_orig__()

def itkMeshF2DTF22F_cast(obj: 'itkLightObject') -> "itkMeshF2DTF22F *":
    """itkMeshF2DTF22F_cast(itkLightObject obj) -> itkMeshF2DTF22F"""
    return _itkMeshBasePython.itkMeshF2DTF22F_cast(obj)

class itkMeshF2DTF22FF(itkPointSetPython.itkPointSetF2DTF22FF):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshF2DTF22FF_Pointer":
        """__New_orig__() -> itkMeshF2DTF22FF_Pointer"""
        return _itkMeshBasePython.itkMeshF2DTF22FF___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshF2DTF22FF_Pointer":
        """Clone(itkMeshF2DTF22FF self) -> itkMeshF2DTF22FF_Pointer"""
        return _itkMeshBasePython.itkMeshF2DTF22FF_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshF2DTF22FF_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshF2DTF22FF_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshF2DTF22FF_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshF2DTF22FF_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshF2DTF22FF self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshF2DTF22FF') -> "void":
        """
        PassStructure(itkMeshF2DTF22FF self, itkMeshF2DTF22FF inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2FMCULPF2 const *":
        """
        GetBoundingBox(itkMeshF2DTF22FF self) -> itkBoundingBoxUL2FMCULPF2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkMapContainerULSIT') -> "void":
        """
        SetCellLinks(itkMeshF2DTF22FF self, itkMapContainerULSIT arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkMapContainerULSIT const *":
        """
        GetCellLinks(itkMeshF2DTF22FF self) -> itkMapContainerULSIT
        GetCellLinks(itkMeshF2DTF22FF self) -> itkMapContainerULSIT
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkMapContainerULCIFCTI2FFULULULPF2MCULPF2') -> "void":
        """
        SetCells(itkMeshF2DTF22FF self, itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkMapContainerULCIFCTI2FFULULULPF2MCULPF2 const *":
        """
        GetCells(itkMeshF2DTF22FF self) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2
        GetCells(itkMeshF2DTF22FF self) -> itkMapContainerULCIFCTI2FFULULULPF2MCULPF2
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "void":
        """
        SetCell(itkMeshF2DTF22FF self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """GetCell(itkMeshF2DTF22FF self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshF2DTF22FF self, itkMapContainerULF arg0)
        SetCellData(itkMeshF2DTF22FF self, unsigned long arg0, float arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshF2DTF22FF self) -> itkMapContainerULF
        GetCellData(itkMeshF2DTF22FF self) -> itkMapContainerULF
        GetCellData(itkMeshF2DTF22FF self, unsigned long arg0, float * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshF2DTF22FF self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshF2DTF22FF self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshF2DTF22FF self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshF2DTF22FF_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshF2DTF22FF self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshF2DTF22FF self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshF2DTF22FF self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshF2DTF22FF self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshF2DTF22FF self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI2FFULULULPF2MCULPF2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshF2DTF22FF self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceFCTI2FFULULULPF2MCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshF2DTF22FF self, itkCellInterfaceFCTI2FFULULULPF2MCULPF2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshF2DTF22FF::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshF2DTF22FF self, itkMeshF2DTF22FF::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshF2DTF22FF_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshF2DTF22FF::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshF2DTF22FF self) -> itkMeshF2DTF22FF::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshF2DTF22FF

    def cast(obj: 'itkLightObject') -> "itkMeshF2DTF22FF *":
        """cast(itkLightObject obj) -> itkMeshF2DTF22FF"""
        return _itkMeshBasePython.itkMeshF2DTF22FF_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshF2DTF22FF *":
        """GetPointer(itkMeshF2DTF22FF self) -> itkMeshF2DTF22FF"""
        return _itkMeshBasePython.itkMeshF2DTF22FF_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshF2DTF22FF

        Create a new object of the class itkMeshF2DTF22FF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshF2DTF22FF.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshF2DTF22FF.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshF2DTF22FF.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshF2DTF22FF.Clone = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_Clone, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetNumberOfCells, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_PassStructure, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetBoundingBox, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_SetCellLinks, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetCellLinks, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_SetCells, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetCells, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_SetCell, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetCell, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_SetCellData, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetCellData, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_SetBoundaryAssignment, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetBoundaryAssignment, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_RemoveBoundaryAssignment, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetNumberOfCellBoundaryFeatures, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetCellBoundaryFeature, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetCellBoundaryFeatureNeighbors, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetCellNeighbors, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetAssignedCellBoundaryIfOneExists, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_BuildCellLinks, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.Accept = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_Accept, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_SetCellsAllocationMethod, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetCellsAllocationMethod, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshF2DTF22FF_GetPointer, None, itkMeshF2DTF22FF)
itkMeshF2DTF22FF_swigregister = _itkMeshBasePython.itkMeshF2DTF22FF_swigregister
itkMeshF2DTF22FF_swigregister(itkMeshF2DTF22FF)

def itkMeshF2DTF22FF___New_orig__() -> "itkMeshF2DTF22FF_Pointer":
    """itkMeshF2DTF22FF___New_orig__() -> itkMeshF2DTF22FF_Pointer"""
    return _itkMeshBasePython.itkMeshF2DTF22FF___New_orig__()

def itkMeshF2DTF22FF_cast(obj: 'itkLightObject') -> "itkMeshF2DTF22FF *":
    """itkMeshF2DTF22FF_cast(itkLightObject obj) -> itkMeshF2DTF22FF"""
    return _itkMeshBasePython.itkMeshF2DTF22FF_cast(obj)

class itkMeshF2STF22F(itkPointSetPython.itkPointSetF2STF22):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshF2STF22FF_Pointer":
        """__New_orig__() -> itkMeshF2STF22FF_Pointer"""
        return _itkMeshBasePython.itkMeshF2STF22F___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshF2STF22FF_Pointer":
        """Clone(itkMeshF2STF22F self) -> itkMeshF2STF22FF_Pointer"""
        return _itkMeshBasePython.itkMeshF2STF22F_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshF2STF22F_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshF2STF22F_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshF2STF22F_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshF2STF22F_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshF2STF22F self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshF2STF22FF') -> "void":
        """
        PassStructure(itkMeshF2STF22F self, itkMeshF2STF22FF inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2FVCULPF2 const *":
        """
        GetBoundingBox(itkMeshF2STF22F self) -> itkBoundingBoxUL2FVCULPF2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshF2STF22F self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshF2STF22F_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshF2STF22F self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshF2STF22F self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshF2STF22F_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetCells(itkMeshF2STF22F self, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 const *":
        """
        GetCells(itkMeshF2STF22F self) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2
        GetCells(itkMeshF2STF22F self) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2
        """
        return _itkMeshBasePython.itkMeshF2STF22F_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        SetCell(itkMeshF2STF22F self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """GetCell(itkMeshF2STF22F self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshF2STF22F_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshF2STF22F self, itkVectorContainerULF arg0)
        SetCellData(itkMeshF2STF22F self, unsigned long arg0, float arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshF2STF22F self) -> itkVectorContainerULF
        GetCellData(itkMeshF2STF22F self) -> itkVectorContainerULF
        GetCellData(itkMeshF2STF22F self, unsigned long arg0, float * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshF2STF22F_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshF2STF22F self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshF2STF22F self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshF2STF22F self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshF2STF22F_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshF2STF22F self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshF2STF22F self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshF2STF22F self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshF2STF22F self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshF2STF22F_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshF2STF22F self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshF2STF22F self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshF2STF22F self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshF2STF22FF::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshF2STF22F self, itkMeshF2STF22FF::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshF2STF22F_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshF2STF22FF::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshF2STF22F self) -> itkMeshF2STF22FF::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshF2STF22F_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshF2STF22F

    def cast(obj: 'itkLightObject') -> "itkMeshF2STF22F *":
        """cast(itkLightObject obj) -> itkMeshF2STF22F"""
        return _itkMeshBasePython.itkMeshF2STF22F_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshF2STF22F *":
        """GetPointer(itkMeshF2STF22F self) -> itkMeshF2STF22F"""
        return _itkMeshBasePython.itkMeshF2STF22F_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshF2STF22F

        Create a new object of the class itkMeshF2STF22F and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshF2STF22F.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshF2STF22F.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshF2STF22F.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshF2STF22F.Clone = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_Clone, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetNumberOfCells, None, itkMeshF2STF22F)
itkMeshF2STF22F.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_PassStructure, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetBoundingBox, None, itkMeshF2STF22F)
itkMeshF2STF22F.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_SetCellLinks, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetCellLinks, None, itkMeshF2STF22F)
itkMeshF2STF22F.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_SetCells, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetCells, None, itkMeshF2STF22F)
itkMeshF2STF22F.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_SetCell, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetCell, None, itkMeshF2STF22F)
itkMeshF2STF22F.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_SetCellData, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetCellData, None, itkMeshF2STF22F)
itkMeshF2STF22F.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_SetBoundaryAssignment, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetBoundaryAssignment, None, itkMeshF2STF22F)
itkMeshF2STF22F.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_RemoveBoundaryAssignment, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetNumberOfCellBoundaryFeatures, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetCellBoundaryFeature, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetCellBoundaryFeatureNeighbors, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetCellNeighbors, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetAssignedCellBoundaryIfOneExists, None, itkMeshF2STF22F)
itkMeshF2STF22F.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_BuildCellLinks, None, itkMeshF2STF22F)
itkMeshF2STF22F.Accept = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_Accept, None, itkMeshF2STF22F)
itkMeshF2STF22F.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_SetCellsAllocationMethod, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetCellsAllocationMethod, None, itkMeshF2STF22F)
itkMeshF2STF22F.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22F_GetPointer, None, itkMeshF2STF22F)
itkMeshF2STF22F_swigregister = _itkMeshBasePython.itkMeshF2STF22F_swigregister
itkMeshF2STF22F_swigregister(itkMeshF2STF22F)

def itkMeshF2STF22F___New_orig__() -> "itkMeshF2STF22FF_Pointer":
    """itkMeshF2STF22F___New_orig__() -> itkMeshF2STF22FF_Pointer"""
    return _itkMeshBasePython.itkMeshF2STF22F___New_orig__()

def itkMeshF2STF22F_cast(obj: 'itkLightObject') -> "itkMeshF2STF22F *":
    """itkMeshF2STF22F_cast(itkLightObject obj) -> itkMeshF2STF22F"""
    return _itkMeshBasePython.itkMeshF2STF22F_cast(obj)

class itkMeshF2STF22FF(itkPointSetPython.itkPointSetF2STF22):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshF2STF22FF_Pointer":
        """__New_orig__() -> itkMeshF2STF22FF_Pointer"""
        return _itkMeshBasePython.itkMeshF2STF22FF___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshF2STF22FF_Pointer":
        """Clone(itkMeshF2STF22FF self) -> itkMeshF2STF22FF_Pointer"""
        return _itkMeshBasePython.itkMeshF2STF22FF_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshF2STF22FF_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshF2STF22FF_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshF2STF22FF_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshF2STF22FF_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshF2STF22FF self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshF2STF22FF') -> "void":
        """
        PassStructure(itkMeshF2STF22FF self, itkMeshF2STF22FF inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL2FVCULPF2 const *":
        """
        GetBoundingBox(itkMeshF2STF22FF self) -> itkBoundingBoxUL2FVCULPF2

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshF2STF22FF self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshF2STF22FF_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshF2STF22FF self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshF2STF22FF self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetCells(itkMeshF2STF22FF self, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 const *":
        """
        GetCells(itkMeshF2STF22FF self) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2
        GetCells(itkMeshF2STF22FF self) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "void":
        """
        SetCell(itkMeshF2STF22FF self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """GetCell(itkMeshF2STF22FF self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshF2STF22FF_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshF2STF22FF self, itkVectorContainerULF arg0)
        SetCellData(itkMeshF2STF22FF self, unsigned long arg0, float arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshF2STF22FF self) -> itkVectorContainerULF
        GetCellData(itkMeshF2STF22FF self) -> itkVectorContainerULF
        GetCellData(itkMeshF2STF22FF self, unsigned long arg0, float * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshF2STF22FF self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshF2STF22FF self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshF2STF22FF self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshF2STF22FF_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshF2STF22FF self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshF2STF22FF self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshF2STF22FF self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshF2STF22FF self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshF2STF22FF_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshF2STF22FF self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI2FFULULULPF2VCULPF2_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshF2STF22FF self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor *') -> "void":
        """
        Accept(itkMeshF2STF22FF self, itkCellInterfaceFCTI2FFULULULPF2VCULPF2::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshF2STF22FF::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshF2STF22FF self, itkMeshF2STF22FF::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshF2STF22FF_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshF2STF22FF::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshF2STF22FF self) -> itkMeshF2STF22FF::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshF2STF22FF_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshF2STF22FF

    def cast(obj: 'itkLightObject') -> "itkMeshF2STF22FF *":
        """cast(itkLightObject obj) -> itkMeshF2STF22FF"""
        return _itkMeshBasePython.itkMeshF2STF22FF_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshF2STF22FF *":
        """GetPointer(itkMeshF2STF22FF self) -> itkMeshF2STF22FF"""
        return _itkMeshBasePython.itkMeshF2STF22FF_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshF2STF22FF

        Create a new object of the class itkMeshF2STF22FF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshF2STF22FF.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshF2STF22FF.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshF2STF22FF.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshF2STF22FF.Clone = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_Clone, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetNumberOfCells, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_PassStructure, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetBoundingBox, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_SetCellLinks, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetCellLinks, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_SetCells, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetCells, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_SetCell, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetCell, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_SetCellData, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetCellData, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_SetBoundaryAssignment, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetBoundaryAssignment, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_RemoveBoundaryAssignment, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetNumberOfCellBoundaryFeatures, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetCellBoundaryFeature, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetCellBoundaryFeatureNeighbors, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetCellNeighbors, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetAssignedCellBoundaryIfOneExists, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_BuildCellLinks, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.Accept = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_Accept, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_SetCellsAllocationMethod, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetCellsAllocationMethod, None, itkMeshF2STF22FF)
itkMeshF2STF22FF.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshF2STF22FF_GetPointer, None, itkMeshF2STF22FF)
itkMeshF2STF22FF_swigregister = _itkMeshBasePython.itkMeshF2STF22FF_swigregister
itkMeshF2STF22FF_swigregister(itkMeshF2STF22FF)

def itkMeshF2STF22FF___New_orig__() -> "itkMeshF2STF22FF_Pointer":
    """itkMeshF2STF22FF___New_orig__() -> itkMeshF2STF22FF_Pointer"""
    return _itkMeshBasePython.itkMeshF2STF22FF___New_orig__()

def itkMeshF2STF22FF_cast(obj: 'itkLightObject') -> "itkMeshF2STF22FF *":
    """itkMeshF2STF22FF_cast(itkLightObject obj) -> itkMeshF2STF22FF"""
    return _itkMeshBasePython.itkMeshF2STF22FF_cast(obj)

class itkMeshF3DTF33F(itkPointSetPython.itkPointSetF3DTF33FF):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshF3DTF33FF_Pointer":
        """__New_orig__() -> itkMeshF3DTF33FF_Pointer"""
        return _itkMeshBasePython.itkMeshF3DTF33F___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshF3DTF33FF_Pointer":
        """Clone(itkMeshF3DTF33F self) -> itkMeshF3DTF33FF_Pointer"""
        return _itkMeshBasePython.itkMeshF3DTF33F_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshF3DTF33F_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshF3DTF33F_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshF3DTF33F_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshF3DTF33F_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshF3DTF33F self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshF3DTF33FF') -> "void":
        """
        PassStructure(itkMeshF3DTF33F self, itkMeshF3DTF33FF inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3FMCULPF3 const *":
        """
        GetBoundingBox(itkMeshF3DTF33F self) -> itkBoundingBoxUL3FMCULPF3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkMapContainerULSIT') -> "void":
        """
        SetCellLinks(itkMeshF3DTF33F self, itkMapContainerULSIT arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshF3DTF33F_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkMapContainerULSIT const *":
        """
        GetCellLinks(itkMeshF3DTF33F self) -> itkMapContainerULSIT
        GetCellLinks(itkMeshF3DTF33F self) -> itkMapContainerULSIT
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkMapContainerULCIFCTI3FFULULULPF3MCULPF3') -> "void":
        """
        SetCells(itkMeshF3DTF33F self, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 const *":
        """
        GetCells(itkMeshF3DTF33F self) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3
        GetCells(itkMeshF3DTF33F self) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        SetCell(itkMeshF3DTF33F self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """GetCell(itkMeshF3DTF33F self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshF3DTF33F_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshF3DTF33F self, itkMapContainerULF arg0)
        SetCellData(itkMeshF3DTF33F self, unsigned long arg0, float arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshF3DTF33F self) -> itkMapContainerULF
        GetCellData(itkMeshF3DTF33F self) -> itkMapContainerULF
        GetCellData(itkMeshF3DTF33F self, unsigned long arg0, float * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshF3DTF33F self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshF3DTF33F self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshF3DTF33F self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshF3DTF33F_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshF3DTF33F self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshF3DTF33F self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshF3DTF33F self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshF3DTF33F self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshF3DTF33F_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshF3DTF33F self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshF3DTF33F self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshF3DTF33F self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshF3DTF33FF::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshF3DTF33F self, itkMeshF3DTF33FF::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33F_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshF3DTF33FF::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshF3DTF33F self) -> itkMeshF3DTF33FF::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshF3DTF33F_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshF3DTF33F

    def cast(obj: 'itkLightObject') -> "itkMeshF3DTF33F *":
        """cast(itkLightObject obj) -> itkMeshF3DTF33F"""
        return _itkMeshBasePython.itkMeshF3DTF33F_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshF3DTF33F *":
        """GetPointer(itkMeshF3DTF33F self) -> itkMeshF3DTF33F"""
        return _itkMeshBasePython.itkMeshF3DTF33F_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshF3DTF33F

        Create a new object of the class itkMeshF3DTF33F and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshF3DTF33F.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshF3DTF33F.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshF3DTF33F.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshF3DTF33F.Clone = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_Clone, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetNumberOfCells, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_PassStructure, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetBoundingBox, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_SetCellLinks, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetCellLinks, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_SetCells, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetCells, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_SetCell, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetCell, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_SetCellData, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetCellData, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_SetBoundaryAssignment, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetBoundaryAssignment, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_RemoveBoundaryAssignment, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetNumberOfCellBoundaryFeatures, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetCellBoundaryFeature, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetCellBoundaryFeatureNeighbors, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetCellNeighbors, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetAssignedCellBoundaryIfOneExists, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_BuildCellLinks, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.Accept = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_Accept, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_SetCellsAllocationMethod, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetCellsAllocationMethod, None, itkMeshF3DTF33F)
itkMeshF3DTF33F.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33F_GetPointer, None, itkMeshF3DTF33F)
itkMeshF3DTF33F_swigregister = _itkMeshBasePython.itkMeshF3DTF33F_swigregister
itkMeshF3DTF33F_swigregister(itkMeshF3DTF33F)

def itkMeshF3DTF33F___New_orig__() -> "itkMeshF3DTF33FF_Pointer":
    """itkMeshF3DTF33F___New_orig__() -> itkMeshF3DTF33FF_Pointer"""
    return _itkMeshBasePython.itkMeshF3DTF33F___New_orig__()

def itkMeshF3DTF33F_cast(obj: 'itkLightObject') -> "itkMeshF3DTF33F *":
    """itkMeshF3DTF33F_cast(itkLightObject obj) -> itkMeshF3DTF33F"""
    return _itkMeshBasePython.itkMeshF3DTF33F_cast(obj)

class itkMeshF3DTF33FF(itkPointSetPython.itkPointSetF3DTF33FF):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshF3DTF33FF_Pointer":
        """__New_orig__() -> itkMeshF3DTF33FF_Pointer"""
        return _itkMeshBasePython.itkMeshF3DTF33FF___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshF3DTF33FF_Pointer":
        """Clone(itkMeshF3DTF33FF self) -> itkMeshF3DTF33FF_Pointer"""
        return _itkMeshBasePython.itkMeshF3DTF33FF_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshF3DTF33FF_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshF3DTF33FF_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshF3DTF33FF_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshF3DTF33FF_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshF3DTF33FF self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshF3DTF33FF') -> "void":
        """
        PassStructure(itkMeshF3DTF33FF self, itkMeshF3DTF33FF inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3FMCULPF3 const *":
        """
        GetBoundingBox(itkMeshF3DTF33FF self) -> itkBoundingBoxUL3FMCULPF3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkMapContainerULSIT') -> "void":
        """
        SetCellLinks(itkMeshF3DTF33FF self, itkMapContainerULSIT arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkMapContainerULSIT const *":
        """
        GetCellLinks(itkMeshF3DTF33FF self) -> itkMapContainerULSIT
        GetCellLinks(itkMeshF3DTF33FF self) -> itkMapContainerULSIT
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkMapContainerULCIFCTI3FFULULULPF3MCULPF3') -> "void":
        """
        SetCells(itkMeshF3DTF33FF self, itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkMapContainerULCIFCTI3FFULULULPF3MCULPF3 const *":
        """
        GetCells(itkMeshF3DTF33FF self) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3
        GetCells(itkMeshF3DTF33FF self) -> itkMapContainerULCIFCTI3FFULULULPF3MCULPF3
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "void":
        """
        SetCell(itkMeshF3DTF33FF self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """GetCell(itkMeshF3DTF33FF self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshF3DTF33FF self, itkMapContainerULF arg0)
        SetCellData(itkMeshF3DTF33FF self, unsigned long arg0, float arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshF3DTF33FF self) -> itkMapContainerULF
        GetCellData(itkMeshF3DTF33FF self) -> itkMapContainerULF
        GetCellData(itkMeshF3DTF33FF self, unsigned long arg0, float * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshF3DTF33FF self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshF3DTF33FF self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshF3DTF33FF self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshF3DTF33FF_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshF3DTF33FF self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshF3DTF33FF self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshF3DTF33FF self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshF3DTF33FF self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshF3DTF33FF self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI3FFULULULPF3MCULPF3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshF3DTF33FF self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceFCTI3FFULULULPF3MCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshF3DTF33FF self, itkCellInterfaceFCTI3FFULULULPF3MCULPF3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshF3DTF33FF::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshF3DTF33FF self, itkMeshF3DTF33FF::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshF3DTF33FF_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshF3DTF33FF::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshF3DTF33FF self) -> itkMeshF3DTF33FF::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshF3DTF33FF

    def cast(obj: 'itkLightObject') -> "itkMeshF3DTF33FF *":
        """cast(itkLightObject obj) -> itkMeshF3DTF33FF"""
        return _itkMeshBasePython.itkMeshF3DTF33FF_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshF3DTF33FF *":
        """GetPointer(itkMeshF3DTF33FF self) -> itkMeshF3DTF33FF"""
        return _itkMeshBasePython.itkMeshF3DTF33FF_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshF3DTF33FF

        Create a new object of the class itkMeshF3DTF33FF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshF3DTF33FF.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshF3DTF33FF.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshF3DTF33FF.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshF3DTF33FF.Clone = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_Clone, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetNumberOfCells, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_PassStructure, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetBoundingBox, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_SetCellLinks, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetCellLinks, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_SetCells, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetCells, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_SetCell, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetCell, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_SetCellData, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetCellData, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_SetBoundaryAssignment, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetBoundaryAssignment, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_RemoveBoundaryAssignment, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetNumberOfCellBoundaryFeatures, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetCellBoundaryFeature, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetCellBoundaryFeatureNeighbors, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetCellNeighbors, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetAssignedCellBoundaryIfOneExists, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_BuildCellLinks, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.Accept = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_Accept, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_SetCellsAllocationMethod, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetCellsAllocationMethod, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshF3DTF33FF_GetPointer, None, itkMeshF3DTF33FF)
itkMeshF3DTF33FF_swigregister = _itkMeshBasePython.itkMeshF3DTF33FF_swigregister
itkMeshF3DTF33FF_swigregister(itkMeshF3DTF33FF)

def itkMeshF3DTF33FF___New_orig__() -> "itkMeshF3DTF33FF_Pointer":
    """itkMeshF3DTF33FF___New_orig__() -> itkMeshF3DTF33FF_Pointer"""
    return _itkMeshBasePython.itkMeshF3DTF33FF___New_orig__()

def itkMeshF3DTF33FF_cast(obj: 'itkLightObject') -> "itkMeshF3DTF33FF *":
    """itkMeshF3DTF33FF_cast(itkLightObject obj) -> itkMeshF3DTF33FF"""
    return _itkMeshBasePython.itkMeshF3DTF33FF_cast(obj)

class itkMeshF3STF33F(itkPointSetPython.itkPointSetF3STF33):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshF3STF33FF_Pointer":
        """__New_orig__() -> itkMeshF3STF33FF_Pointer"""
        return _itkMeshBasePython.itkMeshF3STF33F___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshF3STF33FF_Pointer":
        """Clone(itkMeshF3STF33F self) -> itkMeshF3STF33FF_Pointer"""
        return _itkMeshBasePython.itkMeshF3STF33F_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshF3STF33F_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshF3STF33F_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshF3STF33F_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshF3STF33F_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshF3STF33F self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshF3STF33FF') -> "void":
        """
        PassStructure(itkMeshF3STF33F self, itkMeshF3STF33FF inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3FVCULPF3 const *":
        """
        GetBoundingBox(itkMeshF3STF33F self) -> itkBoundingBoxUL3FVCULPF3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshF3STF33F self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshF3STF33F_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshF3STF33F self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshF3STF33F self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshF3STF33F_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetCells(itkMeshF3STF33F self, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 const *":
        """
        GetCells(itkMeshF3STF33F self) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3
        GetCells(itkMeshF3STF33F self) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3
        """
        return _itkMeshBasePython.itkMeshF3STF33F_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        SetCell(itkMeshF3STF33F self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """GetCell(itkMeshF3STF33F self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshF3STF33F_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshF3STF33F self, itkVectorContainerULF arg0)
        SetCellData(itkMeshF3STF33F self, unsigned long arg0, float arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshF3STF33F self) -> itkVectorContainerULF
        GetCellData(itkMeshF3STF33F self) -> itkVectorContainerULF
        GetCellData(itkMeshF3STF33F self, unsigned long arg0, float * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshF3STF33F_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshF3STF33F self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshF3STF33F self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshF3STF33F self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshF3STF33F_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshF3STF33F self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshF3STF33F self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshF3STF33F self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshF3STF33F self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshF3STF33F_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshF3STF33F self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshF3STF33F self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshF3STF33F self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshF3STF33FF::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshF3STF33F self, itkMeshF3STF33FF::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshF3STF33F_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshF3STF33FF::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshF3STF33F self) -> itkMeshF3STF33FF::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshF3STF33F_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshF3STF33F

    def cast(obj: 'itkLightObject') -> "itkMeshF3STF33F *":
        """cast(itkLightObject obj) -> itkMeshF3STF33F"""
        return _itkMeshBasePython.itkMeshF3STF33F_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshF3STF33F *":
        """GetPointer(itkMeshF3STF33F self) -> itkMeshF3STF33F"""
        return _itkMeshBasePython.itkMeshF3STF33F_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshF3STF33F

        Create a new object of the class itkMeshF3STF33F and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshF3STF33F.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshF3STF33F.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshF3STF33F.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshF3STF33F.Clone = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_Clone, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetNumberOfCells, None, itkMeshF3STF33F)
itkMeshF3STF33F.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_PassStructure, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetBoundingBox, None, itkMeshF3STF33F)
itkMeshF3STF33F.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_SetCellLinks, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetCellLinks, None, itkMeshF3STF33F)
itkMeshF3STF33F.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_SetCells, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetCells, None, itkMeshF3STF33F)
itkMeshF3STF33F.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_SetCell, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetCell, None, itkMeshF3STF33F)
itkMeshF3STF33F.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_SetCellData, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetCellData, None, itkMeshF3STF33F)
itkMeshF3STF33F.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_SetBoundaryAssignment, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetBoundaryAssignment, None, itkMeshF3STF33F)
itkMeshF3STF33F.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_RemoveBoundaryAssignment, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetNumberOfCellBoundaryFeatures, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetCellBoundaryFeature, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetCellBoundaryFeatureNeighbors, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetCellNeighbors, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetAssignedCellBoundaryIfOneExists, None, itkMeshF3STF33F)
itkMeshF3STF33F.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_BuildCellLinks, None, itkMeshF3STF33F)
itkMeshF3STF33F.Accept = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_Accept, None, itkMeshF3STF33F)
itkMeshF3STF33F.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_SetCellsAllocationMethod, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetCellsAllocationMethod, None, itkMeshF3STF33F)
itkMeshF3STF33F.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33F_GetPointer, None, itkMeshF3STF33F)
itkMeshF3STF33F_swigregister = _itkMeshBasePython.itkMeshF3STF33F_swigregister
itkMeshF3STF33F_swigregister(itkMeshF3STF33F)

def itkMeshF3STF33F___New_orig__() -> "itkMeshF3STF33FF_Pointer":
    """itkMeshF3STF33F___New_orig__() -> itkMeshF3STF33FF_Pointer"""
    return _itkMeshBasePython.itkMeshF3STF33F___New_orig__()

def itkMeshF3STF33F_cast(obj: 'itkLightObject') -> "itkMeshF3STF33F *":
    """itkMeshF3STF33F_cast(itkLightObject obj) -> itkMeshF3STF33F"""
    return _itkMeshBasePython.itkMeshF3STF33F_cast(obj)

class itkMeshF3STF33FF(itkPointSetPython.itkPointSetF3STF33):
    """


    Implements the N-dimensional mesh structure.

    Overview  Mesh implements the N-dimensional mesh structure for ITK. It
    provides an API to perform operations on points, cells, boundaries,
    etc., but does not tie down the underlying implementation and storage.
    A "MeshTraits" structure is used to define the container and
    identifier types that will be used to access the mesh. See
    DefaultStaticMeshTraits for the set of type definitions needed. All
    types that are defined in the "MeshTraits" structure will have
    duplicate typedefs in the resulting mesh itself.  Mesh is an adaptive,
    evolving structure. Typically points and cells are created, with the
    cells referring to their defining points. If additional topological
    information is required, then BuildCellLinks() is called and links
    from the points back to the cells that use them are created. This
    allows implicit topological information about the faces to a cell can
    be determined by intersection the sets of cells that use the points
    defining the face. This is an inherent assumption on the manifold
    relationship of the cells in the mesh.) In some cases, either because
    the mesh is non-manifold, because we wish to explicitly store
    information with the faces and edges of the mesh, or because
    performance requirements demand that boundaries are explicitly
    represented (the set intersection does not need to be performed); then
    Mesh can be further extended by adding explicit boundary assignments.

    Usage  Mesh has three template parameters. The first is the pixel
    type, or the type of data stored (optionally) with points, cells,
    and/or boundaries. The second is the geometric dimension of the points
    defining the mesh. This also limits the maximum topological dimension
    of the cells that can be inserted. The third template parameter is the
    "MeshTraits" structure controlling type information for the mesh.
    Most users will be happy with the defaults, and will not have to worry
    about this third argument.  One of the most important parts of using
    this mesh is how to create cells to insert into it. The cells for the
    mesh take two template parameters. The first is the pixel type, and
    should correspond exactly to that type given to the mesh. The second
    is a "CellTraits" which holds a sub-set of the "MeshTraits"
    structure definitions, and is also a member of them. Any cell which is
    to be inserted to a mesh should have MeshTraits::CellTraits as its
    second template parameter.

    Template parameters for Mesh:

    TPixelType = The type stored as data for an entity (cell, point, or
    boundary).

    TMeshTraits = Type information structure for the mesh.

    References No reference information is available.

    C++ includes: itkMesh.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkMeshF3STF33FF_Pointer":
        """__New_orig__() -> itkMeshF3STF33FF_Pointer"""
        return _itkMeshBasePython.itkMeshF3STF33FF___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkMeshF3STF33FF_Pointer":
        """Clone(itkMeshF3STF33FF self) -> itkMeshF3STF33FF_Pointer"""
        return _itkMeshBasePython.itkMeshF3STF33FF_Clone(self)

    CellsAllocationMethodUndefined = _itkMeshBasePython.itkMeshF3STF33FF_CellsAllocationMethodUndefined
    CellsAllocatedAsStaticArray = _itkMeshBasePython.itkMeshF3STF33FF_CellsAllocatedAsStaticArray
    CellsAllocatedAsADynamicArray = _itkMeshBasePython.itkMeshF3STF33FF_CellsAllocatedAsADynamicArray
    CellsAllocatedDynamicallyCellByCell = _itkMeshBasePython.itkMeshF3STF33FF_CellsAllocatedDynamicallyCellByCell

    def GetNumberOfCells(self) -> "unsigned long":
        """
        GetNumberOfCells(itkMeshF3STF33FF self) -> unsigned long

        Mesh-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_GetNumberOfCells(self)


    def PassStructure(self, inputMesh: 'itkMeshF3STF33FF') -> "void":
        """
        PassStructure(itkMeshF3STF33FF self, itkMeshF3STF33FF inputMesh)

        PointSet-level
        operation interface. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_PassStructure(self, inputMesh)


    def GetBoundingBox(self) -> "itkBoundingBoxUL3FVCULPF3 const *":
        """
        GetBoundingBox(itkMeshF3STF33FF self) -> itkBoundingBoxUL3FVCULPF3

        Get the bounding box
        of the mesh. The methods return a pointer to the user-supplied
        bounding box as a convenience. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_GetBoundingBox(self)


    def SetCellLinks(self, arg0: 'itkVectorContainerULSUL') -> "void":
        """
        SetCellLinks(itkMeshF3STF33FF self, itkVectorContainerULSUL arg0)

        Access
        m_CellsLinksContainer, which contains parent cell links for each
        point. Since a point can be used by multiple cells, each point
        identifier accesses another container which holds the cell identifiers

        """
        return _itkMeshBasePython.itkMeshF3STF33FF_SetCellLinks(self, arg0)


    def GetCellLinks(self, *args) -> "itkVectorContainerULSUL const *":
        """
        GetCellLinks(itkMeshF3STF33FF self) -> itkVectorContainerULSUL
        GetCellLinks(itkMeshF3STF33FF self) -> itkVectorContainerULSUL
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_GetCellLinks(self, *args)


    def SetCells(self, arg0: 'itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetCells(itkMeshF3STF33FF self, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 arg0)

        Access m_CellsContainer,
        which holds cells used by the mesh. Individual cells are accessed
        through cell identifiers. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_SetCells(self, arg0)


    def GetCells(self, *args) -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 const *":
        """
        GetCells(itkMeshF3STF33FF self) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3
        GetCells(itkMeshF3STF33FF self) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_GetCells(self, *args)


    def SetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "void":
        """
        SetCell(itkMeshF3STF33FF self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg1)

        Access routines to fill the
        Cells container (m_CellsContainer), and get information from it. If
        SetCell is used to overwrite a cell currently in the mesh, it is the
        caller's responsibility to release the memory for the cell currently
        at the CellIdentifier position prior to calling SetCell. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_SetCell(self, arg0, arg1)


    def GetCell(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """GetCell(itkMeshF3STF33FF self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg1) -> bool"""
        return _itkMeshBasePython.itkMeshF3STF33FF_GetCell(self, arg0, arg1)


    def SetCellData(self, *args) -> "void":
        """
        SetCellData(itkMeshF3STF33FF self, itkVectorContainerULF arg0)
        SetCellData(itkMeshF3STF33FF self, unsigned long arg0, float arg1)

        Access routines to fill
        the CellData container, and get information from it. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_SetCellData(self, *args)


    def GetCellData(self, *args) -> "bool":
        """
        GetCellData(itkMeshF3STF33FF self) -> itkVectorContainerULF
        GetCellData(itkMeshF3STF33FF self) -> itkVectorContainerULF
        GetCellData(itkMeshF3STF33FF self, unsigned long arg0, float * arg1) -> bool
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_GetCellData(self, *args)


    def SetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long') -> "void":
        """
        SetBoundaryAssignment(itkMeshF3STF33FF self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long boundaryId)

        Explicitly
        assign boundaryId as a part of the boundary of cellId. The identifiers
        boundaryId and cellId must identify cell objects already in the mesh.
        The dimension of boundaryId must be specified by dimension, and a
        unique CellFeatureIdentifier featureId must be assigned for each
        distinct boundary feature of a given dimension. CellFeatureIdentifier
        is equivalent to IdentifierType by default, and this typedef will not
        typically need to be changed. The UsingCells list of boundaryId is
        automatically updated to include cellId. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_SetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def GetBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long', boundaryId: 'unsigned long *') -> "bool":
        """
        GetBoundaryAssignment(itkMeshF3STF33FF self, int dimension, unsigned long cellId, unsigned long featureId, unsigned long * boundaryId) -> bool

        For the given
        cellId, get the identifier of a particular boundary feature of the
        given dimension. The featureId determines which boundary feature of
        the specified dimension is returned. For instance, if dimension is 1
        and featureId is 0, then GetBoundaryAssignment finds the 0th edge of
        the given cell. The return value indicates whether a feature of the
        appropriate dimension and featureId exists. If it does not, the
        BoundaryIdentifier pointer is left unchanged. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_GetBoundaryAssignment(self, dimension, cellId, featureId, boundaryId)


    def RemoveBoundaryAssignment(self, dimension: 'int', cellId: 'unsigned long', featureId: 'unsigned long') -> "bool":
        """RemoveBoundaryAssignment(itkMeshF3STF33FF self, int dimension, unsigned long cellId, unsigned long featureId) -> bool"""
        return _itkMeshBasePython.itkMeshF3STF33FF_RemoveBoundaryAssignment(self, dimension, cellId, featureId)


    def GetNumberOfCellBoundaryFeatures(self, dimension: 'int', arg1: 'unsigned long') -> "unsigned long":
        """
        GetNumberOfCellBoundaryFeatures(itkMeshF3STF33FF self, int dimension, unsigned long arg1) -> unsigned long

        Interface to cells. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_GetNumberOfCellBoundaryFeatures(self, dimension, arg1)


    def GetCellBoundaryFeature(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetCellBoundaryFeature(itkMeshF3STF33FF self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Get the
        boundary feature of the given dimension of the given cell
        corresponding to the given feature identifier. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_GetCellBoundaryFeature(self, dimension, arg1, arg2, arg3)


    def GetCellBoundaryFeatureNeighbors(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellBoundaryFeatureNeighbors(itkMeshF3STF33FF self, int dimension, unsigned long arg1, unsigned long arg2, setUL cellSet) -> unsigned long

        Get
        the set of cells neighboring the given cell across the given boundary
        feature. Returns the number of neighbors found. If cellSet is not
        ITK_NULLPTR, the set of cell pointers is filled in with identifiers of
        the neighboring cells. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_GetCellBoundaryFeatureNeighbors(self, dimension, arg1, arg2, cellSet)


    def GetCellNeighbors(self, cellId: 'unsigned long', cellSet: 'setUL') -> "unsigned long":
        """
        GetCellNeighbors(itkMeshF3STF33FF self, unsigned long cellId, setUL cellSet) -> unsigned long

        Get the set of
        cells having the given cell as part of their boundary. Returns the
        number of neighbors found. If cellSet is not ITK_NULLPTR, the set of
        cell pointers is filled in with identifiers of the neighboring cells.

        """
        return _itkMeshBasePython.itkMeshF3STF33FF_GetCellNeighbors(self, cellId, cellSet)


    def GetAssignedCellBoundaryIfOneExists(self, dimension: 'int', arg1: 'unsigned long', arg2: 'unsigned long', arg3: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer') -> "bool":
        """
        GetAssignedCellBoundaryIfOneExists(itkMeshF3STF33FF self, int dimension, unsigned long arg1, unsigned long arg2, itkCellInterfaceFCTI3FFULULULPF3VCULPF3_AutoPointer arg3) -> bool

        Check if there is an explicitly assigned boundary feature for the
        given dimension and cell- and cell-feature-identifiers. If there is, a
        pointer to it is given back through boundary (if boundary !=
        ITK_NULLPTR) and true is returned. Otherwise, false is returned. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_GetAssignedCellBoundaryIfOneExists(self, dimension, arg1, arg2, arg3)


    def BuildCellLinks(self) -> "void":
        """
        BuildCellLinks(itkMeshF3STF33FF self)

        Dynamically build
        the links from points back to their using cells. This information is
        stored in the cell links container, not in the points. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_BuildCellLinks(self)


    def Accept(self, mv: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor *') -> "void":
        """
        Accept(itkMeshF3STF33FF self, itkCellInterfaceFCTI3FFULULULPF3VCULPF3::MultiVisitor * mv)

        This method iterates over
        all the cells in the mesh and has each cell Accept the MultiVisitor.
        See MultiVisitor for more information. (Note, this follows the Visitor
        Design Pattern.) 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_Accept(self, mv)


    def SetCellsAllocationMethod(self, _arg: 'itkMeshF3STF33FF::CellsAllocationMethodType const') -> "void":
        """
        SetCellsAllocationMethod(itkMeshF3STF33FF self, itkMeshF3STF33FF::CellsAllocationMethodType const _arg)

        Set/Get
        the identification of the method used to allocate cells WARNING:
        Failure to call this method correctly will lead to memory leaks and/or
        segmentation faults because the cell memory will not be erased or will
        be erased with an improper method. 
        """
        return _itkMeshBasePython.itkMeshF3STF33FF_SetCellsAllocationMethod(self, _arg)


    def GetCellsAllocationMethod(self) -> "itkMeshF3STF33FF::CellsAllocationMethodType const &":
        """GetCellsAllocationMethod(itkMeshF3STF33FF self) -> itkMeshF3STF33FF::CellsAllocationMethodType const &"""
        return _itkMeshBasePython.itkMeshF3STF33FF_GetCellsAllocationMethod(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkMeshF3STF33FF

    def cast(obj: 'itkLightObject') -> "itkMeshF3STF33FF *":
        """cast(itkLightObject obj) -> itkMeshF3STF33FF"""
        return _itkMeshBasePython.itkMeshF3STF33FF_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkMeshF3STF33FF *":
        """GetPointer(itkMeshF3STF33FF self) -> itkMeshF3STF33FF"""
        return _itkMeshBasePython.itkMeshF3STF33FF_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkMeshF3STF33FF

        Create a new object of the class itkMeshF3STF33FF and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMeshF3STF33FF.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkMeshF3STF33FF.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkMeshF3STF33FF.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkMeshF3STF33FF.Clone = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_Clone, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetNumberOfCells = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetNumberOfCells, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.PassStructure = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_PassStructure, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetBoundingBox = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetBoundingBox, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.SetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_SetCellLinks, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetCellLinks, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.SetCells = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_SetCells, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetCells = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetCells, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.SetCell = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_SetCell, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetCell = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetCell, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.SetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_SetCellData, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetCellData = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetCellData, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.SetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_SetBoundaryAssignment, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetBoundaryAssignment, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.RemoveBoundaryAssignment = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_RemoveBoundaryAssignment, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetNumberOfCellBoundaryFeatures = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetNumberOfCellBoundaryFeatures, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetCellBoundaryFeature = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetCellBoundaryFeature, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetCellBoundaryFeatureNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetCellBoundaryFeatureNeighbors, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetCellNeighbors = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetCellNeighbors, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetAssignedCellBoundaryIfOneExists = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetAssignedCellBoundaryIfOneExists, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.BuildCellLinks = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_BuildCellLinks, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.Accept = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_Accept, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.SetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_SetCellsAllocationMethod, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetCellsAllocationMethod = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetCellsAllocationMethod, None, itkMeshF3STF33FF)
itkMeshF3STF33FF.GetPointer = new_instancemethod(_itkMeshBasePython.itkMeshF3STF33FF_GetPointer, None, itkMeshF3STF33FF)
itkMeshF3STF33FF_swigregister = _itkMeshBasePython.itkMeshF3STF33FF_swigregister
itkMeshF3STF33FF_swigregister(itkMeshF3STF33FF)

def itkMeshF3STF33FF___New_orig__() -> "itkMeshF3STF33FF_Pointer":
    """itkMeshF3STF33FF___New_orig__() -> itkMeshF3STF33FF_Pointer"""
    return _itkMeshBasePython.itkMeshF3STF33FF___New_orig__()

def itkMeshF3STF33FF_cast(obj: 'itkLightObject') -> "itkMeshF3STF33FF *":
    """itkMeshF3STF33FF_cast(itkLightObject obj) -> itkMeshF3STF33FF"""
    return _itkMeshBasePython.itkMeshF3STF33FF_cast(obj)

class itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    Wiki Examples:

    All Examples

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Pointer":
        """__New_orig__() -> itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Pointer":
        """Clone(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self) -> itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceDCTI2DDULULULPD2VCULPD2 *,std::allocator< itkCellInterfaceDCTI2DDULULULPD2VCULPD2 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self) -> std::vector< itkCellInterfaceDCTI2DDULULULPD2VCULPD2 *,std::allocator< itkCellInterfaceDCTI2DDULULULPD2VCULPD2 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceDCTI2DDULULULPD2VCULPD2 *,std::allocator< itkCellInterfaceDCTI2DDULULULPD2VCULPD2 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self) -> std::vector< itkCellInterfaceDCTI2DDULULULPD2VCULPD2 *,std::allocator< itkCellInterfaceDCTI2DDULULULPD2VCULPD2 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceDCTI2DDULULULPD2VCULPD2 *const &":
        """
        ElementAt(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DDULULULPD2VCULPD2
        ElementAt(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DDULULULPD2VCULPD2

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI2DDULULULPD2VCULPD2 *&":
        """
        CreateElementAt(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DDULULULPD2VCULPD2 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI2DDULULULPD2VCULPD2 *":
        """
        GetElement(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DDULULULPD2VCULPD2

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2') -> "void":
        """
        SetElement(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self, unsigned long arg0, itkCellInterfaceDCTI2DDULULULPD2VCULPD2 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2') -> "void":
        """
        InsertElement(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self, unsigned long arg0, itkCellInterfaceDCTI2DDULULULPD2VCULPD2 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DDULULULPD2VCULPD2 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self, unsigned long arg0, itkCellInterfaceDCTI2DDULULULPD2VCULPD2 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't
        ITK_NULLPTR), and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 *":
        """GetPointer(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 self) -> itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2

        Create a new object of the class itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Clone, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_CastToSTLContainer, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_CastToSTLConstContainer, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_ElementAt, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_CreateElementAt, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_GetElement, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_SetElement, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_InsertElement, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_IndexExists, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_GetElementIfIndexExists, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_CreateIndex, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_DeleteIndex, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Size, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Reserve, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Squeeze, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Initialize, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2.GetPointer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_GetPointer, None, itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_swigregister = _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_swigregister
itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_swigregister(itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2)

def itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2___New_orig__() -> "itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Pointer":
    """itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2___New_orig__() -> itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2___New_orig__()

def itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2 *":
    """itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_cast(itkLightObject obj) -> itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2"""
    return _itkMeshBasePython.itkVectorContainerULCIDCTI2DDULULULPD2VCULPD2_cast(obj)

class itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    Wiki Examples:

    All Examples

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Pointer":
        """__New_orig__() -> itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Pointer":
        """Clone(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self) -> itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceDCTI2DFULULULPD2VCULPD2 *,std::allocator< itkCellInterfaceDCTI2DFULULULPD2VCULPD2 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self) -> std::vector< itkCellInterfaceDCTI2DFULULULPD2VCULPD2 *,std::allocator< itkCellInterfaceDCTI2DFULULULPD2VCULPD2 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceDCTI2DFULULULPD2VCULPD2 *,std::allocator< itkCellInterfaceDCTI2DFULULULPD2VCULPD2 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self) -> std::vector< itkCellInterfaceDCTI2DFULULULPD2VCULPD2 *,std::allocator< itkCellInterfaceDCTI2DFULULULPD2VCULPD2 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceDCTI2DFULULULPD2VCULPD2 *const &":
        """
        ElementAt(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DFULULULPD2VCULPD2
        ElementAt(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DFULULULPD2VCULPD2

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI2DFULULULPD2VCULPD2 *&":
        """
        CreateElementAt(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DFULULULPD2VCULPD2 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI2DFULULULPD2VCULPD2 *":
        """
        GetElement(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self, unsigned long arg0) -> itkCellInterfaceDCTI2DFULULULPD2VCULPD2

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2') -> "void":
        """
        SetElement(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2VCULPD2 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2') -> "void":
        """
        InsertElement(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2VCULPD2 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI2DFULULULPD2VCULPD2 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self, unsigned long arg0, itkCellInterfaceDCTI2DFULULULPD2VCULPD2 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't
        ITK_NULLPTR), and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 *":
        """GetPointer(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 self) -> itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2

        Create a new object of the class itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Clone, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_CastToSTLContainer, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_CastToSTLConstContainer, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_ElementAt, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_CreateElementAt, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_GetElement, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_SetElement, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_InsertElement, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_IndexExists, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_GetElementIfIndexExists, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_CreateIndex, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_DeleteIndex, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Size, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Reserve, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Squeeze, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Initialize, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2.GetPointer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_GetPointer, None, itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_swigregister = _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_swigregister
itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_swigregister(itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2)

def itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2___New_orig__() -> "itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Pointer":
    """itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2___New_orig__() -> itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2___New_orig__()

def itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2 *":
    """itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_cast(itkLightObject obj) -> itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2"""
    return _itkMeshBasePython.itkVectorContainerULCIDCTI2DFULULULPD2VCULPD2_cast(obj)

class itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    Wiki Examples:

    All Examples

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Pointer":
        """__New_orig__() -> itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Pointer":
        """Clone(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self) -> itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceDCTI3DDULULULPD3VCULPD3 *,std::allocator< itkCellInterfaceDCTI3DDULULULPD3VCULPD3 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self) -> std::vector< itkCellInterfaceDCTI3DDULULULPD3VCULPD3 *,std::allocator< itkCellInterfaceDCTI3DDULULULPD3VCULPD3 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceDCTI3DDULULULPD3VCULPD3 *,std::allocator< itkCellInterfaceDCTI3DDULULULPD3VCULPD3 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self) -> std::vector< itkCellInterfaceDCTI3DDULULULPD3VCULPD3 *,std::allocator< itkCellInterfaceDCTI3DDULULULPD3VCULPD3 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceDCTI3DDULULULPD3VCULPD3 *const &":
        """
        ElementAt(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DDULULULPD3VCULPD3
        ElementAt(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DDULULULPD3VCULPD3

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI3DDULULULPD3VCULPD3 *&":
        """
        CreateElementAt(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DDULULULPD3VCULPD3 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI3DDULULULPD3VCULPD3 *":
        """
        GetElement(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DDULULULPD3VCULPD3

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3') -> "void":
        """
        SetElement(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self, unsigned long arg0, itkCellInterfaceDCTI3DDULULULPD3VCULPD3 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3') -> "void":
        """
        InsertElement(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self, unsigned long arg0, itkCellInterfaceDCTI3DDULULULPD3VCULPD3 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DDULULULPD3VCULPD3 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self, unsigned long arg0, itkCellInterfaceDCTI3DDULULULPD3VCULPD3 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't
        ITK_NULLPTR), and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 *":
        """GetPointer(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 self) -> itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3

        Create a new object of the class itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Clone, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_CastToSTLContainer, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_CastToSTLConstContainer, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_ElementAt, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_CreateElementAt, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_GetElement, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_SetElement, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_InsertElement, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_IndexExists, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_GetElementIfIndexExists, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_CreateIndex, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_DeleteIndex, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Size, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Reserve, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Squeeze, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Initialize, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3.GetPointer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_GetPointer, None, itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_swigregister = _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_swigregister
itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_swigregister(itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3)

def itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3___New_orig__() -> "itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Pointer":
    """itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3___New_orig__() -> itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3___New_orig__()

def itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3 *":
    """itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_cast(itkLightObject obj) -> itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3"""
    return _itkMeshBasePython.itkVectorContainerULCIDCTI3DDULULULPD3VCULPD3_cast(obj)

class itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    Wiki Examples:

    All Examples

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Pointer":
        """__New_orig__() -> itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Pointer":
        """Clone(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self) -> itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceDCTI3DFULULULPD3VCULPD3 *,std::allocator< itkCellInterfaceDCTI3DFULULULPD3VCULPD3 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self) -> std::vector< itkCellInterfaceDCTI3DFULULULPD3VCULPD3 *,std::allocator< itkCellInterfaceDCTI3DFULULULPD3VCULPD3 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceDCTI3DFULULULPD3VCULPD3 *,std::allocator< itkCellInterfaceDCTI3DFULULULPD3VCULPD3 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self) -> std::vector< itkCellInterfaceDCTI3DFULULULPD3VCULPD3 *,std::allocator< itkCellInterfaceDCTI3DFULULULPD3VCULPD3 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceDCTI3DFULULULPD3VCULPD3 *const &":
        """
        ElementAt(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DFULULULPD3VCULPD3
        ElementAt(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DFULULULPD3VCULPD3

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI3DFULULULPD3VCULPD3 *&":
        """
        CreateElementAt(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DFULULULPD3VCULPD3 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceDCTI3DFULULULPD3VCULPD3 *":
        """
        GetElement(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self, unsigned long arg0) -> itkCellInterfaceDCTI3DFULULULPD3VCULPD3

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3') -> "void":
        """
        SetElement(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3VCULPD3 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3') -> "void":
        """
        InsertElement(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3VCULPD3 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceDCTI3DFULULULPD3VCULPD3 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self, unsigned long arg0, itkCellInterfaceDCTI3DFULULULPD3VCULPD3 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't
        ITK_NULLPTR), and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 *":
        """GetPointer(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 self) -> itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3"""
        return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3

        Create a new object of the class itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Clone, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_CastToSTLContainer, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_CastToSTLConstContainer, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_ElementAt, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_CreateElementAt, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_GetElement, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_SetElement, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_InsertElement, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_IndexExists, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_GetElementIfIndexExists, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_CreateIndex, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_DeleteIndex, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Size, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Reserve, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Squeeze, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Initialize, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3.GetPointer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_GetPointer, None, itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_swigregister = _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_swigregister
itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_swigregister(itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3)

def itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3___New_orig__() -> "itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Pointer":
    """itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3___New_orig__() -> itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3___New_orig__()

def itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3 *":
    """itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_cast(itkLightObject obj) -> itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3"""
    return _itkMeshBasePython.itkVectorContainerULCIDCTI3DFULULULPD3VCULPD3_cast(obj)

class itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    Wiki Examples:

    All Examples

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Pointer":
        """__New_orig__() -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Pointer":
        """Clone(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self) -> std::vector< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self) -> std::vector< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *,std::allocator< itkCellInterfaceFCTI2FFULULULPF2VCULPF2 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *const &":
        """
        ElementAt(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2
        ElementAt(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *&":
        """
        CreateElementAt(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI2FFULULULPF2VCULPF2 *":
        """
        GetElement(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> itkCellInterfaceFCTI2FFULULULPF2VCULPF2

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2') -> "void":
        """
        SetElement(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2VCULPF2 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2') -> "void":
        """
        InsertElement(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2VCULPF2 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI2FFULULULPF2VCULPF2 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0, itkCellInterfaceFCTI2FFULULULPF2VCULPF2 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't
        ITK_NULLPTR), and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 *":
        """GetPointer(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 self) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2

        Create a new object of the class itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Clone, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CastToSTLContainer, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CastToSTLConstContainer, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_ElementAt, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CreateElementAt, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_GetElement, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_SetElement, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_InsertElement, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_IndexExists, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_GetElementIfIndexExists, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_CreateIndex, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_DeleteIndex, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Size, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Reserve, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Squeeze, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Initialize, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2.GetPointer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_GetPointer, None, itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_swigregister = _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_swigregister
itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_swigregister(itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2)

def itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2___New_orig__() -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Pointer":
    """itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2___New_orig__() -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2___New_orig__()

def itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2 *":
    """itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_cast(itkLightObject obj) -> itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2"""
    return _itkMeshBasePython.itkVectorContainerULCIFCTI2FFULULULPF2VCULPF2_cast(obj)

class itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3(ITKCommonBasePython.itkObject):
    """


    Define a front-end to the STL "vector" container that conforms to
    the IndexedContainerInterface.

    This is a full-fleged Object, so there is modification time, debug,
    and reference count information.

    Parameters:
    -----------

    TElementIdentifier:  An INTEGRAL type for use in indexing the vector.

    TElement:  The element type stored in the container.

    Wiki Examples:

    All Examples

    C++ includes: itkVectorContainer.h 
    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr

    def __New_orig__() -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Pointer":
        """__New_orig__() -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3___New_orig__()

    __New_orig__ = staticmethod(__New_orig__)

    def Clone(self) -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Pointer":
        """Clone(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Pointer"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Clone(self)


    def CastToSTLContainer(self) -> "std::vector< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 * > > &":
        """
        CastToSTLContainer(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self) -> std::vector< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 * > > &

        Cast the
        container to a STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CastToSTLContainer(self)


    def CastToSTLConstContainer(self) -> "std::vector< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 * > > const &":
        """
        CastToSTLConstContainer(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self) -> std::vector< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *,std::allocator< itkCellInterfaceFCTI3FFULULULPF3VCULPF3 * > > const &

        Cast the
        container to a const STL container type 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CastToSTLConstContainer(self)


    def ElementAt(self, *args) -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *const &":
        """
        ElementAt(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3
        ElementAt(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3

        Get a reference to the
        element at the given index. It is assumed that the index exists, and
        it will not automatically be created. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_ElementAt(self, *args)


    def CreateElementAt(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *&":
        """
        CreateElementAt(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *&

        Get a reference to
        the element at the given index. If the element location does not
        exist, it will be created with a default element value.

        It is assumed that the value of the element is modified through the
        reference. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CreateElementAt(self, arg0)


    def GetElement(self, arg0: 'unsigned long') -> "itkCellInterfaceFCTI3FFULULULPF3VCULPF3 *":
        """
        GetElement(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> itkCellInterfaceFCTI3FFULULULPF3VCULPF3

        Read the element from
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_GetElement(self, arg0)


    def SetElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3') -> "void":
        """
        SetElement(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3VCULPF3 arg1)

        Set the element value at
        the given index. It is assumed that the index exists. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_SetElement(self, arg0, arg1)


    def InsertElement(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3') -> "void":
        """
        InsertElement(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3VCULPF3 arg1)

        Set the element value
        at the given index. If the element location does not exist, it will be
        created with a default element value. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_InsertElement(self, arg0, arg1)


    def IndexExists(self, arg0: 'unsigned long') -> "bool":
        """
        IndexExists(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0) -> bool

        Check if the index
        range of the vector is large enough to allow the given index without
        expansion. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_IndexExists(self, arg0)


    def GetElementIfIndexExists(self, arg0: 'unsigned long', arg1: 'itkCellInterfaceFCTI3FFULULULPF3VCULPF3 **') -> "bool":
        """
        GetElementIfIndexExists(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0, itkCellInterfaceFCTI3FFULULULPF3VCULPF3 ** arg1) -> bool

        Check if
        the given index is in range of the vector. If it is not, return false.
        Otherwise, set the element through the pointer (if it isn't
        ITK_NULLPTR), and return true. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_GetElementIfIndexExists(self, arg0, arg1)


    def CreateIndex(self, arg0: 'unsigned long') -> "void":
        """
        CreateIndex(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Make sure that the
        index range of the vector is large enough to allow the given index,
        expanding it if necessary. The index will contain the default element
        regardless of whether expansion occurred. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CreateIndex(self, arg0)


    def DeleteIndex(self, arg0: 'unsigned long') -> "void":
        """
        DeleteIndex(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Delete the element
        defined by the index identifier. In practice, it doesn't make sense to
        delete a vector index. Instead, this method just overwrite the index
        with the default element. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_DeleteIndex(self, arg0)


    def Size(self) -> "unsigned long":
        """
        Size(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self) -> unsigned long

        Get the number of elements
        currently stored in the vector. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Size(self)


    def Reserve(self, arg0: 'unsigned long') -> "void":
        """
        Reserve(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self, unsigned long arg0)

        Tell the container to
        allocate enough memory to allow at least as many elements as the size
        given to be stored. In the generic case of ITK containers this is NOT
        guaranteed to actually allocate any memory, but it is useful if the
        implementation of the container allocates contiguous storage. In the
        particular implementation of this VectorContainer the call to this
        method actually allocates memory for the number of elements defined by
        ElementIdentifier. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Reserve(self, arg0)


    def Squeeze(self) -> "void":
        """
        Squeeze(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self)

        Tell the container to try
        to minimize its memory usage for storage of the current number of
        elements. This is NOT guaranteed to decrease memory usage. This method
        is included here mainly for providing a unified API with other
        containers in the toolkit. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Squeeze(self)


    def Initialize(self) -> "void":
        """
        Initialize(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self)

        Clear the elements. The
        final size will be zero. 
        """
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Initialize(self)

    __swig_destroy__ = _itkMeshBasePython.delete_itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3

    def cast(obj: 'itkLightObject') -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 *":
        """cast(itkLightObject obj) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_cast(obj)

    cast = staticmethod(cast)

    def GetPointer(self) -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 *":
        """GetPointer(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 self) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3"""
        return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_GetPointer(self)


    def New(*args, **kargs):
        """New() -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3

        Create a new object of the class itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.New( reader, Threshold=10 )

        is (most of the time) equivalent to:

          obj = itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.New()
          obj.SetInput( 0, reader.GetOutput() )
          obj.SetThreshold( 10 )
        """
        obj = itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)

itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.Clone = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Clone, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.CastToSTLContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CastToSTLContainer, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.CastToSTLConstContainer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CastToSTLConstContainer, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.ElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_ElementAt, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.CreateElementAt = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CreateElementAt, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.GetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_GetElement, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.SetElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_SetElement, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.InsertElement = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_InsertElement, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.IndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_IndexExists, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.GetElementIfIndexExists = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_GetElementIfIndexExists, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.CreateIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_CreateIndex, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.DeleteIndex = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_DeleteIndex, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.Size = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Size, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.Reserve = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Reserve, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.Squeeze = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Squeeze, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.Initialize = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Initialize, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3.GetPointer = new_instancemethod(_itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_GetPointer, None, itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_swigregister = _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_swigregister
itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_swigregister(itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3)

def itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3___New_orig__() -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Pointer":
    """itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3___New_orig__() -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_Pointer"""
    return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3___New_orig__()

def itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_cast(obj: 'itkLightObject') -> "itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3 *":
    """itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_cast(itkLightObject obj) -> itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3"""
    return _itkMeshBasePython.itkVectorContainerULCIFCTI3FFULULULPF3VCULPF3_cast(obj)



