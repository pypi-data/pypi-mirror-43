# dptduapi.py
# Copyright (c) 2007 Roger Marsh
# Licence: See LICENCE (BSD licence)

"""DPT single-step deferred update version.

A database API for bulk insertion of records, implemented using dptdb,
where indicies are represented as lists or bitmaps of record numbers.
    
dptdb is an interface to DPT's database engine generated by Swig.

DPT is an emulation of Model 204 version 5 which runs on Microsoft Windows.

DPT provides the list and bitmapped record number processing.

This module on Windows and Wine only.

See www.dptoolkit.com for details of DPT.

"""

from .api.database import DatabaseError

import sys
_platform_win32 = sys.platform == 'win32'
del sys
del DatabaseError

if not _platform_win32:
    raise DatabaseError('Platform is not "win32"')

import os

from dptdb import dptapi

from . import dptbase
from .api.constants import (
    FLT, INV, UAE, ORD, ONM, SPT,
    BSIZE, BRECPPG, BRESERVE, BREUSE,
    DSIZE, DRESERVE, DPGSRES,
    FILEORG,
    DPT_SYS_FOLDER, DPT_SYSDU_FOLDER,
    )


class DPTduapiError(dptbase.DPTbaseError):
    pass


class DPTduapi(dptbase.Database):
    
    """Bulk insert to database in databasefolder using database_specification.

    Support DPT single-step deferred updates.

    DPT non-deferred (normal) update methods provided by the dptbase.Database
    superclass are overridden here.

    """
    
    def __init__(self, database_specification, databasefolder, **kargs):
        """Create DPT single-step deferred update environment."""
        try:
            dptfolder = os.path.abspath(databasefolder)
        except:
            msg = ' '.join(['Main folder name', str(databasefolder),
                            'is not valid'])
            raise DPTduapiError(msg)
        
        #The database system parameters. DPT assumes reasonable defaults
        #for any values sought in self._dptkargs.
        #At Python26+ need to convert unicode to str for DPT
        dptsys = str(kargs.get(
            DPT_SYSDU_FOLDER,
            os.path.join(dptfolder, DPT_SYS_FOLDER, DPT_SYS_FOLDER)))
        username = str(kargs.get('username', 'dptapi'))

        super(DPTduapi, self).__init__(
            database_specification,
            databasefolder,
            dptsys=dptsys,
            username=username,
            **kargs)

    def create_default_parms(self):
        """Create default parms.ini file."""
        if not os.path.exists(self.get_parms()):
            pf = open(self.get_parms(), 'w')
            try:
                pf.write("RCVOPT=X'00' " + os.linesep)
                pf.write("MAXBUF=100 " + os.linesep)
            finally:
                pf.close()
                
    def delete_instance(self, dbname, instance):
        raise DPTduapiError('delete_instance not implemented')

    def do_deferred_updates(self, pyscript, filepath):
        raise DPTduapiError('do_deferred_updates not implemented')

    def edit_instance(self, dbname, instance):
        raise DPTduapiError('edit_instance not implemented')

    def make_cursor(self, dbname):
        raise DPTduapiError('make_cursor not implemented')

    def use_deferred_update_process(self):
        raise DPTduapiError('Query use of du when in deferred update mode')

    #def make_root(self, name, fname, dptfile, fieldnamefn, sfi):
    #    """DPT file interface customised for single-step deferred update"""
    #    return DPTRecord(name, fname, dptfile, fieldnamefn, sfi)

    def make_root(self, **kw):
        """DPT file interface customised for single-step deferred update"""
        return DPTRecord(**kw)

    def open_context_allocated(self, files=()):
        """Open all files in single-step deferred update mode.

        Intended use is to open files to examine file status, or perhaps the
        equivalent of DPT command VIEW TABLES, when the database is closed as
        far as the application subclass of dptbase.Database is concerned.

        It is assumed that the Database Services object exists.

        """
        for dd in files:
            if dd in self.database_definition:
                root = self.database_definition[dd]
                self.dbservices.Allocate(
                    root._ddname,
                    root._file,
                    dptapi.FILEDISP_OLD)
                cs = dptapi.APIContextSpecification(root._ddname)
                root._opencontext = self.dbservices.OpenContext_DUSingle(cs)

    def deferred_update_housekeeping(self):
        """Call Commit() if a non-TBO update is in progress.

        In non-TBO mode Commit() does not commit the tranasction, but it does
        release redundant resources which would not otherwise be released and
        may lead to an insuffient memory exception.

        """
        if self.dbservices:
            if self.dbservices.UpdateIsInProgress():
                self.dbservices.Commit()


class DPTRecord(dptbase.DPTRecord):

    """Provide single-step deferred update sort processing for DPT file.

    This class disables methods not appropriate to deferred update.
    
    """

    def delete_instance(self, dbname, instance):
        raise DPTduapiError('delete_instance not implemented')

    def edit_instance(self, dbname, instance):
        raise DPTduapiError('edit_instance not implemented')

    def make_cursor(self, dbname):
        raise DPTduapiError('make_cursor not implemented')

    def open_root(self, db):
        """Extend to open file in single-step mode."""
        super().open_root(db)
        db.dbservices.Allocate(
            self._ddname,
            self._file,
            dptapi.FILEDISP_COND)
        cs = dptapi.APIContextSpecification(self._ddname)
        self._opencontext = db.dbservices.OpenContext_DUSingle(cs)
            
