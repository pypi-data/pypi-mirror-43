# dptapi.py
# Copyright (c) 2007 Roger Marsh
# Licence: See LICENCE (BSD licence)

"""DPT normal version.

A database API, implemented using dptdb, where indicies are represented as
lists or bitmaps of record numbers.
    
dptdb is an interface to DPT's database engine generated by Swig.

DPT is an emulation of Model 204 version 5 which runs on Microsoft Windows.

DPT provides the list and bitmapped record number processing.

This module on Windows and Wine only.

See www.dptoolkit.com for details of DPT.

"""

from .api.database import DatabaseError

import sys
_platform_win32 = sys.platform == 'win32'
del sys

if not _platform_win32:
    raise DatabaseError('Platform is not "win32"')
del DatabaseError

from dptdb import dptapi

from . import dptbase
from .api.constants import FLT, INV, UAE, ORD, ONM, SPT
from .api.constants import BSIZE, BRECPPG, BRESERVE, BREUSE
from .api.constants import DSIZE, DRESERVE, DPGSRES
from .api.constants import FILEORG


class DPTapiError(dptbase.DPTbaseError):
    pass


class DPTapi(dptbase.Database):
    
    """Access database with dptdb.  See superclass for *args and **kargs.
    
    dptdb is an interface to DPT's database engine.
    
    """

    def set_defer_update(self, db=None, duallowed=False):
        """Close files before doing deferred updates.

        This method is provided for compatibility with the interface for
        bsddb in dbapi.py.
        
        """
        self.close_context()
        return duallowed

    def unset_defer_update(self, db=None):
        """Reopen files after doing deferred updates.

        This method is provided for compatibility with the interface for
        bsddb in dbapi.py.
        
        """
        return self.open_context()

    def use_deferred_update_process(self, **kargs):
        """Return module name or None

        **kargs - soak up any arguments other database engines need.

        """
        raise DPTapiError('use_deferred_update_process not implemented')

    #def make_root(self, name, fname, dptfile, fieldnamefn, sfi):
    def make_root(self, **kw):

        #return DPTapiRoot(name, fname, dptfile, fieldnamefn, sfi)
        return DPTapiRoot(**kw)


class DPTapiRoot(dptbase.DPTRecord):

    """Provide record level access to a DPT file in non-deferred update mode.

    This is achieved by extending the open_root method to open the file, or
    re-open the file after creating it.
    
    """

    def open_root(self, db):
        """Open file and return True if it is in non-deferred update mode.

        The superclass open_root method creates the file if it does not exist
        but leaves it closed.
        
        """
        super(DPTapiRoot, self).open_root(db)
        try:
            db.dbservices.Allocate(
                self._ddname,
                self._file,
                dptapi.FILEDISP_COND)
        except:
            pass
        cs = dptapi.APIContextSpecification(self._ddname)
        self._opencontext = db.dbservices.OpenContext(cs)
            
