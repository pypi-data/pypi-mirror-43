'''
Use of this source code is governed by a MIT-style license that can be found in the LICENSE file.
Created on Nov 21, 2016
@author: Niels Lubbes
'''

from moebius_aut.class_ma_tools import MATools

from moebius_aut.sage_interface import sage_PolynomialRing
from moebius_aut.sage_interface import sage_NumberField
from moebius_aut.sage_interface import sage_FractionField
from moebius_aut.sage_interface import sage_QQ
from moebius_aut.sage_interface import sage_SR
from moebius_aut.sage_interface import sage_ZZ
from moebius_aut.sage_interface import sage_solve
from moebius_aut.sage_interface import sage__eval
from moebius_aut.sage_interface import sage_matrix
from moebius_aut.sage_interface import sage_Subsets
from moebius_aut.sage_interface import sage_invariant_theory
from moebius_aut.sage_interface import sage_diff


def ring( s ):
    return MARing.ring( s )


class MARing:
    '''
    This class represents a polynomial ring over a fraction field:
    
        FF[s,t,u,w,x#,y#,z#,q#,r#]
    
    where # is in [0,19]
    
        FF := NF(a,b,c,d,e,f,g,h,k) 
    and
     
        NF := QQ(I) 
    
    with I^2==-1
    
    The r% variables are in order to cast solution dictionaries as 
    returned by the Sage "solve" method. 
    
    Attributes
    ----------
    R : sage_PolynomialRing
        Polynomial ring  FF[s,t,u,w,x#,y#,z#,q#,r#].
    '''

    a = sage_PolynomialRing( sage_QQ, 'a' ).gens()[0]
    NF = sage_NumberField( [a ** 2 + 1], 'I' )
    I = NF.gens()[0]

    va_lst = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'k']
    FF = sage_FractionField( sage_PolynomialRing( NF, va_lst ) )

    vx_lst = [ 'x' + str( i ) for i in range( 9 )]
    vy_lst = [ 'y' + str( i ) for i in range( 9 )]
    vz_lst = [ 'z' + str( i ) for i in range( 9 )]
    vs_lst = ['s', 't', 'u', 'w']
    vq_lst = [ 'q' + str( i ) for i in range( 20 ) ]
    vr_lst = [ 'r' + str( i ) for i in range( 20 ) ]

    R = sage_PolynomialRing( FF, vx_lst + vy_lst + vz_lst + vs_lst + vq_lst + vr_lst )

    gens_dct = NF.gens_dict()
    gens_dct.update( FF.gens_dict() )
    gens_dct.update( R.gens_dict() )

    # R.inject_variables();NF.inject_variables();FF.inject_variables()


    @staticmethod
    def x():
        return MARing.ring( 'x0, x1, x2, x3, x4, x5, x6, x7, x8' )


    @staticmethod
    def y():
        return MARing.ring( 'y0, y1, y2, y3, y4, y5, y6, y7, y8' )


    @staticmethod
    def z():
        return MARing.ring( 'z0, z1, z2, z3, z4, z5, z6, z7, z8' )


    @staticmethod
    def q():
        return MARing.ring( 'q0,q1,q2,q3,q4,q5,q6,q7,q8,q9,q10,q11,q12,q13,q14,q15,q16,q17,q18,q19' )


    @staticmethod
    def r():
        return MARing.ring( [ring( 'r' + str( i ) ) for i in range( 20 )] )


    @staticmethod
    def solve( pol_lst, var_lst ):
        '''
        Parameters
        ----------
        pol_lst : list<MARing.R> 
            List of polynomials in "MARing.R" 
            but not in the variables r0,r1,....
    
        var_lst : list
            List of variables  "MARing.R". 
            Length of list should be at most 20.
        
        Returns
        -------
        dict
            A dictionary of parametrized solutions of the  
            zeroset of the ideal generated by the polynomials in 
            "pol_lst". The solutions are parametrized in terms of r0,r1,... 
        
        Note
        ----
            We call Sage "solve" method, but reset the indeterminates
            to be r0,...,r19, otherwise for each new call new 
            r# variables are introduced. The "reset" and "restore"
            functions do not work. See also:
              <https://ask.sagemath.org/question/23719/how-to-reset-variables/>              
            The indeterminates of the "solve" method are either c or r. 
        '''
        # cast to Sage symbolic ring SR and
        # call solve.
        #
        spol_lst = [ sage_SR( str( pol ) ) for pol in pol_lst ]
        svar_lst = [ sage_SR( str( var ) ) for var in var_lst ]
        dct = sage_solve( spol_lst, svar_lst, solution_dict = True )[0]
        MATools.p( 'pol_lst =', pol_lst )
        MATools.p( 'var_lst =', var_lst )
        MATools.p( 'dct     =', dct )

        # construct a list with integers i such
        # ri is occuring in the "dct" dictionary.
        #
        end_char_lst = []
        s = str( dct )
        if pol_lst == []:  # ci are used instead of ri
            s = s.replace( 'c', 'r' )
        rn_lst = []
        i = 0
        while i < len( s ):

            if s[i] == 'r':
                i += 1
                n = ''
                while s[i] in [str( j ) for j in range( 10 )]:
                    n += s[i]
                    i += 1

                # store end character: eg. 'r10}' OR 'r10*' OR 'r10,' OR 'r10 '
                if s[i] not in end_char_lst:
                    end_char_lst += [ s[i] ]

                if int( n ) not in rn_lst:
                    rn_lst += [int( n )]
            i += 1

        MATools.p( 'end_char_lst =', end_char_lst )
        MATools.p( 'rn_lst       =', rn_lst )

        # replace each occurence of r<i> with r<t>
        # where t=0,...,t19
        #
        t = 0
        for n in sorted( rn_lst ):

            #
            # note that we want to prevent for example:
            #     r1-->r0 but also r10-->r00, for this
            # reason we consider the character which indicates
            # the end of the r-variable string so that:
            #    'r1}'-->'r0}', 'r1,'-->'r0,', 'r10'--->'r10'
            #
            for end_char in end_char_lst:
                s = s.replace( 'r' + str( n ) + end_char, 'r' + str( t ) + end_char )
            t += 1


        # cast to solution dictionary with
        # keys and values in "MARing.R"
        #
        sol_dct = ring( s )
        MATools.p( 'sol_dct =', sol_dct )

        return sol_dct


    @staticmethod
    def ring( expr ):
        return sage__eval( str( expr ), MARing.gens_dct )


    @staticmethod
    def diff_mat( mat , var ):
        '''
        Parameters
        ----------
        mat : sage_MATRIX
            A matrix defined over "MARing".
        var :  MARing.R
            An indeterminate in "MARing". 
        
        
        Returns
        -------
            Returns a matrix whose entries are 
            differentiated wrt. "var".              
        '''

        dmat = []
        for row in mat:
            drow = []
            for col in row:
                drow += [ sage_diff( col, var ) ]
            dmat += [drow]

        return sage_matrix( dmat )


    @staticmethod
    def get_sig( pol ):
        '''
        Parameters
        ----------
        pol : MARing.R
            A quadratic form in the subring QQ[x0,...,x9] of the "MARing".
        
        Returns
        -------
        int[]
            An ordered pair of integers which denotes the signature 
            of the 9x9 Gramm matrix of the quadratic form.
                            
        Example
        -------
            >>>> get_sig(MARing.ring('-x0^2+x1^2+x2^2+x3^2+x4^2'))==[1,4]
            True
            
            The return value [1,4] means that the matrix is conjugate 
            to matrix with diagonal either (1,-1,-1,-1,-1,0,0,0,0) 
            or (-1,1,1,1,1,0,0,0,0).
        '''

        x = MARing.x()

        M = sage_invariant_theory.quadratic_form( pol, x ).as_QuadraticForm().matrix()
        M = sage_matrix( sage_QQ, M )
        D, V = M.eigenmatrix_right()

        # determine signature of quadric
        #
        num_neg = len( [ d for d in D.diagonal() if d < 0 ] )
        num_pos = len( [ d for d in D.diagonal() if d > 0 ] )

        return sorted( [ num_neg, num_pos ] )


    @staticmethod
    def get_rand_sigs( pol_lst, num_tries = 10 ):
        '''
        Parameters
        ----------
        pol_lst : list<MARing.R>   
            A list of polynomials in the ring "MARing.R".
        
        num_tries : int 
            A positive integer. 
                
        Returns
        -------
        list
            Returns a sorted list of pairs of integers that represent 
            signatures of random quadratic forms in the ideal generated 
            by "pol_lst". For each subset of the list of quadrics, this 
            method computes "num_tries" of random linear combination of 
            this subset of quadratic forms. 
        '''
        q_lst = [ pol for pol in pol_lst if pol.total_degree() == 2 ]

        sig_lst = []
        for s_lst in sage_Subsets( len( q_lst ) ):
            for i in range( num_tries ):
                quad = sum( [  sage_QQ.random_element() * q_lst[s - 1] for s in s_lst ] )
                if quad in sage_QQ:
                    continue
                sig = MARing.get_sig( quad )
                if sig not in sig_lst:
                    sig_lst += [sig ]
                    MATools.p( 'sig =', sig, '\t\t quad =', quad )
                    MATools.p( '\t\t sub_lst', [q_lst[s - 1] for s in s_lst ] )

        return sorted( sig_lst )



    @staticmethod
    def random_int( val ):
        '''
        Parameters
        ----------
        val : int  
            An integer.
        
        Returns
        -------
        int
            A random element in the interval [-val,val]
        '''
        return int( sage_ZZ.random_element( -val, val + 1 ) )


    @staticmethod
    def random_elt( lst ):
        '''
        Parameters
        ----------
        lst : list
            A list.
        
        Returns
        -------
        object        
            A random element in "lst".
        '''
        idx = int( sage_ZZ.random_element( 0, len( lst ) ) )
        return lst[idx]


    @staticmethod
    def replace_conj_pairs( q_lst ):
        '''
        Parameters
        ----------
        q_lst : list<MARing.R>
            A list of polynomials in MARing.R.                               
        
        Returns
        -------
        list<MARing.R>
            If there is a pair of complex conjugate polynomials 
            (q1,q2) with q1 and q2 in "q_lst" then this pair is 
            replaced by ((q1+q2)/2,((q1-q2)*I)/(-2)). 
            Moreover, if -I*q is real for some q in "q_lst", 
            then q is replaced by -I*q.  
        '''
        I = ring( 'I' )

        c_lst = []
        r_lst = []
        for q in q_lst:
            if 'I' in str( q ):

                if 'I' not in str( -I * q ):
                    r_lst += [ -I * q ]
                else:
                    c_lst += [q]
            else:
                r_lst += [q]

        pair_lst = []
        for c1 in c_lst:
            for c2 in c_lst:
                A = ( c1 + c2 ) / 2
                B = ( c1 - c2 ) * I / 2
                if c1 in pair_lst and c2 in pair_lst:
                    continue
                elif 'I' in str( A ) or 'I' in str( B ):
                    continue
                else:
                    r_lst += [A, B]
                    pair_lst += [c1, c2]

        nc_lst = []
        for c in c_lst:
            if c not in pair_lst:
                nc_lst += [c]

        return sorted( r_lst + nc_lst )
