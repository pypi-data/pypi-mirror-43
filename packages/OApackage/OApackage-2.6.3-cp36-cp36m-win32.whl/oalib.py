# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""Python Orthogonal Array interface"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_oalib')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_oalib')
    _oalib = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_oalib', [dirname(__file__)])
        except ImportError:
            import _oalib
            return _oalib
        try:
            _mod = imp.load_module('_oalib', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _oalib = swig_import_helper()
    del swig_import_helper
else:
    import _oalib
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        object.__setattr__(self, name, value)
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_method(set):
    def set_attr(self, name, value):
        if (name == "thisown"):
            return self.this.own(value)
        if hasattr(self, name) or (name == "this"):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


class SwigPyIterator(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _oalib.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self):
        return _oalib.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _oalib.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _oalib.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _oalib.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _oalib.SwigPyIterator_equal(self, x)

    def copy(self):
        return _oalib.SwigPyIterator_copy(self)

    def next(self):
        return _oalib.SwigPyIterator_next(self)

    def __next__(self):
        return _oalib.SwigPyIterator___next__(self)

    def previous(self):
        return _oalib.SwigPyIterator_previous(self)

    def advance(self, n):
        return _oalib.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _oalib.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _oalib.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _oalib.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _oalib.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _oalib.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _oalib.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _oalib.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)


import sys
import numpy as np
import copy

def reduceGraphNauty(G, colors=None, verbose=1):
  """ Return vertex transformation reducing array to normal form

  The reduction is calculated using `Nauty <http://users.cecs.anu.edu.au/~bdm/nauty/>`_

  Args:
      G (numpy array or array_link) :	the graph in incidence matrix form
      colors (list or None): an optional vertex coloring
  Returns:
      v: relabelling of the vertices
  """
  if isinstance(G, np.ndarray):
      al=array_link()
      al.setarray(G)
  else:
      al = copy.copy(G)
  if colors is None:
    colors = [0] * G.shape[0]
  v = _oalib.reduceNauty ( al, colors, verbose )
  return v

def transformGraphMatrix(G, tr, verbose=1):
    """ Apply a vertex permutation to a graph 

    Arguments
    ---------
      G : Numpy array
	the graph in incidence matrix form
      tr : list 
	the vertex transformation as a list

    Returns
    -------
      The transformed graph

    """
    al=array_link()
    al.setarray(G)
    alt = _oalib.transformGraph(al, tr, verbose)  
    return np.array(alt)


class arraylist_t(object):
    """Proxy of C++ std::deque<(array_link)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def iterator(self):
        """iterator(arraylist_t self) -> SwigPyIterator"""
        return _oalib.arraylist_t_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(arraylist_t self) -> bool"""
        return _oalib.arraylist_t___nonzero__(self)


    def __bool__(self):
        """__bool__(arraylist_t self) -> bool"""
        return _oalib.arraylist_t___bool__(self)


    def __len__(self):
        """__len__(arraylist_t self) -> std::deque< array_link >::size_type"""
        return _oalib.arraylist_t___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(arraylist_t self, std::deque< array_link >::difference_type i, std::deque< array_link >::difference_type j) -> arraylist_t"""
        return _oalib.arraylist_t___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(arraylist_t self, std::deque< array_link >::difference_type i, std::deque< array_link >::difference_type j)
        __setslice__(arraylist_t self, std::deque< array_link >::difference_type i, std::deque< array_link >::difference_type j, arraylist_t v)
        """
        return _oalib.arraylist_t___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(arraylist_t self, std::deque< array_link >::difference_type i, std::deque< array_link >::difference_type j)"""
        return _oalib.arraylist_t___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(arraylist_t self, std::deque< array_link >::difference_type i)
        __delitem__(arraylist_t self, PySliceObject * slice)
        """
        return _oalib.arraylist_t___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(arraylist_t self, PySliceObject * slice) -> arraylist_t
        __getitem__(arraylist_t self, std::deque< array_link >::difference_type i) -> array_link
        """
        return _oalib.arraylist_t___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(arraylist_t self, PySliceObject * slice, arraylist_t v)
        __setitem__(arraylist_t self, PySliceObject * slice)
        __setitem__(arraylist_t self, std::deque< array_link >::difference_type i, array_link x)
        """
        return _oalib.arraylist_t___setitem__(self, *args)


    def pop(self):
        """pop(arraylist_t self) -> array_link"""
        return _oalib.arraylist_t_pop(self)


    def append(self, x):
        """append(arraylist_t self, array_link x)"""
        return _oalib.arraylist_t_append(self, x)


    def empty(self):
        """empty(arraylist_t self) -> bool"""
        return _oalib.arraylist_t_empty(self)


    def size(self):
        """size(arraylist_t self) -> std::deque< array_link >::size_type"""
        return _oalib.arraylist_t_size(self)


    def swap(self, v):
        """swap(arraylist_t self, arraylist_t v)"""
        return _oalib.arraylist_t_swap(self, v)


    def begin(self):
        """begin(arraylist_t self) -> std::deque< array_link >::iterator"""
        return _oalib.arraylist_t_begin(self)


    def end(self):
        """end(arraylist_t self) -> std::deque< array_link >::iterator"""
        return _oalib.arraylist_t_end(self)


    def rbegin(self):
        """rbegin(arraylist_t self) -> std::deque< array_link >::reverse_iterator"""
        return _oalib.arraylist_t_rbegin(self)


    def rend(self):
        """rend(arraylist_t self) -> std::deque< array_link >::reverse_iterator"""
        return _oalib.arraylist_t_rend(self)


    def clear(self):
        """clear(arraylist_t self)"""
        return _oalib.arraylist_t_clear(self)


    def get_allocator(self):
        """get_allocator(arraylist_t self) -> std::deque< array_link >::allocator_type"""
        return _oalib.arraylist_t_get_allocator(self)


    def pop_back(self):
        """pop_back(arraylist_t self)"""
        return _oalib.arraylist_t_pop_back(self)


    def erase(self, *args):
        """
        erase(arraylist_t self, std::deque< array_link >::iterator pos) -> std::deque< array_link >::iterator
        erase(arraylist_t self, std::deque< array_link >::iterator first, std::deque< array_link >::iterator last) -> std::deque< array_link >::iterator
        """
        return _oalib.arraylist_t_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::deque<(array_link)> self) -> arraylist_t
        __init__(std::deque<(array_link)> self, arraylist_t arg2) -> arraylist_t
        __init__(std::deque<(array_link)> self, std::deque< array_link >::size_type size) -> arraylist_t
        __init__(std::deque<(array_link)> self, std::deque< array_link >::size_type size, array_link value) -> arraylist_t
        """
        this = _oalib.new_arraylist_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(arraylist_t self, array_link x)"""
        return _oalib.arraylist_t_push_back(self, x)


    def front(self):
        """front(arraylist_t self) -> array_link"""
        return _oalib.arraylist_t_front(self)


    def back(self):
        """back(arraylist_t self) -> array_link"""
        return _oalib.arraylist_t_back(self)


    def assign(self, n, x):
        """assign(arraylist_t self, std::deque< array_link >::size_type n, array_link x)"""
        return _oalib.arraylist_t_assign(self, n, x)


    def resize(self, *args):
        """
        resize(arraylist_t self, std::deque< array_link >::size_type new_size)
        resize(arraylist_t self, std::deque< array_link >::size_type new_size, array_link x)
        """
        return _oalib.arraylist_t_resize(self, *args)


    def insert(self, *args):
        """
        insert(arraylist_t self, std::deque< array_link >::iterator pos, array_link x) -> std::deque< array_link >::iterator
        insert(arraylist_t self, std::deque< array_link >::iterator pos, std::deque< array_link >::size_type n, array_link x)
        """
        return _oalib.arraylist_t_insert(self, *args)


    def pop_front(self):
        """pop_front(arraylist_t self)"""
        return _oalib.arraylist_t_pop_front(self)


    def push_front(self, x):
        """push_front(arraylist_t self, array_link x)"""
        return _oalib.arraylist_t_push_front(self, x)


    def __repr__(self):
        """__repr__(arraylist_t self) -> std::string"""
        return _oalib.arraylist_t___repr__(self)

    __swig_destroy__ = _oalib.delete_arraylist_t
    __del__ = lambda self: None
arraylist_t_swigregister = _oalib.arraylist_t_swigregister
arraylist_t_swigregister(arraylist_t)

class jstructArray(object):
    """Proxy of C++ std::vector<(jstruct_t)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(jstructArray self) -> SwigPyIterator"""
        return _oalib.jstructArray_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(jstructArray self) -> bool"""
        return _oalib.jstructArray___nonzero__(self)


    def __bool__(self):
        """__bool__(jstructArray self) -> bool"""
        return _oalib.jstructArray___bool__(self)


    def __len__(self):
        """__len__(jstructArray self) -> std::vector< jstruct_t >::size_type"""
        return _oalib.jstructArray___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(jstructArray self, std::vector< jstruct_t >::difference_type i, std::vector< jstruct_t >::difference_type j) -> jstructArray"""
        return _oalib.jstructArray___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(jstructArray self, std::vector< jstruct_t >::difference_type i, std::vector< jstruct_t >::difference_type j)
        __setslice__(jstructArray self, std::vector< jstruct_t >::difference_type i, std::vector< jstruct_t >::difference_type j, jstructArray v)
        """
        return _oalib.jstructArray___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(jstructArray self, std::vector< jstruct_t >::difference_type i, std::vector< jstruct_t >::difference_type j)"""
        return _oalib.jstructArray___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(jstructArray self, std::vector< jstruct_t >::difference_type i)
        __delitem__(jstructArray self, PySliceObject * slice)
        """
        return _oalib.jstructArray___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(jstructArray self, PySliceObject * slice) -> jstructArray
        __getitem__(jstructArray self, std::vector< jstruct_t >::difference_type i) -> jstruct_t
        """
        return _oalib.jstructArray___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(jstructArray self, PySliceObject * slice, jstructArray v)
        __setitem__(jstructArray self, PySliceObject * slice)
        __setitem__(jstructArray self, std::vector< jstruct_t >::difference_type i, jstruct_t x)
        """
        return _oalib.jstructArray___setitem__(self, *args)


    def pop(self):
        """pop(jstructArray self) -> jstruct_t"""
        return _oalib.jstructArray_pop(self)


    def append(self, x):
        """append(jstructArray self, jstruct_t x)"""
        return _oalib.jstructArray_append(self, x)


    def empty(self):
        """empty(jstructArray self) -> bool"""
        return _oalib.jstructArray_empty(self)


    def size(self):
        """size(jstructArray self) -> std::vector< jstruct_t >::size_type"""
        return _oalib.jstructArray_size(self)


    def swap(self, v):
        """swap(jstructArray self, jstructArray v)"""
        return _oalib.jstructArray_swap(self, v)


    def begin(self):
        """begin(jstructArray self) -> std::vector< jstruct_t >::iterator"""
        return _oalib.jstructArray_begin(self)


    def end(self):
        """end(jstructArray self) -> std::vector< jstruct_t >::iterator"""
        return _oalib.jstructArray_end(self)


    def rbegin(self):
        """rbegin(jstructArray self) -> std::vector< jstruct_t >::reverse_iterator"""
        return _oalib.jstructArray_rbegin(self)


    def rend(self):
        """rend(jstructArray self) -> std::vector< jstruct_t >::reverse_iterator"""
        return _oalib.jstructArray_rend(self)


    def clear(self):
        """clear(jstructArray self)"""
        return _oalib.jstructArray_clear(self)


    def get_allocator(self):
        """get_allocator(jstructArray self) -> std::vector< jstruct_t >::allocator_type"""
        return _oalib.jstructArray_get_allocator(self)


    def pop_back(self):
        """pop_back(jstructArray self)"""
        return _oalib.jstructArray_pop_back(self)


    def erase(self, *args):
        """
        erase(jstructArray self, std::vector< jstruct_t >::iterator pos) -> std::vector< jstruct_t >::iterator
        erase(jstructArray self, std::vector< jstruct_t >::iterator first, std::vector< jstruct_t >::iterator last) -> std::vector< jstruct_t >::iterator
        """
        return _oalib.jstructArray_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(jstruct_t)> self) -> jstructArray
        __init__(std::vector<(jstruct_t)> self, jstructArray arg2) -> jstructArray
        __init__(std::vector<(jstruct_t)> self, std::vector< jstruct_t >::size_type size) -> jstructArray
        __init__(std::vector<(jstruct_t)> self, std::vector< jstruct_t >::size_type size, jstruct_t value) -> jstructArray
        """
        this = _oalib.new_jstructArray(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(jstructArray self, jstruct_t x)"""
        return _oalib.jstructArray_push_back(self, x)


    def front(self):
        """front(jstructArray self) -> jstruct_t"""
        return _oalib.jstructArray_front(self)


    def back(self):
        """back(jstructArray self) -> jstruct_t"""
        return _oalib.jstructArray_back(self)


    def assign(self, n, x):
        """assign(jstructArray self, std::vector< jstruct_t >::size_type n, jstruct_t x)"""
        return _oalib.jstructArray_assign(self, n, x)


    def resize(self, *args):
        """
        resize(jstructArray self, std::vector< jstruct_t >::size_type new_size)
        resize(jstructArray self, std::vector< jstruct_t >::size_type new_size, jstruct_t x)
        """
        return _oalib.jstructArray_resize(self, *args)


    def insert(self, *args):
        """
        insert(jstructArray self, std::vector< jstruct_t >::iterator pos, jstruct_t x) -> std::vector< jstruct_t >::iterator
        insert(jstructArray self, std::vector< jstruct_t >::iterator pos, std::vector< jstruct_t >::size_type n, jstruct_t x)
        """
        return _oalib.jstructArray_insert(self, *args)


    def reserve(self, n):
        """reserve(jstructArray self, std::vector< jstruct_t >::size_type n)"""
        return _oalib.jstructArray_reserve(self, n)


    def capacity(self):
        """capacity(jstructArray self) -> std::vector< jstruct_t >::size_type"""
        return _oalib.jstructArray_capacity(self)

    __swig_destroy__ = _oalib.delete_jstructArray
    __del__ = lambda self: None
jstructArray_swigregister = _oalib.jstructArray_swigregister
jstructArray_swigregister(jstructArray)

class uint8Vector(object):
    """Proxy of C++ std::vector<(unsigned char)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(uint8Vector self) -> SwigPyIterator"""
        return _oalib.uint8Vector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(uint8Vector self) -> bool"""
        return _oalib.uint8Vector___nonzero__(self)


    def __bool__(self):
        """__bool__(uint8Vector self) -> bool"""
        return _oalib.uint8Vector___bool__(self)


    def __len__(self):
        """__len__(uint8Vector self) -> std::vector< unsigned char >::size_type"""
        return _oalib.uint8Vector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(uint8Vector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j) -> uint8Vector"""
        return _oalib.uint8Vector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(uint8Vector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j)
        __setslice__(uint8Vector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j, uint8Vector v)
        """
        return _oalib.uint8Vector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(uint8Vector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::difference_type j)"""
        return _oalib.uint8Vector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(uint8Vector self, std::vector< unsigned char >::difference_type i)
        __delitem__(uint8Vector self, PySliceObject * slice)
        """
        return _oalib.uint8Vector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(uint8Vector self, PySliceObject * slice) -> uint8Vector
        __getitem__(uint8Vector self, std::vector< unsigned char >::difference_type i) -> std::vector< unsigned char >::value_type const &
        """
        return _oalib.uint8Vector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(uint8Vector self, PySliceObject * slice, uint8Vector v)
        __setitem__(uint8Vector self, PySliceObject * slice)
        __setitem__(uint8Vector self, std::vector< unsigned char >::difference_type i, std::vector< unsigned char >::value_type const & x)
        """
        return _oalib.uint8Vector___setitem__(self, *args)


    def pop(self):
        """pop(uint8Vector self) -> std::vector< unsigned char >::value_type"""
        return _oalib.uint8Vector_pop(self)


    def append(self, x):
        """append(uint8Vector self, std::vector< unsigned char >::value_type const & x)"""
        return _oalib.uint8Vector_append(self, x)


    def empty(self):
        """empty(uint8Vector self) -> bool"""
        return _oalib.uint8Vector_empty(self)


    def size(self):
        """size(uint8Vector self) -> std::vector< unsigned char >::size_type"""
        return _oalib.uint8Vector_size(self)


    def swap(self, v):
        """swap(uint8Vector self, uint8Vector v)"""
        return _oalib.uint8Vector_swap(self, v)


    def begin(self):
        """begin(uint8Vector self) -> std::vector< unsigned char >::iterator"""
        return _oalib.uint8Vector_begin(self)


    def end(self):
        """end(uint8Vector self) -> std::vector< unsigned char >::iterator"""
        return _oalib.uint8Vector_end(self)


    def rbegin(self):
        """rbegin(uint8Vector self) -> std::vector< unsigned char >::reverse_iterator"""
        return _oalib.uint8Vector_rbegin(self)


    def rend(self):
        """rend(uint8Vector self) -> std::vector< unsigned char >::reverse_iterator"""
        return _oalib.uint8Vector_rend(self)


    def clear(self):
        """clear(uint8Vector self)"""
        return _oalib.uint8Vector_clear(self)


    def get_allocator(self):
        """get_allocator(uint8Vector self) -> std::vector< unsigned char >::allocator_type"""
        return _oalib.uint8Vector_get_allocator(self)


    def pop_back(self):
        """pop_back(uint8Vector self)"""
        return _oalib.uint8Vector_pop_back(self)


    def erase(self, *args):
        """
        erase(uint8Vector self, std::vector< unsigned char >::iterator pos) -> std::vector< unsigned char >::iterator
        erase(uint8Vector self, std::vector< unsigned char >::iterator first, std::vector< unsigned char >::iterator last) -> std::vector< unsigned char >::iterator
        """
        return _oalib.uint8Vector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(unsigned char)> self) -> uint8Vector
        __init__(std::vector<(unsigned char)> self, uint8Vector arg2) -> uint8Vector
        __init__(std::vector<(unsigned char)> self, std::vector< unsigned char >::size_type size) -> uint8Vector
        __init__(std::vector<(unsigned char)> self, std::vector< unsigned char >::size_type size, std::vector< unsigned char >::value_type const & value) -> uint8Vector
        """
        this = _oalib.new_uint8Vector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(uint8Vector self, std::vector< unsigned char >::value_type const & x)"""
        return _oalib.uint8Vector_push_back(self, x)


    def front(self):
        """front(uint8Vector self) -> std::vector< unsigned char >::value_type const &"""
        return _oalib.uint8Vector_front(self)


    def back(self):
        """back(uint8Vector self) -> std::vector< unsigned char >::value_type const &"""
        return _oalib.uint8Vector_back(self)


    def assign(self, n, x):
        """assign(uint8Vector self, std::vector< unsigned char >::size_type n, std::vector< unsigned char >::value_type const & x)"""
        return _oalib.uint8Vector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(uint8Vector self, std::vector< unsigned char >::size_type new_size)
        resize(uint8Vector self, std::vector< unsigned char >::size_type new_size, std::vector< unsigned char >::value_type const & x)
        """
        return _oalib.uint8Vector_resize(self, *args)


    def insert(self, *args):
        """
        insert(uint8Vector self, std::vector< unsigned char >::iterator pos, std::vector< unsigned char >::value_type const & x) -> std::vector< unsigned char >::iterator
        insert(uint8Vector self, std::vector< unsigned char >::iterator pos, std::vector< unsigned char >::size_type n, std::vector< unsigned char >::value_type const & x)
        """
        return _oalib.uint8Vector_insert(self, *args)


    def reserve(self, n):
        """reserve(uint8Vector self, std::vector< unsigned char >::size_type n)"""
        return _oalib.uint8Vector_reserve(self, n)


    def capacity(self):
        """capacity(uint8Vector self) -> std::vector< unsigned char >::size_type"""
        return _oalib.uint8Vector_capacity(self)

    __swig_destroy__ = _oalib.delete_uint8Vector
    __del__ = lambda self: None
uint8Vector_swigregister = _oalib.uint8Vector_swigregister
uint8Vector_swigregister(uint8Vector)

class charVector(object):
    """Proxy of C++ std::vector<(signed char)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(charVector self) -> SwigPyIterator"""
        return _oalib.charVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(charVector self) -> bool"""
        return _oalib.charVector___nonzero__(self)


    def __bool__(self):
        """__bool__(charVector self) -> bool"""
        return _oalib.charVector___bool__(self)


    def __len__(self):
        """__len__(charVector self) -> std::vector< signed char >::size_type"""
        return _oalib.charVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(charVector self, std::vector< signed char >::difference_type i, std::vector< signed char >::difference_type j) -> charVector"""
        return _oalib.charVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(charVector self, std::vector< signed char >::difference_type i, std::vector< signed char >::difference_type j)
        __setslice__(charVector self, std::vector< signed char >::difference_type i, std::vector< signed char >::difference_type j, charVector v)
        """
        return _oalib.charVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(charVector self, std::vector< signed char >::difference_type i, std::vector< signed char >::difference_type j)"""
        return _oalib.charVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(charVector self, std::vector< signed char >::difference_type i)
        __delitem__(charVector self, PySliceObject * slice)
        """
        return _oalib.charVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(charVector self, PySliceObject * slice) -> charVector
        __getitem__(charVector self, std::vector< signed char >::difference_type i) -> std::vector< signed char >::value_type const &
        """
        return _oalib.charVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(charVector self, PySliceObject * slice, charVector v)
        __setitem__(charVector self, PySliceObject * slice)
        __setitem__(charVector self, std::vector< signed char >::difference_type i, std::vector< signed char >::value_type const & x)
        """
        return _oalib.charVector___setitem__(self, *args)


    def pop(self):
        """pop(charVector self) -> std::vector< signed char >::value_type"""
        return _oalib.charVector_pop(self)


    def append(self, x):
        """append(charVector self, std::vector< signed char >::value_type const & x)"""
        return _oalib.charVector_append(self, x)


    def empty(self):
        """empty(charVector self) -> bool"""
        return _oalib.charVector_empty(self)


    def size(self):
        """size(charVector self) -> std::vector< signed char >::size_type"""
        return _oalib.charVector_size(self)


    def swap(self, v):
        """swap(charVector self, charVector v)"""
        return _oalib.charVector_swap(self, v)


    def begin(self):
        """begin(charVector self) -> std::vector< signed char >::iterator"""
        return _oalib.charVector_begin(self)


    def end(self):
        """end(charVector self) -> std::vector< signed char >::iterator"""
        return _oalib.charVector_end(self)


    def rbegin(self):
        """rbegin(charVector self) -> std::vector< signed char >::reverse_iterator"""
        return _oalib.charVector_rbegin(self)


    def rend(self):
        """rend(charVector self) -> std::vector< signed char >::reverse_iterator"""
        return _oalib.charVector_rend(self)


    def clear(self):
        """clear(charVector self)"""
        return _oalib.charVector_clear(self)


    def get_allocator(self):
        """get_allocator(charVector self) -> std::vector< signed char >::allocator_type"""
        return _oalib.charVector_get_allocator(self)


    def pop_back(self):
        """pop_back(charVector self)"""
        return _oalib.charVector_pop_back(self)


    def erase(self, *args):
        """
        erase(charVector self, std::vector< signed char >::iterator pos) -> std::vector< signed char >::iterator
        erase(charVector self, std::vector< signed char >::iterator first, std::vector< signed char >::iterator last) -> std::vector< signed char >::iterator
        """
        return _oalib.charVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(signed char)> self) -> charVector
        __init__(std::vector<(signed char)> self, charVector arg2) -> charVector
        __init__(std::vector<(signed char)> self, std::vector< signed char >::size_type size) -> charVector
        __init__(std::vector<(signed char)> self, std::vector< signed char >::size_type size, std::vector< signed char >::value_type const & value) -> charVector
        """
        this = _oalib.new_charVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(charVector self, std::vector< signed char >::value_type const & x)"""
        return _oalib.charVector_push_back(self, x)


    def front(self):
        """front(charVector self) -> std::vector< signed char >::value_type const &"""
        return _oalib.charVector_front(self)


    def back(self):
        """back(charVector self) -> std::vector< signed char >::value_type const &"""
        return _oalib.charVector_back(self)


    def assign(self, n, x):
        """assign(charVector self, std::vector< signed char >::size_type n, std::vector< signed char >::value_type const & x)"""
        return _oalib.charVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(charVector self, std::vector< signed char >::size_type new_size)
        resize(charVector self, std::vector< signed char >::size_type new_size, std::vector< signed char >::value_type const & x)
        """
        return _oalib.charVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(charVector self, std::vector< signed char >::iterator pos, std::vector< signed char >::value_type const & x) -> std::vector< signed char >::iterator
        insert(charVector self, std::vector< signed char >::iterator pos, std::vector< signed char >::size_type n, std::vector< signed char >::value_type const & x)
        """
        return _oalib.charVector_insert(self, *args)


    def reserve(self, n):
        """reserve(charVector self, std::vector< signed char >::size_type n)"""
        return _oalib.charVector_reserve(self, n)


    def capacity(self):
        """capacity(charVector self) -> std::vector< signed char >::size_type"""
        return _oalib.charVector_capacity(self)

    __swig_destroy__ = _oalib.delete_charVector
    __del__ = lambda self: None
charVector_swigregister = _oalib.charVector_swigregister
charVector_swigregister(charVector)

class intVector(object):
    """Proxy of C++ std::vector<(int)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(intVector self) -> SwigPyIterator"""
        return _oalib.intVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(intVector self) -> bool"""
        return _oalib.intVector___nonzero__(self)


    def __bool__(self):
        """__bool__(intVector self) -> bool"""
        return _oalib.intVector___bool__(self)


    def __len__(self):
        """__len__(intVector self) -> std::vector< int >::size_type"""
        return _oalib.intVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(intVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j) -> intVector"""
        return _oalib.intVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(intVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)
        __setslice__(intVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j, intVector v)
        """
        return _oalib.intVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(intVector self, std::vector< int >::difference_type i, std::vector< int >::difference_type j)"""
        return _oalib.intVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(intVector self, std::vector< int >::difference_type i)
        __delitem__(intVector self, PySliceObject * slice)
        """
        return _oalib.intVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(intVector self, PySliceObject * slice) -> intVector
        __getitem__(intVector self, std::vector< int >::difference_type i) -> std::vector< int >::value_type const &
        """
        return _oalib.intVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(intVector self, PySliceObject * slice, intVector v)
        __setitem__(intVector self, PySliceObject * slice)
        __setitem__(intVector self, std::vector< int >::difference_type i, std::vector< int >::value_type const & x)
        """
        return _oalib.intVector___setitem__(self, *args)


    def pop(self):
        """pop(intVector self) -> std::vector< int >::value_type"""
        return _oalib.intVector_pop(self)


    def append(self, x):
        """append(intVector self, std::vector< int >::value_type const & x)"""
        return _oalib.intVector_append(self, x)


    def empty(self):
        """empty(intVector self) -> bool"""
        return _oalib.intVector_empty(self)


    def size(self):
        """size(intVector self) -> std::vector< int >::size_type"""
        return _oalib.intVector_size(self)


    def swap(self, v):
        """swap(intVector self, intVector v)"""
        return _oalib.intVector_swap(self, v)


    def begin(self):
        """begin(intVector self) -> std::vector< int >::iterator"""
        return _oalib.intVector_begin(self)


    def end(self):
        """end(intVector self) -> std::vector< int >::iterator"""
        return _oalib.intVector_end(self)


    def rbegin(self):
        """rbegin(intVector self) -> std::vector< int >::reverse_iterator"""
        return _oalib.intVector_rbegin(self)


    def rend(self):
        """rend(intVector self) -> std::vector< int >::reverse_iterator"""
        return _oalib.intVector_rend(self)


    def clear(self):
        """clear(intVector self)"""
        return _oalib.intVector_clear(self)


    def get_allocator(self):
        """get_allocator(intVector self) -> std::vector< int >::allocator_type"""
        return _oalib.intVector_get_allocator(self)


    def pop_back(self):
        """pop_back(intVector self)"""
        return _oalib.intVector_pop_back(self)


    def erase(self, *args):
        """
        erase(intVector self, std::vector< int >::iterator pos) -> std::vector< int >::iterator
        erase(intVector self, std::vector< int >::iterator first, std::vector< int >::iterator last) -> std::vector< int >::iterator
        """
        return _oalib.intVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(int)> self) -> intVector
        __init__(std::vector<(int)> self, intVector arg2) -> intVector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size) -> intVector
        __init__(std::vector<(int)> self, std::vector< int >::size_type size, std::vector< int >::value_type const & value) -> intVector
        """
        this = _oalib.new_intVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(intVector self, std::vector< int >::value_type const & x)"""
        return _oalib.intVector_push_back(self, x)


    def front(self):
        """front(intVector self) -> std::vector< int >::value_type const &"""
        return _oalib.intVector_front(self)


    def back(self):
        """back(intVector self) -> std::vector< int >::value_type const &"""
        return _oalib.intVector_back(self)


    def assign(self, n, x):
        """assign(intVector self, std::vector< int >::size_type n, std::vector< int >::value_type const & x)"""
        return _oalib.intVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(intVector self, std::vector< int >::size_type new_size)
        resize(intVector self, std::vector< int >::size_type new_size, std::vector< int >::value_type const & x)
        """
        return _oalib.intVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(intVector self, std::vector< int >::iterator pos, std::vector< int >::value_type const & x) -> std::vector< int >::iterator
        insert(intVector self, std::vector< int >::iterator pos, std::vector< int >::size_type n, std::vector< int >::value_type const & x)
        """
        return _oalib.intVector_insert(self, *args)


    def reserve(self, n):
        """reserve(intVector self, std::vector< int >::size_type n)"""
        return _oalib.intVector_reserve(self, n)


    def capacity(self):
        """capacity(intVector self) -> std::vector< int >::size_type"""
        return _oalib.intVector_capacity(self)

    __swig_destroy__ = _oalib.delete_intVector
    __del__ = lambda self: None
intVector_swigregister = _oalib.intVector_swigregister
intVector_swigregister(intVector)

class longVector(object):
    """Proxy of C++ std::vector<(long)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(longVector self) -> SwigPyIterator"""
        return _oalib.longVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(longVector self) -> bool"""
        return _oalib.longVector___nonzero__(self)


    def __bool__(self):
        """__bool__(longVector self) -> bool"""
        return _oalib.longVector___bool__(self)


    def __len__(self):
        """__len__(longVector self) -> std::vector< long >::size_type"""
        return _oalib.longVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(longVector self, std::vector< long >::difference_type i, std::vector< long >::difference_type j) -> longVector"""
        return _oalib.longVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(longVector self, std::vector< long >::difference_type i, std::vector< long >::difference_type j)
        __setslice__(longVector self, std::vector< long >::difference_type i, std::vector< long >::difference_type j, longVector v)
        """
        return _oalib.longVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(longVector self, std::vector< long >::difference_type i, std::vector< long >::difference_type j)"""
        return _oalib.longVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(longVector self, std::vector< long >::difference_type i)
        __delitem__(longVector self, PySliceObject * slice)
        """
        return _oalib.longVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(longVector self, PySliceObject * slice) -> longVector
        __getitem__(longVector self, std::vector< long >::difference_type i) -> std::vector< long >::value_type const &
        """
        return _oalib.longVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(longVector self, PySliceObject * slice, longVector v)
        __setitem__(longVector self, PySliceObject * slice)
        __setitem__(longVector self, std::vector< long >::difference_type i, std::vector< long >::value_type const & x)
        """
        return _oalib.longVector___setitem__(self, *args)


    def pop(self):
        """pop(longVector self) -> std::vector< long >::value_type"""
        return _oalib.longVector_pop(self)


    def append(self, x):
        """append(longVector self, std::vector< long >::value_type const & x)"""
        return _oalib.longVector_append(self, x)


    def empty(self):
        """empty(longVector self) -> bool"""
        return _oalib.longVector_empty(self)


    def size(self):
        """size(longVector self) -> std::vector< long >::size_type"""
        return _oalib.longVector_size(self)


    def swap(self, v):
        """swap(longVector self, longVector v)"""
        return _oalib.longVector_swap(self, v)


    def begin(self):
        """begin(longVector self) -> std::vector< long >::iterator"""
        return _oalib.longVector_begin(self)


    def end(self):
        """end(longVector self) -> std::vector< long >::iterator"""
        return _oalib.longVector_end(self)


    def rbegin(self):
        """rbegin(longVector self) -> std::vector< long >::reverse_iterator"""
        return _oalib.longVector_rbegin(self)


    def rend(self):
        """rend(longVector self) -> std::vector< long >::reverse_iterator"""
        return _oalib.longVector_rend(self)


    def clear(self):
        """clear(longVector self)"""
        return _oalib.longVector_clear(self)


    def get_allocator(self):
        """get_allocator(longVector self) -> std::vector< long >::allocator_type"""
        return _oalib.longVector_get_allocator(self)


    def pop_back(self):
        """pop_back(longVector self)"""
        return _oalib.longVector_pop_back(self)


    def erase(self, *args):
        """
        erase(longVector self, std::vector< long >::iterator pos) -> std::vector< long >::iterator
        erase(longVector self, std::vector< long >::iterator first, std::vector< long >::iterator last) -> std::vector< long >::iterator
        """
        return _oalib.longVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(long)> self) -> longVector
        __init__(std::vector<(long)> self, longVector arg2) -> longVector
        __init__(std::vector<(long)> self, std::vector< long >::size_type size) -> longVector
        __init__(std::vector<(long)> self, std::vector< long >::size_type size, std::vector< long >::value_type const & value) -> longVector
        """
        this = _oalib.new_longVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(longVector self, std::vector< long >::value_type const & x)"""
        return _oalib.longVector_push_back(self, x)


    def front(self):
        """front(longVector self) -> std::vector< long >::value_type const &"""
        return _oalib.longVector_front(self)


    def back(self):
        """back(longVector self) -> std::vector< long >::value_type const &"""
        return _oalib.longVector_back(self)


    def assign(self, n, x):
        """assign(longVector self, std::vector< long >::size_type n, std::vector< long >::value_type const & x)"""
        return _oalib.longVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(longVector self, std::vector< long >::size_type new_size)
        resize(longVector self, std::vector< long >::size_type new_size, std::vector< long >::value_type const & x)
        """
        return _oalib.longVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(longVector self, std::vector< long >::iterator pos, std::vector< long >::value_type const & x) -> std::vector< long >::iterator
        insert(longVector self, std::vector< long >::iterator pos, std::vector< long >::size_type n, std::vector< long >::value_type const & x)
        """
        return _oalib.longVector_insert(self, *args)


    def reserve(self, n):
        """reserve(longVector self, std::vector< long >::size_type n)"""
        return _oalib.longVector_reserve(self, n)


    def capacity(self):
        """capacity(longVector self) -> std::vector< long >::size_type"""
        return _oalib.longVector_capacity(self)

    __swig_destroy__ = _oalib.delete_longVector
    __del__ = lambda self: None
longVector_swigregister = _oalib.longVector_swigregister
longVector_swigregister(longVector)

class longDeque(object):
    """Proxy of C++ std::deque<(long)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(longDeque self) -> SwigPyIterator"""
        return _oalib.longDeque_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(longDeque self) -> bool"""
        return _oalib.longDeque___nonzero__(self)


    def __bool__(self):
        """__bool__(longDeque self) -> bool"""
        return _oalib.longDeque___bool__(self)


    def __len__(self):
        """__len__(longDeque self) -> std::deque< long >::size_type"""
        return _oalib.longDeque___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(longDeque self, std::deque< long >::difference_type i, std::deque< long >::difference_type j) -> longDeque"""
        return _oalib.longDeque___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(longDeque self, std::deque< long >::difference_type i, std::deque< long >::difference_type j)
        __setslice__(longDeque self, std::deque< long >::difference_type i, std::deque< long >::difference_type j, longDeque v)
        """
        return _oalib.longDeque___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(longDeque self, std::deque< long >::difference_type i, std::deque< long >::difference_type j)"""
        return _oalib.longDeque___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(longDeque self, std::deque< long >::difference_type i)
        __delitem__(longDeque self, PySliceObject * slice)
        """
        return _oalib.longDeque___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(longDeque self, PySliceObject * slice) -> longDeque
        __getitem__(longDeque self, std::deque< long >::difference_type i) -> std::deque< long >::value_type const &
        """
        return _oalib.longDeque___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(longDeque self, PySliceObject * slice, longDeque v)
        __setitem__(longDeque self, PySliceObject * slice)
        __setitem__(longDeque self, std::deque< long >::difference_type i, std::deque< long >::value_type const & x)
        """
        return _oalib.longDeque___setitem__(self, *args)


    def pop(self):
        """pop(longDeque self) -> std::deque< long >::value_type"""
        return _oalib.longDeque_pop(self)


    def append(self, x):
        """append(longDeque self, std::deque< long >::value_type const & x)"""
        return _oalib.longDeque_append(self, x)


    def empty(self):
        """empty(longDeque self) -> bool"""
        return _oalib.longDeque_empty(self)


    def size(self):
        """size(longDeque self) -> std::deque< long >::size_type"""
        return _oalib.longDeque_size(self)


    def swap(self, v):
        """swap(longDeque self, longDeque v)"""
        return _oalib.longDeque_swap(self, v)


    def begin(self):
        """begin(longDeque self) -> std::deque< long >::iterator"""
        return _oalib.longDeque_begin(self)


    def end(self):
        """end(longDeque self) -> std::deque< long >::iterator"""
        return _oalib.longDeque_end(self)


    def rbegin(self):
        """rbegin(longDeque self) -> std::deque< long >::reverse_iterator"""
        return _oalib.longDeque_rbegin(self)


    def rend(self):
        """rend(longDeque self) -> std::deque< long >::reverse_iterator"""
        return _oalib.longDeque_rend(self)


    def clear(self):
        """clear(longDeque self)"""
        return _oalib.longDeque_clear(self)


    def get_allocator(self):
        """get_allocator(longDeque self) -> std::deque< long >::allocator_type"""
        return _oalib.longDeque_get_allocator(self)


    def pop_back(self):
        """pop_back(longDeque self)"""
        return _oalib.longDeque_pop_back(self)


    def erase(self, *args):
        """
        erase(longDeque self, std::deque< long >::iterator pos) -> std::deque< long >::iterator
        erase(longDeque self, std::deque< long >::iterator first, std::deque< long >::iterator last) -> std::deque< long >::iterator
        """
        return _oalib.longDeque_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::deque<(long)> self) -> longDeque
        __init__(std::deque<(long)> self, longDeque arg2) -> longDeque
        __init__(std::deque<(long)> self, std::deque< long >::size_type size) -> longDeque
        __init__(std::deque<(long)> self, std::deque< long >::size_type size, std::deque< long >::value_type const & value) -> longDeque
        """
        this = _oalib.new_longDeque(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(longDeque self, std::deque< long >::value_type const & x)"""
        return _oalib.longDeque_push_back(self, x)


    def front(self):
        """front(longDeque self) -> std::deque< long >::value_type const &"""
        return _oalib.longDeque_front(self)


    def back(self):
        """back(longDeque self) -> std::deque< long >::value_type const &"""
        return _oalib.longDeque_back(self)


    def assign(self, n, x):
        """assign(longDeque self, std::deque< long >::size_type n, std::deque< long >::value_type const & x)"""
        return _oalib.longDeque_assign(self, n, x)


    def resize(self, *args):
        """
        resize(longDeque self, std::deque< long >::size_type new_size)
        resize(longDeque self, std::deque< long >::size_type new_size, std::deque< long >::value_type const & x)
        """
        return _oalib.longDeque_resize(self, *args)


    def insert(self, *args):
        """
        insert(longDeque self, std::deque< long >::iterator pos, std::deque< long >::value_type const & x) -> std::deque< long >::iterator
        insert(longDeque self, std::deque< long >::iterator pos, std::deque< long >::size_type n, std::deque< long >::value_type const & x)
        """
        return _oalib.longDeque_insert(self, *args)


    def pop_front(self):
        """pop_front(longDeque self)"""
        return _oalib.longDeque_pop_front(self)


    def push_front(self, x):
        """push_front(longDeque self, std::deque< long >::value_type const & x)"""
        return _oalib.longDeque_push_front(self, x)

    __swig_destroy__ = _oalib.delete_longDeque
    __del__ = lambda self: None
longDeque_swigregister = _oalib.longDeque_swigregister
longDeque_swigregister(longDeque)

class doubleVector(object):
    """Proxy of C++ std::vector<(double)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(doubleVector self) -> SwigPyIterator"""
        return _oalib.doubleVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(doubleVector self) -> bool"""
        return _oalib.doubleVector___nonzero__(self)


    def __bool__(self):
        """__bool__(doubleVector self) -> bool"""
        return _oalib.doubleVector___bool__(self)


    def __len__(self):
        """__len__(doubleVector self) -> std::vector< double >::size_type"""
        return _oalib.doubleVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(doubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j) -> doubleVector"""
        return _oalib.doubleVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(doubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)
        __setslice__(doubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j, doubleVector v)
        """
        return _oalib.doubleVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(doubleVector self, std::vector< double >::difference_type i, std::vector< double >::difference_type j)"""
        return _oalib.doubleVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(doubleVector self, std::vector< double >::difference_type i)
        __delitem__(doubleVector self, PySliceObject * slice)
        """
        return _oalib.doubleVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(doubleVector self, PySliceObject * slice) -> doubleVector
        __getitem__(doubleVector self, std::vector< double >::difference_type i) -> std::vector< double >::value_type const &
        """
        return _oalib.doubleVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(doubleVector self, PySliceObject * slice, doubleVector v)
        __setitem__(doubleVector self, PySliceObject * slice)
        __setitem__(doubleVector self, std::vector< double >::difference_type i, std::vector< double >::value_type const & x)
        """
        return _oalib.doubleVector___setitem__(self, *args)


    def pop(self):
        """pop(doubleVector self) -> std::vector< double >::value_type"""
        return _oalib.doubleVector_pop(self)


    def append(self, x):
        """append(doubleVector self, std::vector< double >::value_type const & x)"""
        return _oalib.doubleVector_append(self, x)


    def empty(self):
        """empty(doubleVector self) -> bool"""
        return _oalib.doubleVector_empty(self)


    def size(self):
        """size(doubleVector self) -> std::vector< double >::size_type"""
        return _oalib.doubleVector_size(self)


    def swap(self, v):
        """swap(doubleVector self, doubleVector v)"""
        return _oalib.doubleVector_swap(self, v)


    def begin(self):
        """begin(doubleVector self) -> std::vector< double >::iterator"""
        return _oalib.doubleVector_begin(self)


    def end(self):
        """end(doubleVector self) -> std::vector< double >::iterator"""
        return _oalib.doubleVector_end(self)


    def rbegin(self):
        """rbegin(doubleVector self) -> std::vector< double >::reverse_iterator"""
        return _oalib.doubleVector_rbegin(self)


    def rend(self):
        """rend(doubleVector self) -> std::vector< double >::reverse_iterator"""
        return _oalib.doubleVector_rend(self)


    def clear(self):
        """clear(doubleVector self)"""
        return _oalib.doubleVector_clear(self)


    def get_allocator(self):
        """get_allocator(doubleVector self) -> std::vector< double >::allocator_type"""
        return _oalib.doubleVector_get_allocator(self)


    def pop_back(self):
        """pop_back(doubleVector self)"""
        return _oalib.doubleVector_pop_back(self)


    def erase(self, *args):
        """
        erase(doubleVector self, std::vector< double >::iterator pos) -> std::vector< double >::iterator
        erase(doubleVector self, std::vector< double >::iterator first, std::vector< double >::iterator last) -> std::vector< double >::iterator
        """
        return _oalib.doubleVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(double)> self) -> doubleVector
        __init__(std::vector<(double)> self, doubleVector arg2) -> doubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size) -> doubleVector
        __init__(std::vector<(double)> self, std::vector< double >::size_type size, std::vector< double >::value_type const & value) -> doubleVector
        """
        this = _oalib.new_doubleVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(doubleVector self, std::vector< double >::value_type const & x)"""
        return _oalib.doubleVector_push_back(self, x)


    def front(self):
        """front(doubleVector self) -> std::vector< double >::value_type const &"""
        return _oalib.doubleVector_front(self)


    def back(self):
        """back(doubleVector self) -> std::vector< double >::value_type const &"""
        return _oalib.doubleVector_back(self)


    def assign(self, n, x):
        """assign(doubleVector self, std::vector< double >::size_type n, std::vector< double >::value_type const & x)"""
        return _oalib.doubleVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(doubleVector self, std::vector< double >::size_type new_size)
        resize(doubleVector self, std::vector< double >::size_type new_size, std::vector< double >::value_type const & x)
        """
        return _oalib.doubleVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(doubleVector self, std::vector< double >::iterator pos, std::vector< double >::value_type const & x) -> std::vector< double >::iterator
        insert(doubleVector self, std::vector< double >::iterator pos, std::vector< double >::size_type n, std::vector< double >::value_type const & x)
        """
        return _oalib.doubleVector_insert(self, *args)


    def reserve(self, n):
        """reserve(doubleVector self, std::vector< double >::size_type n)"""
        return _oalib.doubleVector_reserve(self, n)


    def capacity(self):
        """capacity(doubleVector self) -> std::vector< double >::size_type"""
        return _oalib.doubleVector_capacity(self)

    __swig_destroy__ = _oalib.delete_doubleVector
    __del__ = lambda self: None
doubleVector_swigregister = _oalib.doubleVector_swigregister
doubleVector_swigregister(doubleVector)

class stringVector(object):
    """Proxy of C++ std::vector<(std::string)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(stringVector self) -> SwigPyIterator"""
        return _oalib.stringVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(stringVector self) -> bool"""
        return _oalib.stringVector___nonzero__(self)


    def __bool__(self):
        """__bool__(stringVector self) -> bool"""
        return _oalib.stringVector___bool__(self)


    def __len__(self):
        """__len__(stringVector self) -> std::vector< std::string >::size_type"""
        return _oalib.stringVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(stringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j) -> stringVector"""
        return _oalib.stringVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(stringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)
        __setslice__(stringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j, stringVector v)
        """
        return _oalib.stringVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(stringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::difference_type j)"""
        return _oalib.stringVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(stringVector self, std::vector< std::string >::difference_type i)
        __delitem__(stringVector self, PySliceObject * slice)
        """
        return _oalib.stringVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(stringVector self, PySliceObject * slice) -> stringVector
        __getitem__(stringVector self, std::vector< std::string >::difference_type i) -> std::vector< std::string >::value_type const &
        """
        return _oalib.stringVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(stringVector self, PySliceObject * slice, stringVector v)
        __setitem__(stringVector self, PySliceObject * slice)
        __setitem__(stringVector self, std::vector< std::string >::difference_type i, std::vector< std::string >::value_type const & x)
        """
        return _oalib.stringVector___setitem__(self, *args)


    def pop(self):
        """pop(stringVector self) -> std::vector< std::string >::value_type"""
        return _oalib.stringVector_pop(self)


    def append(self, x):
        """append(stringVector self, std::vector< std::string >::value_type const & x)"""
        return _oalib.stringVector_append(self, x)


    def empty(self):
        """empty(stringVector self) -> bool"""
        return _oalib.stringVector_empty(self)


    def size(self):
        """size(stringVector self) -> std::vector< std::string >::size_type"""
        return _oalib.stringVector_size(self)


    def swap(self, v):
        """swap(stringVector self, stringVector v)"""
        return _oalib.stringVector_swap(self, v)


    def begin(self):
        """begin(stringVector self) -> std::vector< std::string >::iterator"""
        return _oalib.stringVector_begin(self)


    def end(self):
        """end(stringVector self) -> std::vector< std::string >::iterator"""
        return _oalib.stringVector_end(self)


    def rbegin(self):
        """rbegin(stringVector self) -> std::vector< std::string >::reverse_iterator"""
        return _oalib.stringVector_rbegin(self)


    def rend(self):
        """rend(stringVector self) -> std::vector< std::string >::reverse_iterator"""
        return _oalib.stringVector_rend(self)


    def clear(self):
        """clear(stringVector self)"""
        return _oalib.stringVector_clear(self)


    def get_allocator(self):
        """get_allocator(stringVector self) -> std::vector< std::string >::allocator_type"""
        return _oalib.stringVector_get_allocator(self)


    def pop_back(self):
        """pop_back(stringVector self)"""
        return _oalib.stringVector_pop_back(self)


    def erase(self, *args):
        """
        erase(stringVector self, std::vector< std::string >::iterator pos) -> std::vector< std::string >::iterator
        erase(stringVector self, std::vector< std::string >::iterator first, std::vector< std::string >::iterator last) -> std::vector< std::string >::iterator
        """
        return _oalib.stringVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::string)> self) -> stringVector
        __init__(std::vector<(std::string)> self, stringVector arg2) -> stringVector
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size) -> stringVector
        __init__(std::vector<(std::string)> self, std::vector< std::string >::size_type size, std::vector< std::string >::value_type const & value) -> stringVector
        """
        this = _oalib.new_stringVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(stringVector self, std::vector< std::string >::value_type const & x)"""
        return _oalib.stringVector_push_back(self, x)


    def front(self):
        """front(stringVector self) -> std::vector< std::string >::value_type const &"""
        return _oalib.stringVector_front(self)


    def back(self):
        """back(stringVector self) -> std::vector< std::string >::value_type const &"""
        return _oalib.stringVector_back(self)


    def assign(self, n, x):
        """assign(stringVector self, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)"""
        return _oalib.stringVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(stringVector self, std::vector< std::string >::size_type new_size)
        resize(stringVector self, std::vector< std::string >::size_type new_size, std::vector< std::string >::value_type const & x)
        """
        return _oalib.stringVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(stringVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::value_type const & x) -> std::vector< std::string >::iterator
        insert(stringVector self, std::vector< std::string >::iterator pos, std::vector< std::string >::size_type n, std::vector< std::string >::value_type const & x)
        """
        return _oalib.stringVector_insert(self, *args)


    def reserve(self, n):
        """reserve(stringVector self, std::vector< std::string >::size_type n)"""
        return _oalib.stringVector_reserve(self, n)


    def capacity(self):
        """capacity(stringVector self) -> std::vector< std::string >::size_type"""
        return _oalib.stringVector_capacity(self)

    __swig_destroy__ = _oalib.delete_stringVector
    __del__ = lambda self: None
stringVector_swigregister = _oalib.stringVector_swigregister
stringVector_swigregister(stringVector)

class map_int_long(object):
    """Proxy of C++ std::map<(int,long)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(map_int_long self) -> SwigPyIterator"""
        return _oalib.map_int_long_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(map_int_long self) -> bool"""
        return _oalib.map_int_long___nonzero__(self)


    def __bool__(self):
        """__bool__(map_int_long self) -> bool"""
        return _oalib.map_int_long___bool__(self)


    def __len__(self):
        """__len__(map_int_long self) -> std::map< int,long >::size_type"""
        return _oalib.map_int_long___len__(self)

    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        """__getitem__(map_int_long self, std::map< int,long >::key_type const & key) -> std::map< int,long >::mapped_type const &"""
        return _oalib.map_int_long___getitem__(self, key)


    def __delitem__(self, key):
        """__delitem__(map_int_long self, std::map< int,long >::key_type const & key)"""
        return _oalib.map_int_long___delitem__(self, key)


    def has_key(self, key):
        """has_key(map_int_long self, std::map< int,long >::key_type const & key) -> bool"""
        return _oalib.map_int_long_has_key(self, key)


    def keys(self):
        """keys(map_int_long self) -> PyObject *"""
        return _oalib.map_int_long_keys(self)


    def values(self):
        """values(map_int_long self) -> PyObject *"""
        return _oalib.map_int_long_values(self)


    def items(self):
        """items(map_int_long self) -> PyObject *"""
        return _oalib.map_int_long_items(self)


    def __contains__(self, key):
        """__contains__(map_int_long self, std::map< int,long >::key_type const & key) -> bool"""
        return _oalib.map_int_long___contains__(self, key)


    def key_iterator(self):
        """key_iterator(map_int_long self) -> SwigPyIterator"""
        return _oalib.map_int_long_key_iterator(self)


    def value_iterator(self):
        """value_iterator(map_int_long self) -> SwigPyIterator"""
        return _oalib.map_int_long_value_iterator(self)


    def __setitem__(self, *args):
        """
        __setitem__(map_int_long self, std::map< int,long >::key_type const & key)
        __setitem__(map_int_long self, std::map< int,long >::key_type const & key, std::map< int,long >::mapped_type const & x)
        """
        return _oalib.map_int_long___setitem__(self, *args)


    def asdict(self):
        """asdict(map_int_long self) -> PyObject *"""
        return _oalib.map_int_long_asdict(self)


    def __init__(self, *args):
        """
        __init__(std::map<(int,long)> self, std::less< int > const & arg2) -> map_int_long
        __init__(std::map<(int,long)> self) -> map_int_long
        __init__(std::map<(int,long)> self, map_int_long arg2) -> map_int_long
        """
        this = _oalib.new_map_int_long(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self):
        """empty(map_int_long self) -> bool"""
        return _oalib.map_int_long_empty(self)


    def size(self):
        """size(map_int_long self) -> std::map< int,long >::size_type"""
        return _oalib.map_int_long_size(self)


    def swap(self, v):
        """swap(map_int_long self, map_int_long v)"""
        return _oalib.map_int_long_swap(self, v)


    def begin(self):
        """begin(map_int_long self) -> std::map< int,long >::iterator"""
        return _oalib.map_int_long_begin(self)


    def end(self):
        """end(map_int_long self) -> std::map< int,long >::iterator"""
        return _oalib.map_int_long_end(self)


    def rbegin(self):
        """rbegin(map_int_long self) -> std::map< int,long >::reverse_iterator"""
        return _oalib.map_int_long_rbegin(self)


    def rend(self):
        """rend(map_int_long self) -> std::map< int,long >::reverse_iterator"""
        return _oalib.map_int_long_rend(self)


    def clear(self):
        """clear(map_int_long self)"""
        return _oalib.map_int_long_clear(self)


    def get_allocator(self):
        """get_allocator(map_int_long self) -> std::map< int,long >::allocator_type"""
        return _oalib.map_int_long_get_allocator(self)


    def count(self, x):
        """count(map_int_long self, std::map< int,long >::key_type const & x) -> std::map< int,long >::size_type"""
        return _oalib.map_int_long_count(self, x)


    def erase(self, *args):
        """
        erase(map_int_long self, std::map< int,long >::key_type const & x) -> std::map< int,long >::size_type
        erase(map_int_long self, std::map< int,long >::iterator position)
        erase(map_int_long self, std::map< int,long >::iterator first, std::map< int,long >::iterator last)
        """
        return _oalib.map_int_long_erase(self, *args)


    def find(self, x):
        """find(map_int_long self, std::map< int,long >::key_type const & x) -> std::map< int,long >::iterator"""
        return _oalib.map_int_long_find(self, x)


    def lower_bound(self, x):
        """lower_bound(map_int_long self, std::map< int,long >::key_type const & x) -> std::map< int,long >::iterator"""
        return _oalib.map_int_long_lower_bound(self, x)


    def upper_bound(self, x):
        """upper_bound(map_int_long self, std::map< int,long >::key_type const & x) -> std::map< int,long >::iterator"""
        return _oalib.map_int_long_upper_bound(self, x)

    __swig_destroy__ = _oalib.delete_map_int_long
    __del__ = lambda self: None
map_int_long_swigregister = _oalib.map_int_long_swigregister
map_int_long_swigregister(map_int_long)


import numpy

MAXCOLS = _oalib.MAXCOLS
MAXROWS = _oalib.MAXROWS
OACHECK = _oalib.OACHECK
FREQELEM = _oalib.FREQELEM
SYMMBLOCKS = _oalib.SYMMBLOCKS
TPLUSCOLUMN = _oalib.TPLUSCOLUMN
oacolSortName = _oalib.oacolSortName

def compile_information():
    """
    compile_information() -> std::string



    Print the compile-time options to string.  

    Returns
    -------
    String with compile time information  

    """
    return _oalib.compile_information()

def version():
    """
    version() -> std::string



    Print version.  

    """
    return _oalib.version()

def print_copyright():
    """
    print_copyright()



    Print copyright statement.  

    """
    return _oalib.print_copyright()

def print_copyright_light():
    """
    print_copyright_light()



    Print copyright statement.  

    """
    return _oalib.print_copyright_light()

def print_options(*args):
    """
    print_options(std::ostream & output_stream)
    print_options()



    Print compile time options to stdout.  

    """
    return _oalib.print_options(*args)

def oadevelop():
    """
    oadevelop() -> int



    """
    return _oalib.oadevelop()
class Combinations(object):
    """


    C++ includes: mathtools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    __swig_destroy__ = _oalib.delete_Combinations
    __del__ = lambda self: None

    def number_combinations_max_n():
        """
        number_combinations_max_n() -> int



        return max number of N that can be calculated with number_combinations  

        """
        return _oalib.Combinations_number_combinations_max_n()

    number_combinations_max_n = staticmethod(number_combinations_max_n)

    def initialize_number_combinations(N):
        """
        initialize_number_combinations(int N)



        initialize datastructure for number_combinations, this function is not thread
        safe  

        """
        return _oalib.Combinations_initialize_number_combinations(N)

    initialize_number_combinations = staticmethod(initialize_number_combinations)

    def number_combinations(n, k):
        """
        number_combinations(int n, int k) -> long



        Return number of combinations from previously calculated results  

        The results should be initialized with initialize_number_combinations  

        """
        return _oalib.Combinations_number_combinations(n, k)

    number_combinations = staticmethod(number_combinations)

    def __init__(self):
        """
        __init__(Combinations self) -> Combinations



        C++ includes: mathtools.h

        """
        this = _oalib.new_Combinations()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Combinations_swigregister = _oalib.Combinations_swigregister
Combinations_swigregister(Combinations)

def Combinations_number_combinations_max_n():
    """
    Combinations_number_combinations_max_n() -> int



    return max number of N that can be calculated with number_combinations  

    """
    return _oalib.Combinations_number_combinations_max_n()

def Combinations_initialize_number_combinations(N):
    """
    Combinations_initialize_number_combinations(int N)



    initialize datastructure for number_combinations, this function is not thread
    safe  

    """
    return _oalib.Combinations_initialize_number_combinations(N)

def Combinations_number_combinations(n, k):
    """
    Combinations_number_combinations(int n, int k) -> long



    Return number of combinations from previously calculated results  

    The results should be initialized with initialize_number_combinations  

    """
    return _oalib.Combinations_number_combinations(n, k)


def fastrand():
    """
    fastrand() -> int



    """
    return _oalib.fastrand()

def seedfastrand(s):
    """
    seedfastrand(int s)



    """
    return _oalib.seedfastrand(s)

def fastrandK(k):
    """
    fastrandK(int k) -> int



    """
    return _oalib.fastrandK(k)

def set_srand(s):
    """
    set_srand(unsigned int s)



    seed the C rand method with the srand function  

    """
    return _oalib.set_srand(s)
class indexsort(object):
    """


    Class to sort data without moving the data in memory.  

    The data is sorted by using a list of indices. A stable sort is being used.  

    C++ includes: mathtools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    indices = _swig_property(_oalib.indexsort_indices_get, _oalib.indexsort_indices_set)

    def __init__(self, nn):
        """
        __init__(indexsort self, int nn) -> indexsort



        Constructor for vector class.  

        """
        this = _oalib.new_indexsort(nn)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def show(self):
        """
        show(indexsort self)



        """
        return _oalib.indexsort_show(self)


    def issorted(self):
        """
        issorted(indexsort self) -> bool



        Returns true of the data is sorted ascending.  

        """
        return _oalib.indexsort_issorted(self)


    def issorteddescending(self):
        """
        issorteddescending(indexsort self) -> bool



        Returns true of the data is sorted descending.  

        """
        return _oalib.indexsort_issorteddescending(self)

    __swig_destroy__ = _oalib.delete_indexsort
    __del__ = lambda self: None
indexsort_swigregister = _oalib.indexsort_swigregister
indexsort_swigregister(indexsort)

class symmetry_group(object):
    """


    Class to describe the symmetry group of a list of elements.  

    The class assumes the list is sorted. The symmetry group is then a direct
    product of full permutation groups.  

    We do not implement this using templates because we want to export to Python.  

    C++ includes: mathtools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    gidx = _swig_property(_oalib.symmetry_group_gidx_get, _oalib.symmetry_group_gidx_set)
    gstart = _swig_property(_oalib.symmetry_group_gstart_get, _oalib.symmetry_group_gstart_set)
    gsize = _swig_property(_oalib.symmetry_group_gsize_get, _oalib.symmetry_group_gsize_set)
    ngroups = _swig_property(_oalib.symmetry_group_ngroups_get, _oalib.symmetry_group_ngroups_set)
    n = _swig_property(_oalib.symmetry_group_n_get, _oalib.symmetry_group_n_set)
    ascending = _swig_property(_oalib.symmetry_group_ascending_get, _oalib.symmetry_group_ascending_set)

    def __init__(self, *args):
        """
        __init__(symmetry_group self, intVector vals, bool ascending=True, int verbose=0) -> symmetry_group
        __init__(symmetry_group self, intVector vals, bool ascending=True) -> symmetry_group
        __init__(symmetry_group self, intVector vals) -> symmetry_group
        __init__(symmetry_group self, doubleVector vals, bool ascending=True, int verbose=0) -> symmetry_group
        __init__(symmetry_group self, doubleVector vals, bool ascending=True) -> symmetry_group
        __init__(symmetry_group self, doubleVector vals) -> symmetry_group
        __init__(symmetry_group self, std::vector< float,std::allocator< float > > const & vals, bool ascending=True, int verbose=0) -> symmetry_group
        __init__(symmetry_group self, std::vector< float,std::allocator< float > > const & vals, bool ascending=True) -> symmetry_group
        __init__(symmetry_group self, std::vector< float,std::allocator< float > > const & vals) -> symmetry_group
        __init__(symmetry_group self, std::vector< short,std::allocator< short > > const & vals, bool ascending=True, int verbose=0) -> symmetry_group
        __init__(symmetry_group self, std::vector< short,std::allocator< short > > const & vals, bool ascending=True) -> symmetry_group
        __init__(symmetry_group self, std::vector< short,std::allocator< short > > const & vals) -> symmetry_group
        __init__(symmetry_group self, std::vector< unsigned int,std::allocator< unsigned int > > const & vals, bool ascending=True, int verbose=0) -> symmetry_group
        __init__(symmetry_group self, std::vector< unsigned int,std::allocator< unsigned int > > const & vals, bool ascending=True) -> symmetry_group
        __init__(symmetry_group self, std::vector< unsigned int,std::allocator< unsigned int > > const & vals) -> symmetry_group
        __init__(symmetry_group self, vector_mvalue_t_double vals, bool ascending=True, int verbose=0) -> symmetry_group
        __init__(symmetry_group self, vector_mvalue_t_double vals, bool ascending=True) -> symmetry_group
        __init__(symmetry_group self, vector_mvalue_t_double vals) -> symmetry_group
        __init__(symmetry_group self, vector_mvalue_t_int vals, bool ascending=True, int verbose=0) -> symmetry_group
        __init__(symmetry_group self, vector_mvalue_t_int vals, bool ascending=True) -> symmetry_group
        __init__(symmetry_group self, vector_mvalue_t_int vals) -> symmetry_group
        __init__(symmetry_group self, symmetry_group sgx) -> symmetry_group
        __init__(symmetry_group self) -> symmetry_group



        default constructor  

        """
        this = _oalib.new_symmetry_group(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def permsize(self):
        """
        permsize(symmetry_group self) -> symmetry_group::perm_return_type



        Return size of the group of all permutations respecting the symmetry  

        The return type can overflow quickly. For larger group sizes use permsize_large  

        """
        return _oalib.symmetry_group_permsize(self)


    def permsize_large(self):
        """
        permsize_large(symmetry_group self) -> InfInt



        return size of the group of all permutations respecting the symmetry  

        """
        return _oalib.symmetry_group_permsize_large(self)


    def checkIndices(self):
        """
        checkIndices(symmetry_group self) -> intVector



        list with indices set to check for symmetry reductions  

        """
        return _oalib.symmetry_group_checkIndices(self)


    def __repr__(self):
        """
        __repr__(symmetry_group self) -> std::string



        representation function (for python interface)  

        """
        return _oalib.symmetry_group___repr__(self)


    def show(self, verbose=1):
        """
        show(symmetry_group self, int verbose=1)
        show(symmetry_group self)



        show the symmetry group  

        """
        return _oalib.symmetry_group_show(self, verbose)

    __swig_destroy__ = _oalib.delete_symmetry_group
    __del__ = lambda self: None
symmetry_group_swigregister = _oalib.symmetry_group_swigregister
symmetry_group_swigregister(symmetry_group)

class symmetry_group_walker(object):
    """


    Class to walk over all elements of a symmetry group  

    The elements are generated by walking over all product permutations.  

    C++ includes: mathtools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    sg = _swig_property(_oalib.symmetry_group_walker_sg_get, _oalib.symmetry_group_walker_sg_set)
    perms = _swig_property(_oalib.symmetry_group_walker_perms_get, _oalib.symmetry_group_walker_perms_set)

    def __init__(self, sg):
        """
        __init__(symmetry_group_walker self, symmetry_group sg) -> symmetry_group_walker



        """
        this = _oalib.new_symmetry_group_walker(sg)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def show(self, verbose=1):
        """
        show(symmetry_group_walker self, int verbose=1)
        show(symmetry_group_walker self)



        show all elements in the symmetry group  

        """
        return _oalib.symmetry_group_walker_show(self, verbose)


    def next(self):
        """
        next(symmetry_group_walker self) -> bool



        go to next element of the symmetry group  

        """
        return _oalib.symmetry_group_walker_next(self)


    def fullperm(self):
        """
        fullperm(symmetry_group_walker self) -> intVector



        return the full permutation corresponding to the current permutation in the
        walker  

        """
        return _oalib.symmetry_group_walker_fullperm(self)

    __swig_destroy__ = _oalib.delete_symmetry_group_walker
    __del__ = lambda self: None
symmetry_group_walker_swigregister = _oalib.symmetry_group_walker_swigregister
symmetry_group_walker_swigregister(symmetry_group_walker)


def ipow(*args):
    """
    ipow(long x, long y) -> long
    ipow(unsigned int x, unsigned int p) -> unsigned int



    Power of two unsigned integers.  

    """
    return _oalib.ipow(*args)

def power_minus_one(*args):
    """
    power_minus_one(int n) -> int
    power_minus_one(long n) -> long



    -1 to the power n (integer)  

    """
    return _oalib.power_minus_one(*args)

def throw_runtime_exception(exception_message):
    """
    throw_runtime_exception(std::string const exception_message)



    Throw a runtime_error exception with specified error message  

    This exception is caught in the SWIG interface.  

    """
    return _oalib.throw_runtime_exception(exception_message)

def eigenInfo(*args):
    """
    eigenInfo(MatrixFloat const m, char const * str, int verbose=1)
    eigenInfo(MatrixFloat const m, char const * str)
    eigenInfo(MatrixFloat const m)
    """
    return _oalib.eigenInfo(*args)

def print_eigen_matrix(matrix):
    """print_eigen_matrix(MatrixFloat const matrix)"""
    return _oalib.print_eigen_matrix(matrix)

def eigen2numpyHelper(pymat1, n, m):
    """eigen2numpyHelper(double * pymat1, int n, MatrixFloat const & m)"""
    return _oalib.eigen2numpyHelper(pymat1, n, m)

def sizeof_array_t():
    """sizeof_array_t() -> int"""
    return _oalib.sizeof_array_t()

def possible_F_values(N, strength):
    """possible_F_values(int N, int strength) -> intVector"""
    return _oalib.possible_F_values(N, strength)

def file_exists(*args):
    """
    file_exists(std::string const filename) -> bool
    file_exists(char const * filename) -> bool
    """
    return _oalib.file_exists(*args)

def oa_file_exists(*args):
    """
    oa_file_exists(char const * filename) -> bool
    oa_file_exists(std::string const filename) -> bool
    """
    return _oalib.oa_file_exists(*args)
ORDER_LEX = _oalib.ORDER_LEX
ORDER_J5 = _oalib.ORDER_J5
class arraydata_t(object):
    """


    Specifies a class of arrays.  

    The specification includes the number of rows, number of columns, factor levels
    and strength.  

    C++ includes: arraytools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    N = _swig_property(_oalib.arraydata_t_N_get, _oalib.arraydata_t_N_set)
    ncols = _swig_property(_oalib.arraydata_t_ncols_get, _oalib.arraydata_t_ncols_set)
    strength = _swig_property(_oalib.arraydata_t_strength_get, _oalib.arraydata_t_strength_set)
    s = _swig_property(_oalib.arraydata_t_s_get, _oalib.arraydata_t_s_set)
    order = _swig_property(_oalib.arraydata_t_order_get, _oalib.arraydata_t_order_set)
    ncolgroups = _swig_property(_oalib.arraydata_t_ncolgroups_get, _oalib.arraydata_t_ncolgroups_set)
    colgroupindex = _swig_property(_oalib.arraydata_t_colgroupindex_get, _oalib.arraydata_t_colgroupindex_set)
    colgroupsize = _swig_property(_oalib.arraydata_t_colgroupsize_get, _oalib.arraydata_t_colgroupsize_set)
    oaindex = _swig_property(_oalib.arraydata_t_oaindex_get, _oalib.arraydata_t_oaindex_set)

    def __init__(self, *args):
        """
        __init__(arraydata_t self) -> arraydata_t
        __init__(arraydata_t self, array_t s, rowindex_t N, colindex_t strength, colindex_t ncols) -> arraydata_t
        __init__(arraydata_t self, intVector s, rowindex_t N, colindex_t strength, colindex_t ncols) -> arraydata_t
        __init__(arraydata_t self, array_t const * s_, rowindex_t N, colindex_t strength, colindex_t ncols) -> arraydata_t
        __init__(arraydata_t self, arraydata_t adp) -> arraydata_t
        __init__(arraydata_t self, arraydata_t adp, colindex_t newncols) -> arraydata_t



        Specifies a class of orthogonal arrays  

        The specification includes the number of rows, number of columns, factor levels
        and strength.  

        An orthogonal array of strength t, N runs, k factors (columns) and factor levels
        s[i] is an N times k array with symbols 0, 1, ..., s[i]-1 in column i such that
        for every t columns every t-tuple of elements occurs equally often.  

        """
        this = _oalib.new_arraydata_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_arraydata_t
    __del__ = lambda self: None

    def __eq__(self, ad2):
        """__eq__(arraydata_t self, arraydata_t ad2) -> int"""
        return _oalib.arraydata_t___eq__(self, ad2)


    def ismixed(self):
        """
        ismixed(arraydata_t self) -> bool



        return true if the class represents mixed-level arrays  

        """
        return _oalib.arraydata_t_ismixed(self)


    def is2level(self):
        """
        is2level(arraydata_t self) -> bool



        return true if the class represents a 2-level array  

        """
        return _oalib.arraydata_t_is2level(self)


    def randomarray(self, strength=0, ncols=-1):
        """
        randomarray(arraydata_t self, int strength=0, int ncols=-1) -> array_link
        randomarray(arraydata_t self, int strength=0) -> array_link
        randomarray(arraydata_t self) -> array_link



        return random array from the class. this operation is only valid for strength 0
        or 1  

        """
        return _oalib.arraydata_t_randomarray(self, strength, ncols)


    def writeConfigFile(self, filename):
        """
        writeConfigFile(arraydata_t self, char const * filename)



        Write file with specification of orthognal array class.  

        Parameters
        ----------
        * `filename` :  
            Filename to write to  

        """
        return _oalib.arraydata_t_writeConfigFile(self, filename)


    def idstr(self):
        """
        idstr(arraydata_t self) -> std::string



        """
        return _oalib.arraydata_t_idstr(self)


    def idstrseriesfull(self):
        """
        idstrseriesfull(arraydata_t self) -> std::string



        """
        return _oalib.arraydata_t_idstrseriesfull(self)


    def fullidstr(self, series=0):
        """
        fullidstr(arraydata_t self, int series=0) -> std::string
        fullidstr(arraydata_t self) -> std::string



        """
        return _oalib.arraydata_t_fullidstr(self, series)


    def latexstr(self, cmd=0, series=0):
        """
        latexstr(arraydata_t self, int cmd=0, int series=0) -> std::string
        latexstr(arraydata_t self, int cmd=0) -> std::string
        latexstr(arraydata_t self) -> std::string



        return latex string describing the class  

        """
        return _oalib.arraydata_t_latexstr(self, cmd, series)


    def reduceColumns(self, k):
        """
        reduceColumns(arraydata_t self, int k) -> arraydata_t



        """
        return _oalib.arraydata_t_reduceColumns(self, k)


    def showstr(self):
        """
        showstr(arraydata_t self) -> std::string



        """
        return _oalib.arraydata_t_showstr(self)


    def show(self, verbose=1):
        """
        show(arraydata_t self, int verbose=1)
        show(arraydata_t self)



        """
        return _oalib.arraydata_t_show(self, verbose)


    def complete_arraydata(self):
        """
        complete_arraydata(arraydata_t self)



        Calculate derived data such as the index and column groups from a design.  

        """
        return _oalib.arraydata_t_complete_arraydata(self)


    def lmc_overflow_check(self):
        """
        lmc_overflow_check(arraydata_t self)



        check whether the LMC calculation will overflow  

        """
        return _oalib.arraydata_t_lmc_overflow_check(self)


    def complete_arraydata_fixlast(self):
        """
        complete_arraydata_fixlast(arraydata_t self)



        """
        return _oalib.arraydata_t_complete_arraydata_fixlast(self)


    def complete_arraydata_splitn(self, ns):
        """
        complete_arraydata_splitn(arraydata_t self, int ns)



        """
        return _oalib.arraydata_t_complete_arraydata_splitn(self, ns)


    def set_colgroups(self, *args):
        """
        set_colgroups(arraydata_t self, intVector splits)
        set_colgroups(arraydata_t self, symmetry_group sg)



        set column group equal to that of a symmetry group  

        """
        return _oalib.arraydata_t_set_colgroups(self, *args)


    def show_colgroups(self):
        """
        show_colgroups(arraydata_t self)



        show column groups in the array class  

        """
        return _oalib.arraydata_t_show_colgroups(self)


    def calculate_oa_index(self, strength):
        """
        calculate_oa_index(arraydata_t self, colindex_t strength)



        calculate the index of the orthogonal arrays in this class  

        """
        return _oalib.arraydata_t_calculate_oa_index(self, strength)


    def create_root(self, n_columns=-1, fill_value=0):
        """
        create_root(arraydata_t self, int n_columns=-1, int fill_value=0) -> array_link
        create_root(arraydata_t self, int n_columns=-1) -> array_link
        create_root(arraydata_t self) -> array_link



        return the root array for the class  

        """
        return _oalib.arraydata_t_create_root(self, n_columns, fill_value)


    def getfactorlevel(self, idx):
        """
        getfactorlevel(arraydata_t self, int idx) -> int



        return the factor level for the specified column return -1 if the column index
        is invalid  

        """
        return _oalib.arraydata_t_getfactorlevel(self, idx)


    def getS(self):
        """
        getS(arraydata_t self) -> intVector



        return factor levels  

        """
        return _oalib.arraydata_t_getS(self)


    def factor_levels(self):
        """
        factor_levels(arraydata_t self) -> intVector



        return factor levels  

        """
        return _oalib.arraydata_t_factor_levels(self)


    def reset_strength(self, strength):
        """
        reset_strength(arraydata_t self, colindex_t strength)



        Reset strength of arraydata.  

        Parameters
        ----------
        * `strength` :  
            The strength to reset the structure to  

        """
        return _oalib.arraydata_t_reset_strength(self, strength)


    def get_col_group(self, col):
        """
        get_col_group(arraydata_t self, colindex_t const col) -> colindex_t



        Return index of the column group for a column.  

        """
        return _oalib.arraydata_t_get_col_group(self, col)


    def is_factor_levels_sorted(self):
        """
        is_factor_levels_sorted(arraydata_t self) -> bool



        Return True if the factor levels are sorted from large to small.  

        """
        return _oalib.arraydata_t_is_factor_levels_sorted(self)


    def __repr__(self):
        """__repr__(arraydata_t self) -> std::string"""
        return _oalib.arraydata_t___repr__(self)

arraydata_t_swigregister = _oalib.arraydata_t_swigregister
arraydata_t_swigregister(arraydata_t)


def readConfigFile(file):
    """readConfigFile(char const * file) -> arraydata_t"""
    return _oalib.readConfigFile(file)

def copy_array(src, dst, nrows, ncols):
    """copy_array(array_t const * src, array_t *const dst, int const nrows, int const ncols)"""
    return _oalib.copy_array(src, dst, nrows, ncols)

def destroy_array(array):
    """destroy_array(array_t * array) -> int"""
    return _oalib.destroy_array(array)

def create_array(*args):
    """
    create_array(int const nrows, int const ncols) -> array_t
    create_array(arraydata_t ad) -> array_t *
    """
    return _oalib.create_array(*args)

def clone_array(array, nrows, ncols):
    """clone_array(array_t const *const array, rowindex_t const nrows, colindex_t const ncols) -> array_t *"""
    return _oalib.clone_array(array, nrows, ncols)
class array_link(object):
    """


    C++ includes: arraytools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    n_rows = _swig_property(_oalib.array_link_n_rows_get, _oalib.array_link_n_rows_set)
    n_columns = _swig_property(_oalib.array_link_n_columns_get, _oalib.array_link_n_columns_set)
    index = _swig_property(_oalib.array_link_index_get, _oalib.array_link_index_set)
    array = _swig_property(_oalib.array_link_array_get, _oalib.array_link_array_set)
    INDEX_NONE = _oalib.array_link_INDEX_NONE
    INDEX_ERROR = _oalib.array_link_INDEX_ERROR
    INDEX_DEFAULT = _oalib.array_link_INDEX_DEFAULT
    __swig_destroy__ = _oalib.delete_array_link
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(array_link self) -> array_link
        __init__(array_link self, rowindex_t nrows, colindex_t ncols, int index) -> array_link
        __init__(array_link self, rowindex_t nrows, colindex_t ncols, int index, carray_t * data) -> array_link
        __init__(array_link self, array_link arg2) -> array_link
        __init__(array_link self, Eigen::MatrixXd & eigen_matrix) -> array_link
        __init__(array_link self, array_link array, intVector column_permutation) -> array_link
        __init__(array_link self, array_t const * array, rowindex_t nrows, colindex_t ncols, int index=0) -> array_link
        __init__(array_link self, array_t const * array, rowindex_t nrows, colindex_t ncols) -> array_link
        __init__(array_link self, array_t const * array, rowindex_t nrows, colindex_t ncolsorig, colindex_t ncols, int index) -> array_link
        __init__(array_link self, intVector values, rowindex_t nrows, colindex_t ncols, int index=0) -> array_link
        __init__(array_link self, intVector values, rowindex_t nrows, colindex_t ncols) -> array_link
        __init__(array_link self, long * pymatinput) -> array_link



        A class representing an integer valued array  

        The array is initialized by copying the values from a vector.  

        """
        this = _oalib.new_array_link(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def clone(self):
        """
        clone(array_link self) -> array_link



        """
        return _oalib.array_link_clone(self)


    def showarray(self):
        """
        showarray(array_link self)



        print array to stdout  

        """
        return _oalib.array_link_showarray(self)


    def showarrayString(self):
        """
        showarrayString(array_link self) -> std::string



        print array to string  

        """
        return _oalib.array_link_showarrayString(self)


    def showarraycompact(self):
        """
        showarraycompact(array_link self)



        print array to stdout in compact format (no whitespace between elemenents)  

        """
        return _oalib.array_link_showarraycompact(self)


    def showproperties(self):
        """
        showproperties(array_link self)



        print array properties to stdout  

        """
        return _oalib.array_link_showproperties(self)


    def is2level(self):
        """
        is2level(array_link self) -> bool



        return true if the array is a 2-level array (e.g. only contains values 0 and 1)  

        """
        return _oalib.array_link_is2level(self)


    def is_mixed_level(self):
        """
        is_mixed_level(array_link self) -> bool



        return true is the array is a mixel-level array  

        """
        return _oalib.array_link_is_mixed_level(self)


    def is_orthogonal_array(self):
        """
        is_orthogonal_array(array_link self) -> bool



        return true is the array is array with values in 0, 1, ..., for each column  

        """
        return _oalib.array_link_is_orthogonal_array(self)


    def is_conference(self, *args):
        """
        is_conference(array_link self) -> bool
        is_conference(array_link self, int number_of_zeros) -> bool



        return true if the array is a +1, 0, -1 valued array, with specified number of
        zeros in each column  

        """
        return _oalib.array_link_is_conference(self, *args)


    def isSymmetric(self):
        """
        isSymmetric(array_link self) -> bool



        return true if the array is symmetric  

        """
        return _oalib.array_link_isSymmetric(self)


    def makeSymmetric(self):
        """
        makeSymmetric(array_link self)



        make the array symmetric by copying the upper-right to the lower-left  

        """
        return _oalib.array_link_makeSymmetric(self)


    def deleteColumn(self, index):
        """
        deleteColumn(array_link self, int index) -> array_link



        return array with selected column removed  

        """
        return _oalib.array_link_deleteColumn(self, index)


    def selectFirstRows(self, nrows):
        """
        selectFirstRows(array_link self, int nrows) -> array_link



        return array with first number_of_arrays rows  

        """
        return _oalib.array_link_selectFirstRows(self, nrows)


    def selectFirstColumns(self, ncolumns):
        """
        selectFirstColumns(array_link self, int ncolumns) -> array_link



        return array with first number_of_arrays columns selected  

        """
        return _oalib.array_link_selectFirstColumns(self, ncolumns)


    def selectLastColumns(self, ncolumns):
        """
        selectLastColumns(array_link self, int ncolumns) -> array_link



        return array with last number_of_arrays columns selected  

        """
        return _oalib.array_link_selectLastColumns(self, ncolumns)


    def selectColumns(self, *args):
        """
        selectColumns(array_link self, intVector c) -> array_link
        selectColumns(array_link self, int c) -> array_link



        select single column from an array  

        """
        return _oalib.array_link_selectColumns(self, *args)


    def setColumn(self, *args):
        """
        setColumn(array_link self, int c, intVector v)
        setColumn(array_link self, int c, charVector v)



        set a column of the array to the given vector  

        """
        return _oalib.array_link_setColumn(self, *args)


    def transposed(self):
        """
        transposed(array_link self) -> array_link



        return transposed array  

        """
        return _oalib.array_link_transposed(self)


    def Defficiency(self):
        """
        Defficiency(array_link self) -> double



        calculate D-efficiency  

        """
        return _oalib.array_link_Defficiency(self)


    def DsEfficiency(self, verbose=0):
        """
        DsEfficiency(array_link self, int verbose=0) -> double
        DsEfficiency(array_link self) -> double



        calculate main effect robustness (or Ds-optimality)  

        """
        return _oalib.array_link_DsEfficiency(self, verbose)


    def Defficiencies(self, verbose=0, addDs0=0):
        """
        Defficiencies(array_link self, int verbose=0, int addDs0=0) -> doubleVector
        Defficiencies(array_link self, int verbose=0) -> doubleVector
        Defficiencies(array_link self) -> doubleVector



        calculate D-efficiency, calculate main effect robustness (or Ds-optimality) and
        D1-efficiency for an orthogonal array  

        """
        return _oalib.array_link_Defficiencies(self, verbose, addDs0)


    def VIFefficiency(self):
        """
        VIFefficiency(array_link self) -> double



        """
        return _oalib.array_link_VIFefficiency(self)


    def Aefficiency(self):
        """
        Aefficiency(array_link self) -> double



        calculate A-efficiency  

        """
        return _oalib.array_link_Aefficiency(self)


    def Eefficiency(self):
        """
        Eefficiency(array_link self) -> double



        calculate E-efficiency  

        """
        return _oalib.array_link_Eefficiency(self)


    def Fvalues(self, number_of_columns):
        """
        Fvalues(array_link self, int number_of_columns) -> intVector



        Calculate F-values of a 2-level matrix.  

        This assumes the strength is at least 3. Otherwise use the jstruct_t object  

        """
        return _oalib.array_link_Fvalues(self, number_of_columns)


    def FvaluesConference(self, number_of_columns):
        """
        FvaluesConference(array_link self, int number_of_columns) -> intVector



        Calculate F-values of a conference design  

               \param number_of_columns Number of columns to use
               \return The Fk vector with k the number of columns specified


        """
        return _oalib.array_link_FvaluesConference(self, number_of_columns)


    def Jcharacteristics(self, jj=4):
        """
        Jcharacteristics(array_link self, int jj=4) -> intVector
        Jcharacteristics(array_link self) -> intVector



        Calculate the Jk-characteristics of the matrix (the values are signed)  

        Parameters
        ----------
        * `jj` :  
            Number of columns to use  

        Returns
        -------
        Vector with calculated Jk values  

        """
        return _oalib.array_link_Jcharacteristics(self, jj)


    def PECsequence(self, verbose=0):
        """
        PECsequence(array_link self, int verbose=0) -> doubleVector
        PECsequence(array_link self) -> doubleVector



        Calculate the projective estimation capacity sequence.  

        """
        return _oalib.array_link_PECsequence(self, verbose)


    def PICsequence(self, verbose=0):
        """
        PICsequence(array_link self, int verbose=0) -> doubleVector
        PICsequence(array_link self) -> doubleVector



        Calculate the projective information capacity sequence.  

        """
        return _oalib.array_link_PICsequence(self, verbose)


    def rank(self):
        """
        rank(array_link self) -> int



        calculate rank of array  

        """
        return _oalib.array_link_rank(self)


    def GWLP(self, truncate=1, verbose=0):
        """
        GWLP(array_link self, int truncate=1, int verbose=0) -> doubleVector
        GWLP(array_link self, int truncate=1) -> doubleVector
        GWLP(array_link self) -> doubleVector



        Calculate generalized wordlength pattern  

        See also: GWLP  

        """
        return _oalib.array_link_GWLP(self, truncate, verbose)


    def strength(self):
        """
        strength(array_link self) -> int



        calculate strength of an array  

        """
        return _oalib.array_link_strength(self)


    def foldover(self):
        """
        foldover(array_link self) -> bool



        return true if the array is a foldover array  

        """
        return _oalib.array_link_foldover(self)


    def min(self):
        """
        min(array_link self) -> array_t



        """
        return _oalib.array_link_min(self)


    def max(self):
        """
        max(array_link self) -> array_t



        """
        return _oalib.array_link_max(self)


    def CL2discrepancy(self):
        """
        CL2discrepancy(array_link self) -> double



        Calculate centered L2 discrepancy  

        The method is from "A connection between uniformity and aberration in regular
        fractions of two-level factorials", Fang and Mukerjee, 2000  

        """
        return _oalib.array_link_CL2discrepancy(self)


    def randomperm(self):
        """
        randomperm(array_link self) -> array_link



        apply a random permutation of rows, columns and levels of an orthogonal array  

        """
        return _oalib.array_link_randomperm(self)


    def randomcolperm(self):
        """
        randomcolperm(array_link self) -> array_link



        apply a random permutation of columns of an orthogonal array  

        """
        return _oalib.array_link_randomcolperm(self)


    def randomrowperm(self):
        """
        randomrowperm(array_link self) -> array_link



        apply a random permutation of rows of an orthogonal array  

        """
        return _oalib.array_link_randomrowperm(self)


    def getModelMatrix(self, order, intercept=1, verbose=0):
        """
        getModelMatrix(array_link self, int order, int intercept=1, int verbose=0) -> MatrixFloat
        getModelMatrix(array_link self, int order, int intercept=1) -> MatrixFloat
        getModelMatrix(array_link self, int order) -> MatrixFloat



        Caculate model matrix of an orthogonal array  

        Parameters
        ----------
        * `order` :  
            For 0 return only the intercept; for 1 return intercept and main effects;
            for 2 return intercept, main effects and interaction effects.  
        * `intercept` :  
            If 1, then include the intercept in the output.  
        * `verbose` :  
            Verbosity level  

        Returns
        -------
        Calculated model matrix  

        This function uses array2eigenModelMatrixMixed for the calculation.  

        """
        return _oalib.array_link_getModelMatrix(self, order, intercept, verbose)


    def deepcopy(self, rhs):
        """
        deepcopy(array_link self, array_link rhs) -> array_link



        """
        return _oalib.array_link_deepcopy(self, rhs)


    def shallowcopy(self, rhs):
        """
        shallowcopy(array_link self, array_link rhs) -> array_link



        """
        return _oalib.array_link_shallowcopy(self, rhs)


    def __eq__(self, rhs):
        """__eq__(array_link self, array_link rhs) -> int"""
        return _oalib.array_link___eq__(self, rhs)


    def __ne__(self, rhs):
        """__ne__(array_link self, array_link rhs) -> int"""
        return _oalib.array_link___ne__(self, rhs)


    def __lt__(self, rhs):
        """__lt__(array_link self, array_link rhs) -> int"""
        return _oalib.array_link___lt__(self, rhs)


    def __gt__(self, rhs):
        """__gt__(array_link self, array_link rhs) -> int"""
        return _oalib.array_link___gt__(self, rhs)


    def equalsize(self, rhs):
        """
        equalsize(array_link self, array_link rhs) -> int



        return true of two array have the same dimensions  

        """
        return _oalib.array_link_equalsize(self, rhs)


    def __add__(self, *args):
        """
        __add__(array_link self, array_link arg2) -> array_link
        __add__(array_link self, array_t value) -> array_link
        """
        return _oalib.array_link___add__(self, *args)


    def __sub__(self, *args):
        """
        __sub__(array_link self, array_link arg2) -> array_link
        __sub__(array_link self, array_t value) -> array_link
        """
        return _oalib.array_link___sub__(self, *args)


    def __mul__(self, *args):
        """
        __mul__(array_link self, array_link rhs) -> array_link
        __mul__(array_link self, array_t value) -> array_link
        """
        return _oalib.array_link___mul__(self, *args)


    def __imul__(self, value):
        """__imul__(array_link self, array_t value) -> array_link"""
        return _oalib.array_link___imul__(self, value)


    def __iadd__(self, value):
        """__iadd__(array_link self, array_t value) -> array_link"""
        return _oalib.array_link___iadd__(self, value)


    def __isub__(self, value):
        """__isub__(array_link self, array_t value) -> array_link"""
        return _oalib.array_link___isub__(self, value)


    def atfast(self, *args):
        """
        atfast(array_link self, rowindex_t const r, colindex_t const c) -> array_t const
        atfast(array_link self, rowindex_t const r, colindex_t const c) -> array_t &



        get element from array, no error checking, inline version  

        """
        return _oalib.array_link_atfast(self, *args)


    def _at(self, *args):
        """
        _at(array_link self, rowindex_t const arg2, colindex_t const arg3) -> array_t
        _at(array_link self, int const index) -> array_t



        get element at specified position, no bounds checking  

        """
        return _oalib.array_link__at(self, *args)


    def at(self, *args):
        """
        at(array_link self, rowindex_t const arg2, colindex_t const arg3) -> array_t
        at(array_link self, int const index) -> array_t
        at(array_link self, rowindex_t const arg2, colindex_t const arg3) -> array_t &



        get element at specified position  

        """
        return _oalib.array_link_at(self, *args)


    def setconstant(self, value):
        """
        setconstant(array_link self, array_t value)



        set all elements in the array to a value  

        """
        return _oalib.array_link_setconstant(self, value)


    def setvalue(self, *args):
        """
        setvalue(array_link self, int row, int col, int value)
        setvalue(array_link self, int row, int col, double value)



        set value of an array  

        """
        return _oalib.array_link_setvalue(self, *args)


    def _setvalue(self, row, col, value):
        """
        _setvalue(array_link self, int row, int col, int value)



        set value of an array, no bounds checking!  

        """
        return _oalib.array_link__setvalue(self, row, col, value)


    def negateRow(self, row):
        """
        negateRow(array_link self, rowindex_t row)



        multiply a row by -1  

        """
        return _oalib.array_link_negateRow(self, row)


    def show(self):
        """
        show(array_link self)



        print information about array  

        """
        return _oalib.array_link_show(self)


    def showstr(self):
        """
        showstr(array_link self) -> std::string



        return string describing the array  

        """
        return _oalib.array_link_showstr(self)


    def md5(self):
        """
        md5(array_link self) -> std::string



        return md5 sum of array representation (as represented with 32bit int datatype
        in memory)  

        """
        return _oalib.array_link_md5(self)


    def columnEqual(self, column_index, rhs, column_index_rhs):
        """
        columnEqual(array_link self, int column_index, array_link rhs, int column_index_rhs) -> bool



        return true if two columns are equal  

        """
        return _oalib.array_link_columnEqual(self, column_index, rhs, column_index_rhs)


    def firstColumnDifference(self, A):
        """
        firstColumnDifference(array_link self, array_link A) -> int



        return index of first different column  

        """
        return _oalib.array_link_firstColumnDifference(self, A)


    def firstDiff(self, A, r, c, verbose=1):
        """
        firstDiff(array_link self, array_link A, int & r, int & c, int verbose=1) -> bool
        firstDiff(array_link self, array_link A, int & r, int & c) -> bool



        Calculate row and column index of first difference between two arrays  

        The difference is according to the column-major ordering.  

        """
        return _oalib.array_link_firstDiff(self, A, r, c, verbose)


    def create_root(self, arrayclass, fill_value=0):
        """
        create_root(array_link self, arraydata_t arrayclass, int fill_value=0)
        create_root(array_link self, arraydata_t arrayclass)



        create root in arraylink  

        """
        return _oalib.array_link_create_root(self, arrayclass, fill_value)


    def nonzero_fraction(self):
        """
        nonzero_fraction(array_link self) -> double



        return fraction of nonzero elements in array  

        """
        return _oalib.array_link_nonzero_fraction(self)


    def clear(self):
        """
        clear(array_link self)



        fill array with zeros  

        """
        return _oalib.array_link_clear(self)


    def getarraydata(self, pymat1):
        """
        getarraydata(array_link self, int * pymat1)



        """
        return _oalib.array_link_getarraydata(self, pymat1)


    def setarraydata(self, tmp, n):
        """
        setarraydata(array_link self, intVector tmp, int n)



        internal function  

        """
        return _oalib.array_link_setarraydata(self, tmp, n)


    def setcolumn(self, target_column, source_array, source_column=0):
        """
        setcolumn(array_link self, int target_column, array_link source_array, int source_column=0)
        setcolumn(array_link self, int target_column, array_link source_array)



        set column to values  

        """
        return _oalib.array_link_setcolumn(self, target_column, source_array, source_column)


    def init(self, r, c):
        """
        init(array_link self, rowindex_t r, colindex_t c)



        """
        return _oalib.array_link_init(self, r, c)


    def row_symmetry_group(self):
        """
        row_symmetry_group(array_link self) -> symmetry_group



        return the row_symmetry group of an array  

        """
        return _oalib.array_link_row_symmetry_group(self)


    def reduceLMC(self):
        """
        reduceLMC(array_link self) -> array_link



        return the LMC form of the array  

        """
        return _oalib.array_link_reduceLMC(self)


    def reduceDOP(self):
        """
        reduceDOP(array_link self) -> array_link



        return the delete-one-factor-projection form of the array  

        """
        return _oalib.array_link_reduceDOP(self)


    def getEigenMatrix(self):
        """
        getEigenMatrix(array_link self) -> MatrixFloat



        return the array as an Eigen matrix  

        """
        return _oalib.array_link_getEigenMatrix(self)


    def columnGreater(self, c1, rhs, rhs_column):
        """
        columnGreater(array_link self, int c1, array_link rhs, int rhs_column) -> int



        return true of specified column is smaller than column in another array  

        """
        return _oalib.array_link_columnGreater(self, c1, rhs, rhs_column)


    def debug(self):
        """
        debug(array_link self)



        """
        return _oalib.array_link_debug(self)


    def data(self):
        """data(array_link self) -> void *"""
        return _oalib.array_link_data(self)



    def __getattr__(self, attr):
        if attr=='__array_interface__':
          a = dict()
          a['version']=3
          a['shape']=(self.n_rows, self.n_columns)
          sizeofdata=_oalib.sizeof_array_t()
          a['typestr']='<i%d' % sizeofdata # sizeof(array_t)
          a['data']=(self.data(), True)
    # convert from the OAP column-major style to Numpy row-major style
          a['strides']=(sizeofdata, sizeofdata*self.n_rows)
          return a
        else:
          raise AttributeError("%r object has no attribute %r" %
                             (self.__class__, attr))

    @property
    def shape(self):
        return (self.n_rows, self.n_columns)

    @property
    def size(self):
        return self.n_rows*self.n_columns

    def showarray(self):
      """ Show array """
    # overridden to fix problems with ipython
      sys.stdout.write(self.showarrayString())

    def getarray(self, verbose=0, *args):
      """ Return Numpy style array """
      if verbose:
          print('getting array: size %d %d' % (self.n_rows, self.n_columns))
      x=self.getarraydata( int(self.n_rows*self.n_columns) )
      return x.reshape((self.n_columns, self.n_rows)).transpose()

    def setarray(self, X, verbose=0):
      """ Update the array link object with a Numpy array

      Args:
         X (numpy array): array to be copied to the object
      """
      self.init(X.shape[0], X.shape[1])
      self.index=-1
      iv = intVector(X.T.astype(int).flatten().tolist())
      self.setarraydata(iv, X.size)

    def _slice2range(self, slice, max_value):
        """ Convert a python slice object to a range """
        if isinstance(slice, int):
            return [slice]
        if slice.start  is None:
            start = 0
        else:
            start = slice.start
        if slice.stop is None:
            stop = max_value
        else:
            stop = slice.stop
        if slice.step is None:
            step = 1
        else:
            step = slice.step
        return list(range(start, stop, step))

    def _ranges2subarray(self, row_range, col_range):
          """ From a list of row element and a list of column element construct a submatrix """
          al=array_link(len(row_range), len(col_range), array_link.INDEX_DEFAULT )
          for ii, row in enumerate(row_range):
              for jj, col in enumerate(col_range):
                  al[ii, jj]=self.at(row, col)
          return al

    def __getitem__(self, index):
      """ Return element of array """
      if type(index)==int:
          if index<0 or index > self.n_rows*self.n_columns:
            raise IndexError('index out of bounds')
          return self.at(index)
      elif isinstance(index, slice):
          indices=self._slice2range(index, self.n_rows*self.n_columns)
          return np.array( [self.at(a) for a in indices])
      else:
          if len(index)==2:
              index0=index[0]
              index1=index[1]
              if isinstance(index0, int) and isinstance(index1, int):
                if index0<0 or index0 >= self.n_rows:
                  raise IndexError('index out of bounds')
                if index1<0 or index1 >= self.n_columns:
                  raise IndexError('index out of bounds')
                return self.at(index0, index1)	  
              elif isinstance(index0, int) and isinstance(index1, slice):
                  row_range=[index0]
                  col_range=self._slice2range(index1, self.n_columns)

                  return self._ranges2subarray(row_range, col_range)
              elif isinstance(index0, slice) and isinstance(index1, int):
                  row_range=self._slice2range(index0, self.n_rows)
                  col_range=[index1]

                  return self._ranges2subarray(row_range, col_range)
              elif isinstance(index0, slice) and isinstance(index1, slice):
                  row_range=self._slice2range(index0, self.n_rows)
                  col_range=self._slice2range(index1, self.n_columns)

                  return self._ranges2subarray(row_range, col_range)
              else:
                  raise NotImplementedError('slice indexing not supported')
          else:
            raise IndexError('invalid index')

    def __setitem__(self, index, value):
      """ Set specified value at specified index in the array """
      if type(index)==int:
          if index<0 or index > self.n_rows*self.n_columns:
            raise IndexError('index out of bounds')
          self.setvalue(index, 0, value) 
      else:
          if len(index)==2:
            a=index[0]
            b=index[1]
            if a<0 or a >= self.n_rows:
              raise IndexError('index out of bounds')
            if b<0 or b >= self.n_columns:
              raise IndexError('index out of bounds')
            self.setvalue(a, b, value)
          else:
            raise IndexError('invalid index')


    def __repr__(self):
        """__repr__(array_link self) -> std::string"""
        return _oalib.array_link___repr__(self)

array_link_swigregister = _oalib.array_link_swigregister
array_link_swigregister(array_link)


def exampleArray(idx=0, verbose=0):
    """
    exampleArray(int idx=0, int verbose=0) -> array_link
    exampleArray(int idx=0) -> array_link
    exampleArray() -> array_link
    """
    return _oalib.exampleArray(idx, verbose)

def Jcharacteristics_conference(array, number_of_columns, verbose=0):
    """
    Jcharacteristics_conference(array_link array, int number_of_columns, int verbose=0) -> intVector
    Jcharacteristics_conference(array_link array, int number_of_columns) -> intVector
    """
    return _oalib.Jcharacteristics_conference(array, number_of_columns, verbose)

def hstack(*args):
    """
    hstack(array_link array1, array_link array2) -> array_link
    hstack(array_link array, charVector column) -> array_link
    """
    return _oalib.hstack(*args)

def hstacklastcol(A, B):
    """hstacklastcol(array_link A, array_link B) -> array_link"""
    return _oalib.hstacklastcol(A, B)

def vstack(column_top, column_bottom):
    """vstack(charVector column_top, charVector column_bottom) -> charVector"""
    return _oalib.vstack(column_top, column_bottom)

def perform_column_permutation(source, target, perm):
    """perform_column_permutation(array_link source, array_link target, intVector perm)"""
    return _oalib.perform_column_permutation(source, target, perm)

def perform_row_permutation(source, target, perm):
    """perform_row_permutation(array_link source, array_link target, intVector perm)"""
    return _oalib.perform_row_permutation(source, target, perm)

def arraylink2arraydata(array, extracols=0, strength=2):
    """
    arraylink2arraydata(array_link array, int extracols=0, int strength=2) -> arraydata_t
    arraylink2arraydata(array_link array, int extracols=0) -> arraydata_t
    arraylink2arraydata(array_link array) -> arraydata_t
    """
    return _oalib.arraylink2arraydata(array, extracols, strength)

def addConstant(lst, value):
    """addConstant(arraylist_t lst, int value) -> arraylist_t"""
    return _oalib.addConstant(lst, value)

def getJcounts(arraylist, N, k, verbose=1):
    """
    getJcounts(arraylist_t arraylist, int N, int k, int verbose=1) -> intVector
    getJcounts(arraylist_t arraylist, int N, int k) -> intVector
    """
    return _oalib.getJcounts(arraylist, N, k, verbose)
class jstructbase_t(object):
    """


    struct to hold data of an array, e.g. J-characteristic. Abstract base class  

    C++ includes: arraytools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    values = _swig_property(_oalib.jstructbase_t_values_get, _oalib.jstructbase_t_values_set)
    jvalues = _swig_property(_oalib.jstructbase_t_jvalues_get, _oalib.jstructbase_t_jvalues_set)
    jvalue2index = _swig_property(_oalib.jstructbase_t_jvalue2index_get, _oalib.jstructbase_t_jvalue2index_set)
    jj = _swig_property(_oalib.jstructbase_t_jj_get, _oalib.jstructbase_t_jj_set)

    def maxJ(self):
        """
        maxJ(jstructbase_t self) -> int



        calculate maximum J value  

        """
        return _oalib.jstructbase_t_maxJ(self)


    def Jvalues(self):
        """
        Jvalues(jstructbase_t self) -> intVector



        calculate possible values in F vector  

        """
        return _oalib.jstructbase_t_Jvalues(self)


    def calculateF(self):
        """
        calculateF(jstructbase_t self) -> intVector



        Calculate histogram of J values  

               The histogram bins are given by the values of @ref Jvalues

               \returns Histogram of J values


        """
        return _oalib.jstructbase_t_calculateF(self)


    def calc(self, array):
        """
        calc(jstructbase_t self, array_link array)



        Calculate the J-values for a given array.  

        """
        return _oalib.jstructbase_t_calc(self, array)


    def show(self):
        """
        show(jstructbase_t self)



        Show contents of structure.  

        """
        return _oalib.jstructbase_t_show(self)


    def showdata(self, verbose=1):
        """
        showdata(jstructbase_t self, int verbose=1)
        showdata(jstructbase_t self)



        """
        return _oalib.jstructbase_t_showdata(self, verbose)


    def showstr(self):
        """
        showstr(jstructbase_t self) -> std::string



        """
        return _oalib.jstructbase_t_showstr(self)


    def allzero(self):
        """
        allzero(jstructbase_t self) -> int



        return 1 if all vals are zero  

        """
        return _oalib.jstructbase_t_allzero(self)

    __swig_destroy__ = _oalib.delete_jstructbase_t
    __del__ = lambda self: None
jstructbase_t_swigregister = _oalib.jstructbase_t_swigregister
jstructbase_t_swigregister(jstructbase_t)

class symmdata(object):
    """


    structure containing data related to symmetries of arrays  

    C++ includes: arraytools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    rowvalue = _swig_property(_oalib.symmdata_rowvalue_get, _oalib.symmdata_rowvalue_set)
    orig = _swig_property(_oalib.symmdata_orig_get, _oalib.symmdata_orig_set)
    ft = _swig_property(_oalib.symmdata_ft_get, _oalib.symmdata_ft_set)

    def __init__(self, al, minlen=1):
        """
        __init__(symmdata self, array_link al, int minlen=1) -> symmdata
        __init__(symmdata self, array_link al) -> symmdata



        """
        this = _oalib.new_symmdata(al, minlen)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def show(self, verbose=1):
        """
        show(symmdata self, int verbose=1)
        show(symmdata self)



        """
        return _oalib.symmdata_show(self, verbose)


    def checkIdx(self, col=-1):
        """
        checkIdx(symmdata self, int col=-1) -> intVector
        checkIdx(symmdata self) -> intVector



        list with indices set to check for symmetry reductions  

        """
        return _oalib.symmdata_checkIdx(self, col)

    __swig_destroy__ = _oalib.delete_symmdata
    __del__ = lambda self: None
symmdata_swigregister = _oalib.symmdata_swigregister
symmdata_swigregister(symmdata)

class jstruct_t(object):
    """


    struct to hold data of an array, e.g. J-characteristic, rank  

    See papers: Minimum G2-aberration properties of two-level foldover designs,
    Butler, 2004 Design Selection and Classification for Hadamard Matrices Using
    Generalized Minimum Aberration Criteria, Deng and Tang  

    C++ includes: arraytools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    N = _swig_property(_oalib.jstruct_t_N_get, _oalib.jstruct_t_N_set)
    k = _swig_property(_oalib.jstruct_t_k_get, _oalib.jstruct_t_k_set)
    jj = _swig_property(_oalib.jstruct_t_jj_get, _oalib.jstruct_t_jj_set)
    nc = _swig_property(_oalib.jstruct_t_nc_get, _oalib.jstruct_t_nc_set)
    values = _swig_property(_oalib.jstruct_t_values_get, _oalib.jstruct_t_values_set)
    abberration = _swig_property(_oalib.jstruct_t_abberration_get, _oalib.jstruct_t_abberration_set)

    def __init__(self, *args):
        """
        __init__(jstruct_t self) -> jstruct_t
        __init__(jstruct_t self, array_link al, int jj=4) -> jstruct_t
        __init__(jstruct_t self, array_link al) -> jstruct_t
        __init__(jstruct_t self, int const N, int const K, int const jj=4) -> jstruct_t
        __init__(jstruct_t self, int const N, int const K) -> jstruct_t
        __init__(jstruct_t self, jstruct_t js) -> jstruct_t



        """
        this = _oalib.new_jstruct_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_jstruct_t
    __del__ = lambda self: None

    def maxJ(self):
        """
        maxJ(jstruct_t self) -> int



        calculate maximum J value  

        """
        return _oalib.jstruct_t_maxJ(self)


    def number_J_values(self, strength):
        """number_J_values(jstruct_t self, int strength) -> int"""
        return _oalib.jstruct_t_number_J_values(self, strength)


    def Fval(self, strength=3):
        """
        Fval(jstruct_t self, int strength=3) -> intVector
        Fval(jstruct_t self) -> intVector



        calculate possible values in F vector  

        """
        return _oalib.jstruct_t_Fval(self, strength)


    def calculateF(self, strength=3):
        """
        calculateF(jstruct_t self, int strength=3) -> intVector
        calculateF(jstruct_t self) -> intVector



        calculate histogram of J values for a 2-level array  

        """
        return _oalib.jstruct_t_calculateF(self, strength)


    def calculateAberration(self):
        """
        calculateAberration(jstruct_t self)



        Calculate aberration value  

        This is equal to the sum of the squares of all Jk values, divided by the number
        of rows squared.  

        """
        return _oalib.jstruct_t_calculateAberration(self)


    def show(self):
        """
        show(jstruct_t self)



        Show contents of structure.  

        """
        return _oalib.jstruct_t_show(self)


    def showdata(self):
        """
        showdata(jstruct_t self)



        """
        return _oalib.jstruct_t_showdata(self)


    def showstr(self):
        """
        showstr(jstruct_t self) -> std::string



        """
        return _oalib.jstruct_t_showstr(self)


    def allzero(self):
        """
        allzero(jstruct_t self) -> int



        return 1 if all J values are zero, otherwise return 0  

        """
        return _oalib.jstruct_t_allzero(self)


    def __repr__(self):
        """__repr__(jstruct_t self) -> std::string"""
        return _oalib.jstruct_t___repr__(self)

jstruct_t_swigregister = _oalib.jstruct_t_swigregister
jstruct_t_swigregister(jstruct_t)

class jstructconference_t(jstructbase_t):
    """


    Calculate J-characteristics of conference designs  

    C++ includes: arraytools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(jstructconference_t self, int N, int jj=4) -> jstructconference_t
        __init__(jstructconference_t self, int N) -> jstructconference_t
        __init__(jstructconference_t self, array_link array, int jj=4) -> jstructconference_t
        __init__(jstructconference_t self, array_link array) -> jstructconference_t



        Calculate J-characteristics of a conference design  

        Parameters
        ----------
        * `array` :  
            Array to calculate the J-characteristics for  
        * `jj` :  
            Number of columns to use for the Jk-characteristics  

        """
        this = _oalib.new_jstructconference_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_jstructconference_t
    __del__ = lambda self: None
jstructconference_t_swigregister = _oalib.jstructconference_t_swigregister
jstructconference_t_swigregister(jstructconference_t)


def create_root(*args):
    """
    create_root(array_t * array, arraydata_t arrayclass)
    create_root(arraydata_t arrayclass, arraylist_t solutions)
    """
    return _oalib.create_root(*args)

def array_diff(A, B, r, c, rpos, cpos):
    """array_diff(carray_p A, carray_p B, rowindex_t const r, colindex_t const c, rowindex_t & rpos, colindex_t & cpos) -> int"""
    return _oalib.array_diff(A, B, r, c, rpos, cpos)

def fastJupdate(array, N, J, column_indices, tmp):
    """fastJupdate(array_t const * array, rowindex_t N, int const J, colindex_t const * column_indices, array_t * tmp)"""
    return _oalib.fastJupdate(array, N, J, column_indices, tmp)

def jvalue(array, J, column_indices):
    """jvalue(array_link array, int const J, int const * column_indices) -> int"""
    return _oalib.jvalue(array, J, column_indices)

def jvaluefast(array, N, J, column_indices):
    """jvaluefast(array_t const * array, rowindex_t N, int const J, colindex_t const * column_indices) -> int"""
    return _oalib.jvaluefast(array, N, J, column_indices)

def analyseArrays(arraylist, verbose, jj=4):
    """
    analyseArrays(arraylist_t arraylist, int const verbose, int const jj=4) -> jstructArray
    analyseArrays(arraylist_t arraylist, int const verbose) -> jstructArray
    """
    return _oalib.analyseArrays(arraylist, verbose, jj)
class array_transformation_t(object):
    """


    Contains a transformation of an array.  

    Contains an array transformation. The transformation consists of column, row and
    level permutations. The level and column permutations are not commutative (since
    the level permutations are tied to a particular column). We apply the column
    permutations first.  

    C++ includes: arraytools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    rperm = _swig_property(_oalib.array_transformation_t_rperm_get, _oalib.array_transformation_t_rperm_set)
    cperm = _swig_property(_oalib.array_transformation_t_cperm_get, _oalib.array_transformation_t_cperm_set)
    lperms = _swig_property(_oalib.array_transformation_t_lperms_get, _oalib.array_transformation_t_lperms_set)
    ad = _swig_property(_oalib.array_transformation_t_ad_get, _oalib.array_transformation_t_ad_set)

    def __init__(self, *args):
        """
        __init__(array_transformation_t self, arraydata_t arrayclass) -> array_transformation_t
        __init__(array_transformation_t self, arraydata_t arrayclass) -> array_transformation_t
        __init__(array_transformation_t self) -> array_transformation_t
        __init__(array_transformation_t self, array_transformation_t transformation) -> array_transformation_t



        copy constructor  

        """
        this = _oalib.new_array_transformation_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_array_transformation_t
    __del__ = lambda self: None

    def isIdentity(self):
        """
        isIdentity(array_transformation_t self) -> bool



        return true if the transformation is equal to the identity  

        """
        return _oalib.array_transformation_t_isIdentity(self)


    def inverse(self):
        """
        inverse(array_transformation_t self) -> array_transformation_t



        return the inverse transformation  

        """
        return _oalib.array_transformation_t_inverse(self)


    def reset(self):
        """
        reset(array_transformation_t self)



        return the transformation to the identity transformation  

        """
        return _oalib.array_transformation_t_reset(self)


    def randomize(self):
        """
        randomize(array_transformation_t self)



        initialize to a random transformation  

        """
        return _oalib.array_transformation_t_randomize(self)


    def randomizecolperm(self):
        """
        randomizecolperm(array_transformation_t self)



        initialize with a random column permutation  

        """
        return _oalib.array_transformation_t_randomizecolperm(self)


    def randomizerowperm(self):
        """
        randomizerowperm(array_transformation_t self)



        initialize with a random row permutation  

        """
        return _oalib.array_transformation_t_randomizerowperm(self)


    def __eq__(self, t2):
        """__eq__(array_transformation_t self, array_transformation_t t2) -> int"""
        return _oalib.array_transformation_t___eq__(self, t2)


    def __mul__(self, b):
        """__mul__(array_transformation_t self, array_transformation_t b) -> array_transformation_t"""
        return _oalib.array_transformation_t___mul__(self, b)


    def apply(self, *args):
        """
        apply(array_transformation_t self, array_link array) -> array_link
        apply(array_transformation_t self, array_t * sourcetarget)
        apply(array_transformation_t self, array_t const * source, array_t * target)



        apply transformation to an array  

        """
        return _oalib.array_transformation_t_apply(self, *args)


    def print_transformed(self, source):
        """
        print_transformed(array_transformation_t self, carray_t * source)



        apply transformation and show resulting array  

        """
        return _oalib.array_transformation_t_print_transformed(self, source)


    def show(self, *args):
        """
        show(array_transformation_t self)
        show(array_transformation_t self, std::ostream & out)



        """
        return _oalib.array_transformation_t_show(self, *args)


    def rowperm(self):
        """
        rowperm(array_transformation_t self) -> intVector



        return the row permutation of the transformation  

        """
        return _oalib.array_transformation_t_rowperm(self)


    def colperm(self):
        """
        colperm(array_transformation_t self) -> intVector



        return the column permutation of the transformation  

        """
        return _oalib.array_transformation_t_colperm(self)


    def lvlperm(self, c):
        """
        lvlperm(array_transformation_t self, int c) -> intVector



        return the level permutations of the transformation  

        """
        return _oalib.array_transformation_t_lvlperm(self, c)


    def setrowperm(self, row_permutation):
        """
        setrowperm(array_transformation_t self, intVector row_permutation)



        set the row permutation of the transformation  

        """
        return _oalib.array_transformation_t_setrowperm(self, row_permutation)


    def setcolperm(self, column_permutation):
        """
        setcolperm(array_transformation_t self, intVector column_permutation)



        set the column permutation of the transformation  

        """
        return _oalib.array_transformation_t_setcolperm(self, column_permutation)


    def setlevelperm(self, column_index, lvl_permutation):
        """
        setlevelperm(array_transformation_t self, int column_index, intVector lvl_permutation)



        set the level permutation of the transformation  

        """
        return _oalib.array_transformation_t_setlevelperm(self, column_index, lvl_permutation)


    def __repr__(self):
        """__repr__(array_transformation_t self) -> std::string"""
        return _oalib.array_transformation_t___repr__(self)

array_transformation_t_swigregister = _oalib.array_transformation_t_swigregister
array_transformation_t_swigregister(array_transformation_t)

class conference_transformation_t(object):
    """


    Contains a transformation of a conference matrix.  

    Contains an array transformation. The transformation consists of column
    permutations, row permutations and sign switches for both the rows and columns.  

    The sign switches and the permutations are not commutative. We apply the
    permutations first and then the sign flips.  

    C++ includes: arraytools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    rperm = _swig_property(_oalib.conference_transformation_t_rperm_get, _oalib.conference_transformation_t_rperm_set)
    cperm = _swig_property(_oalib.conference_transformation_t_cperm_get, _oalib.conference_transformation_t_cperm_set)
    cswitch = _swig_property(_oalib.conference_transformation_t_cswitch_get, _oalib.conference_transformation_t_cswitch_set)
    rswitch = _swig_property(_oalib.conference_transformation_t_rswitch_get, _oalib.conference_transformation_t_rswitch_set)
    nrows = _swig_property(_oalib.conference_transformation_t_nrows_get, _oalib.conference_transformation_t_nrows_set)
    ncols = _swig_property(_oalib.conference_transformation_t_ncols_get, _oalib.conference_transformation_t_ncols_set)

    def __init__(self, *args):
        """
        __init__(conference_transformation_t self) -> conference_transformation_t
        __init__(conference_transformation_t self, int nrows, int ncols) -> conference_transformation_t
        __init__(conference_transformation_t self, array_link al) -> conference_transformation_t
        __init__(conference_transformation_t self, conference_transformation_t T) -> conference_transformation_t



        """
        this = _oalib.new_conference_transformation_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def show(self, verbose=1):
        """
        show(conference_transformation_t self, int verbose=1)
        show(conference_transformation_t self)



        show the array transformation  

        """
        return _oalib.conference_transformation_t_show(self, verbose)


    def isIdentity(self):
        """
        isIdentity(conference_transformation_t self) -> bool



        return true if the transformation is equal to the identity  

        """
        return _oalib.conference_transformation_t_isIdentity(self)


    def inverse(self):
        """
        inverse(conference_transformation_t self) -> conference_transformation_t



        return the inverse transformation  

        """
        return _oalib.conference_transformation_t_inverse(self)


    def reset(self):
        """
        reset(conference_transformation_t self)



        return the transformation to the identity transformation  

        """
        return _oalib.conference_transformation_t_reset(self)


    def randomize(self):
        """
        randomize(conference_transformation_t self)



        initialize to a random transformation  

        """
        return _oalib.conference_transformation_t_randomize(self)


    def randomizecolperm(self):
        """
        randomizecolperm(conference_transformation_t self)



        initialize with a random column permutation  

        """
        return _oalib.conference_transformation_t_randomizecolperm(self)


    def randomizerowperm(self):
        """
        randomizerowperm(conference_transformation_t self)



        initialize with a random row permutation  

        """
        return _oalib.conference_transformation_t_randomizerowperm(self)


    def randomizecolflips(self):
        """
        randomizecolflips(conference_transformation_t self)



        initialize with random col switches  

        """
        return _oalib.conference_transformation_t_randomizecolflips(self)


    def randomizerowflips(self):
        """
        randomizerowflips(conference_transformation_t self)



        initialize with random row switches  

        """
        return _oalib.conference_transformation_t_randomizerowflips(self)


    def apply(self, al):
        """
        apply(conference_transformation_t self, array_link al) -> array_link



        apply transformation to an array_link object  

        """
        return _oalib.conference_transformation_t_apply(self, al)


    def __eq__(self, rhs):
        """__eq__(conference_transformation_t self, conference_transformation_t rhs) -> int"""
        return _oalib.conference_transformation_t___eq__(self, rhs)


    def __mul__(self, rhs):
        """__mul__(conference_transformation_t self, conference_transformation_t rhs) -> conference_transformation_t"""
        return _oalib.conference_transformation_t___mul__(self, rhs)


    def setrowperm(self, rp):
        """
        setrowperm(conference_transformation_t self, intVector rp)



        """
        return _oalib.conference_transformation_t_setrowperm(self, rp)


    def setcolperm(self, cp):
        """
        setcolperm(conference_transformation_t self, intVector cp)



        """
        return _oalib.conference_transformation_t_setcolperm(self, cp)

    __swig_destroy__ = _oalib.delete_conference_transformation_t
    __del__ = lambda self: None
conference_transformation_t_swigregister = _oalib.conference_transformation_t_swigregister
conference_transformation_t_swigregister(conference_transformation_t)


def showArrayList(lst):
    """showArrayList(arraylist_t lst)"""
    return _oalib.showArrayList(lst)
ATEXT = _oalib.ATEXT
ALATEX = _oalib.ALATEX
ABINARY = _oalib.ABINARY
ABINARY_DIFF = _oalib.ABINARY_DIFF
ABINARY_DIFFZERO = _oalib.ABINARY_DIFFZERO
AERROR = _oalib.AERROR
A_AUTOMATIC = _oalib.A_AUTOMATIC
A_AUTOMATIC_BINARY = _oalib.A_AUTOMATIC_BINARY
READ = _oalib.READ
WRITE = _oalib.WRITE
READWRITE = _oalib.READWRITE
class arrayfile_t(object):
    """


    Structure for reading or writing a file with arrays.  

    The format of the file is determined by the `arrayfilemode_t` The format
    described in detail in the documentation of the OApackage
    https://oapackage.readthedocs.io/en/latest/.  

    C++ includes: arraytools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    filename = _swig_property(_oalib.arrayfile_t_filename_get, _oalib.arrayfile_t_filename_set)
    iscompressed = _swig_property(_oalib.arrayfile_t_iscompressed_get, _oalib.arrayfile_t_iscompressed_set)
    nrows = _swig_property(_oalib.arrayfile_t_nrows_get, _oalib.arrayfile_t_nrows_set)
    ncols = _swig_property(_oalib.arrayfile_t_ncols_get, _oalib.arrayfile_t_ncols_set)
    nbits = _swig_property(_oalib.arrayfile_t_nbits_get, _oalib.arrayfile_t_nbits_set)
    mode = _swig_property(_oalib.arrayfile_t_mode_get, _oalib.arrayfile_t_mode_set)
    rwmode = _swig_property(_oalib.arrayfile_t_rwmode_get, _oalib.arrayfile_t_rwmode_set)
    narrays = _swig_property(_oalib.arrayfile_t_narrays_get, _oalib.arrayfile_t_narrays_set)
    narraycounter = _swig_property(_oalib.arrayfile_t_narraycounter_get, _oalib.arrayfile_t_narraycounter_set)
    NARRAYS_MAX = _oalib.arrayfile_t_NARRAYS_MAX

    def __init__(self, *args):
        """
        __init__(arrayfile::arrayfile_t self) -> arrayfile_t
        __init__(arrayfile::arrayfile_t self, std::string const filename, int verbose=1) -> arrayfile_t
        __init__(arrayfile::arrayfile_t self, std::string const filename) -> arrayfile_t
        __init__(arrayfile::arrayfile_t self, std::string const filename, int nrows, int ncols, int narrays=-1, arrayfile::arrayfilemode_t mode, int number_of_bits=8) -> arrayfile_t
        __init__(arrayfile::arrayfile_t self, std::string const filename, int nrows, int ncols, int narrays=-1, arrayfile::arrayfilemode_t mode) -> arrayfile_t
        __init__(arrayfile::arrayfile_t self, std::string const filename, int nrows, int ncols, int narrays=-1) -> arrayfile_t
        __init__(arrayfile::arrayfile_t self, std::string const filename, int nrows, int ncols) -> arrayfile_t



        Structure for reading or writing a file with arrays  

        Open new array file for writing  

        Parameters
        ----------
        * `filename` :  
            File to open  
        * `nrows` :  
            Number of rows  
        * `ncols` :  
            Number of columns  
        * `narrays` :  
            Specify a number of arrays, or -1 to add dynamically  
        * `mode` :  
            File mode  
        * `number_of_bits` :  
            Number of bits to use for storage. For 2-level arrays only 1 bit is needed  

        """
        this = _oalib.new_arrayfile_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_arrayfile_t
    __del__ = lambda self: None

    def createfile(self, *args):
        """
        createfile(arrayfile_t self, std::string const filename, int nrows, int ncols, int narrays=-1, arrayfile::arrayfilemode_t m, int number_of_bits=8)
        createfile(arrayfile_t self, std::string const filename, int nrows, int ncols, int narrays=-1, arrayfile::arrayfilemode_t m)
        createfile(arrayfile_t self, std::string const filename, int nrows, int ncols, int narrays=-1)
        createfile(arrayfile_t self, std::string const filename, int nrows, int ncols)



        Open a new file for writing and (if opened) close the current file.  

        """
        return _oalib.arrayfile_t_createfile(self, *args)


    def closefile(self):
        """
        closefile(arrayfile_t self)



        close the array file  

        """
        return _oalib.arrayfile_t_closefile(self)


    def isopen(self):
        """
        isopen(arrayfile_t self) -> int



        return true if file is open  

        """
        return _oalib.arrayfile_t_isopen(self)


    def seek(self, pos):
        """
        seek(arrayfile_t self, int pos) -> int



        seek to specified array position  

        """
        return _oalib.arrayfile_t_seek(self, pos)


    def readnext(self):
        """
        readnext(arrayfile_t self) -> array_link



        read next array from the file  

        """
        return _oalib.arrayfile_t_readnext(self)


    def readarrays(self, *args):
        """
        readarrays(arrayfile_t self, int nmax, int verbose=1) -> arraylist_t
        readarrays(arrayfile_t self, int nmax) -> arraylist_t
        readarrays(arrayfile_t self) -> arraylist_t



        read set of array from the file  

        """
        return _oalib.arrayfile_t_readarrays(self, *args)


    def flush(self):
        """
        flush(arrayfile_t self)



        flush any open file pointer  

        """
        return _oalib.arrayfile_t_flush(self)


    def isbinary(self):
        """
        isbinary(arrayfile_t self) -> bool



        return true if the file has binary format  

        """
        return _oalib.arrayfile_t_isbinary(self)


    def append_arrays(self, arrays, startidx=-1):
        """
        append_arrays(arrayfile_t self, arraylist_t arrays, int startidx=-1) -> int
        append_arrays(arrayfile_t self, arraylist_t arrays) -> int



        append list of arrays to the file  

        """
        return _oalib.arrayfile_t_append_arrays(self, arrays, startidx)


    def append_array(self, a, specialindex=-1):
        """
        append_array(arrayfile_t self, array_link a, int specialindex=-1)
        append_array(arrayfile_t self, array_link a)



        append a single array to the file  

        """
        return _oalib.arrayfile_t_append_array(self, a, specialindex)


    def swigcheck(self):
        """
        swigcheck(arrayfile_t self) -> int



        return True if code is wrapper by SWIG  

        """
        return _oalib.arrayfile_t_swigcheck(self)


    def showstr(self):
        """
        showstr(arrayfile_t self) -> std::string



        return string describing the object  

        """
        return _oalib.arrayfile_t_showstr(self)


    def pos(self):
        """
        pos(arrayfile_t self) -> size_t



        return current position in file  

        """
        return _oalib.arrayfile_t_pos(self)


    def hasrandomaccess(self):
        """
        hasrandomaccess(arrayfile_t self) -> bool



        return true of the file format has random access mode  

        """
        return _oalib.arrayfile_t_hasrandomaccess(self)

    nfid = _swig_property(_oalib.arrayfile_t_nfid_get, _oalib.arrayfile_t_nfid_set)
    gzfid = _swig_property(_oalib.arrayfile_t_gzfid_get, _oalib.arrayfile_t_gzfid_set)
    verbose = _swig_property(_oalib.arrayfile_t_verbose_get, _oalib.arrayfile_t_verbose_set)

    def updatenumbers(self):
        """
        updatenumbers(arrayfile_t self)



        """
        return _oalib.arrayfile_t_updatenumbers(self)


    def read_array(self, *args):
        """
        read_array(arrayfile_t self, array_link a) -> int
        read_array(arrayfile_t self, array_t * array, int const nrows, int const ncols) -> int



        read array and return index  

        """
        return _oalib.arrayfile_t_read_array(self, *args)


    def finisharrayfile(self):
        """
        finisharrayfile(arrayfile_t self)



        """
        return _oalib.arrayfile_t_finisharrayfile(self)


    def setVerbose(self, v):
        """
        setVerbose(arrayfile_t self, int v)



        set verbosity level  

        """
        return _oalib.arrayfile_t_setVerbose(self, v)


    def getnbits(self):
        """
        getnbits(arrayfile_t self) -> int



        """
        return _oalib.arrayfile_t_getnbits(self)


    def parseModeString(format):
        """
        parseModeString(std::string const format) -> arrayfile::arrayfilemode_t



        parse string to determine the file mode  

        """
        return _oalib.arrayfile_t_parseModeString(format)

    parseModeString = staticmethod(parseModeString)

    def arrayNbits(*args):
        """
        arrayNbits(arraydata_t ad) -> int
        arrayNbits(array_link A) -> int



        return number of bits necessary to store an array  

        """
        return _oalib.arrayfile_t_arrayNbits(*args)

    arrayNbits = staticmethod(arrayNbits)

    def __repr__(self):
        """__repr__(arrayfile_t self) -> std::string"""
        return _oalib.arrayfile_t___repr__(self)

arrayfile_t_swigregister = _oalib.arrayfile_t_swigregister
arrayfile_t_swigregister(arrayfile_t)

def arrayfile_t_parseModeString(format):
    """
    arrayfile_t_parseModeString(std::string const format) -> arrayfile::arrayfilemode_t



    parse string to determine the file mode  

    """
    return _oalib.arrayfile_t_parseModeString(format)

def arrayfile_t_arrayNbits(*args):
    """
    arrayNbits(arraydata_t ad) -> int
    arrayfile_t_arrayNbits(array_link A) -> int



    return number of bits necessary to store an array  

    """
    return _oalib.arrayfile_t_arrayNbits(*args)


def nArrays(fname):
    """nArrays(char const * fname) -> long"""
    return _oalib.nArrays(fname)

def arrayfileinfo(filename, number_of_arrays, number_of_rows, number_of_columns):
    """arrayfileinfo(char const * filename, int & number_of_arrays, int & number_of_rows, int & number_of_columns)"""
    return _oalib.arrayfileinfo(filename, number_of_arrays, number_of_rows, number_of_columns)

def readarrayfile(*args):
    """
    readarrayfile(char const * fname, int verbose=0, int * setcols=None) -> arraylist_t
    readarrayfile(char const * fname, int verbose=0) -> arraylist_t
    readarrayfile(char const * fname) -> arraylist_t
    readarrayfile(char const * filename, arraylist_t arraylist, int verbose=1, int * setcols=None, int * setrows=None, int * setbits=None) -> int
    readarrayfile(char const * filename, arraylist_t arraylist, int verbose=1, int * setcols=None, int * setrows=None) -> int
    readarrayfile(char const * filename, arraylist_t arraylist, int verbose=1, int * setcols=None) -> int
    readarrayfile(char const * filename, arraylist_t arraylist, int verbose=1) -> int
    readarrayfile(char const * filename, arraylist_t arraylist) -> int
    """
    return _oalib.readarrayfile(*args)

def writearrayfile(*args):
    """
    writearrayfile(char const * filename, arraylist_t arraylist, arrayfile::arrayfilemode_t mode, int nrows, int ncols) -> int
    writearrayfile(char const * filename, arraylist_t arraylist, arrayfile::arrayfilemode_t mode, int nrows) -> int
    writearrayfile(char const * filename, arraylist_t arraylist, arrayfile::arrayfilemode_t mode) -> int
    writearrayfile(char const * filename, arraylist_t arraylist) -> int
    writearrayfile(char const * filename, array_link array, arrayfile::arrayfilemode_t mode) -> int
    writearrayfile(char const * filename, array_link array) -> int
    """
    return _oalib.writearrayfile(*args)

def append_arrayfile(filename, array):
    """append_arrayfile(char const * filename, array_link array) -> int"""
    return _oalib.append_arrayfile(filename, array)

def selectArrays(*args):
    """
    selectArrays(std::string const filename, intVector idx, arraylist_t fl, int verbose=0)
    selectArrays(std::string const filename, intVector idx, arraylist_t fl)
    selectArrays(std::string filename, int index) -> array_link
    selectArrays(arraylist_t input_list, intVector idx) -> arraylist_t
    selectArrays(arraylist_t input_list, longVector idx) -> arraylist_t
    selectArrays(arraylist_t input_list, intVector idx, arraylist_t output_list)
    selectArrays(arraylist_t input_list, longVector idx, arraylist_t output_list)
    """
    return _oalib.selectArrays(*args)

def appendArrays(arrays_to_append, dst):
    """appendArrays(arraylist_t arrays_to_append, arraylist_t dst)"""
    return _oalib.appendArrays(arrays_to_append, dst)

def convert_array_file(input_filename, output_filename, output_format, verbose=0):
    """
    convert_array_file(std::string input_filename, std::string output_filename, arrayfile::arrayfilemode_t output_format, int verbose=0)
    convert_array_file(std::string input_filename, std::string output_filename, arrayfile::arrayfilemode_t output_format)
    """
    return _oalib.convert_array_file(input_filename, output_filename, output_format, verbose)
class arraywriter_t(object):
    """


    structure to write arrays to disk, thread safe  

    C++ includes: arraytools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    afiles = _swig_property(_oalib.arraywriter_t_afiles_get, _oalib.arraywriter_t_afiles_set)
    writearrays = _swig_property(_oalib.arraywriter_t_writearrays_get, _oalib.arraywriter_t_writearrays_set)
    nwritten = _swig_property(_oalib.arraywriter_t_nwritten_get, _oalib.arraywriter_t_nwritten_set)
    verbose = _swig_property(_oalib.arraywriter_t_verbose_get, _oalib.arraywriter_t_verbose_set)

    def __init__(self):
        """
        __init__(arraywriter_t self) -> arraywriter_t



        """
        this = _oalib.new_arraywriter_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_arraywriter_t
    __del__ = lambda self: None

    def flush(self):
        """
        flush(arraywriter_t self)



        flush all output files  

        """
        return _oalib.arraywriter_t_flush(self)


    def writeArray(self, *args):
        """
        writeArray(arraywriter_t self, array_link A)
        writeArray(arraywriter_t self, arraylist_t lst)



        write a list of arrays to disk  

        """
        return _oalib.arraywriter_t_writeArray(self, *args)


    def initArrayFiles(self, *args):
        """
        initArrayFiles(arraywriter_t self, arraydata_t ad, int kstart, std::string const prefix, arrayfile::arrayfilemode_t mode)
        initArrayFiles(arraywriter_t self, arraydata_t ad, int kstart, std::string const prefix)



        initialize the result files  

        """
        return _oalib.arraywriter_t_initArrayFiles(self, *args)


    def nArraysWritten(self):
        """
        nArraysWritten(arraywriter_t self) -> int



        return the total number arrays written to disk  

        """
        return _oalib.arraywriter_t_nArraysWritten(self)


    def closeafiles(self):
        """
        closeafiles(arraywriter_t self)



        """
        return _oalib.arraywriter_t_closeafiles(self)

arraywriter_t_swigregister = _oalib.arraywriter_t_swigregister
arraywriter_t_swigregister(arraywriter_t)
cvar = _oalib.cvar
NRAUTO = cvar.NRAUTO


def readbinheader(fid, nr, nc):
    """readbinheader(FILE * fid, int & nr, int & nc) -> bool"""
    return _oalib.readbinheader(fid, nr, nc)

def writebinheader(fid, number_rows, number_columns):
    """writebinheader(FILE * fid, int number_rows, int number_columns)"""
    return _oalib.writebinheader(fid, number_rows, number_columns)

def vectorvector2binfile(fname, vals, writeheader, na):
    """vectorvector2binfile(std::string const fname, vector_vector_double vals, int writeheader, int na)"""
    return _oalib.vectorvector2binfile(fname, vals, writeheader, na)

def array2eigenX1(array, intercept=1):
    """
    array2eigenX1(array_link array, int intercept=1) -> MatrixFloat
    array2eigenX1(array_link array) -> MatrixFloat
    """
    return _oalib.array2eigenX1(array, intercept)

def array2eigenX2(array):
    """array2eigenX2(array_link array) -> MatrixFloat"""
    return _oalib.array2eigenX2(array)

def array2eigenModelMatrix(array):
    """array2eigenModelMatrix(array_link array) -> MatrixFloat"""
    return _oalib.array2eigenModelMatrix(array)

def array2eigenModelMatrixMixed(array, verbose=1):
    """
    array2eigenModelMatrixMixed(array_link array, int verbose=1) -> pairEigenMatrix
    array2eigenModelMatrixMixed(array_link array) -> pairEigenMatrix
    """
    return _oalib.array2eigenModelMatrixMixed(array, verbose)

def numberModelParams(array, order=-1):
    """
    numberModelParams(array_link array, int order=-1) -> intVector
    numberModelParams(array_link array) -> intVector
    """
    return _oalib.numberModelParams(array, order)

def arrayInFile(array, array_file, verbose=1):
    """
    arrayInFile(array_link array, char const * array_file, int verbose=1) -> int
    arrayInFile(array_link array, char const * array_file) -> int
    """
    return _oalib.arrayInFile(array, array_file, verbose)

def arrayInList(array, arrays, verbose=1):
    """
    arrayInList(array_link array, arraylist_t arrays, int verbose=1) -> int
    arrayInList(array_link array, arraylist_t arrays) -> int
    """
    return _oalib.arrayInList(array, arrays, verbose)

def printfd_handler(file, func, line, message):
    """
    printfd_handler(char const * file, char const * func, int line, char const * message)



    function to print debugging messages  

    """
    return _oalib.printfd_handler(file, func, line, message)
LOGERROR = _oalib.LOGERROR
SYSTEM = _oalib.SYSTEM
QUIET = _oalib.QUIET
NORMAL = _oalib.NORMAL
DEBUG = _oalib.DEBUG
EXTRADEBUG = _oalib.EXTRADEBUG

def log_print(level, message):
    """
    log_print(int const level, char const * message) -> int



    """
    return _oalib.log_print(level, message)

def getloglevel():
    """
    getloglevel() -> int



    return current level of logging  

    """
    return _oalib.getloglevel()

def setloglevel(n):
    """
    setloglevel(int n)



    reset the level of logging  

    """
    return _oalib.setloglevel(n)

def checkloglevel(level):
    """
    checkloglevel(int level) -> bool



    return True if the current logging level is smaller or equal than the specified
    level  

    """
    return _oalib.checkloglevel(level)

def system_uname():
    """
    system_uname() -> std::string



    Return string describing the system.  

    """
    return _oalib.system_uname()

def path_separator():
    """
    path_separator() -> char



    return path separator symbol for the current platform  

    """
    return _oalib.path_separator()

def mycheck_handler(file, func, line, condition, error_message):
    """
    mycheck_handler(char const * file, char const * func, int line, int condition, char const * error_message)



    handler for error messages. throws an std::runtime_error exception  

    """
    return _oalib.mycheck_handler(file, func, line, condition, error_message)

def myassert(condition, error_message):
    """
    myassert(int condition, char const * error_message)



    Check whether the condition is true and throw an expception otherwise.  

    """
    return _oalib.myassert(condition, error_message)

def cprintf(check, message):
    """
    cprintf(int check, char const * message) -> int



    conditional printf  

    """
    return _oalib.cprintf(check, message)

def flush_stdout():
    """
    flush_stdout()



    flush to stdout  

    """
    return _oalib.flush_stdout()

def next_comb_s(comb, k, n):
    """
    next_comb_s(int * comb, int k, int n) -> int



    Go to next combination in sequence  

    """
    return _oalib.next_comb_s(comb, k, n)

def print_array(*args):
    """
    print_array(char const * str, array_t const * array, int const nrows, int const ncols)
    print_array(array_t const * array, rowindex_t const nrows, colindex_t const ncols)



    """
    return _oalib.print_array(*args)

def get_time_ms(*args):
    """
    get_time_ms() -> double
    get_time_ms(double t0) -> double



    return time difference with milisecond precision  

    """
    return _oalib.get_time_ms(*args)

def trim(*args):
    """
    trim(std::string & str, std::string const & trimChars)
    trim(std::string & str)



    trim a string by removing the specified characters from the left and right  

    """
    return _oalib.trim(*args)

def currenttime():
    """
    currenttime() -> std::string



    return the current time as a string  

    """
    return _oalib.currenttime()

def oafilestring(arrayclass):
    """
    oafilestring(arraydata_t arrayclass) -> std::string



    return string describing array  

    """
    return _oalib.oafilestring(arrayclass)

def replaceString(subject, search, replacement):
    """
    replaceString(std::string subject, std::string const & search, std::string const & replacement) -> std::string



    replace all occurces of a substring in a string  

    """
    return _oalib.replaceString(subject, search, replacement)

def printdoubleasbits(double_value, add_newline=True):
    """
    printdoubleasbits(double double_value, bool add_newline=True)
    printdoubleasbits(double double_value)



    print a double value as bits  

    """
    return _oalib.printdoubleasbits(double_value, add_newline)

def splitDir(tag_indices):
    """
    splitDir(intVector tag_indices) -> std::string



    calculate directory name for job splitted into parts  

    """
    return _oalib.splitDir(tag_indices)

def splitFile(tag_indices):
    """
    splitFile(intVector tag_indices) -> std::string



    calculate file name of job splitted into parts  

    """
    return _oalib.splitFile(tag_indices)

def splitTag(tag_indices):
    """
    splitTag(intVector tag_indices) -> std::string



    calculate tag for job splitted into parts  

    """
    return _oalib.splitTag(tag_indices)

def DAEefficiencyWithSVD(secondorder_interaction_matrix, Deff, vif, Eeff, rank, verbose):
    """
    DAEefficiencyWithSVD(Eigen::MatrixXd const & secondorder_interaction_matrix, double & Deff, double & vif, double & Eeff, int & rank, int verbose)



    Calculate D-efficiency and VIF-efficiency and E-efficiency values using SVD.  

    """
    return _oalib.DAEefficiencyWithSVD(secondorder_interaction_matrix, Deff, vif, Eeff, rank, verbose)

def array2rank_Deff_Beff(al, ret=None, verbose=0):
    """
    array2rank_Deff_Beff(array_link al, doubleVector ret=None, int verbose=0) -> int
    array2rank_Deff_Beff(array_link al, doubleVector ret=None) -> int
    array2rank_Deff_Beff(array_link al) -> int



    Calculate the rank of the second order interaction matrix of an orthogonal array  

    The model is the intercept, main effects and interaction effects The rank,
    D-efficiency, VIF-efficiency and E-efficiency are appended to the second
    argument  

    The return vector is filled with the rank, Defficiency, VIF efficiency and
    Eefficiency  

    """
    return _oalib.array2rank_Deff_Beff(al, ret, verbose)

def Defficiency(orthogonal_array, verbose=0):
    """
    Defficiency(array_link orthogonal_array, int verbose=0) -> double
    Defficiency(array_link orthogonal_array) -> double



    Calculate D-efficiency for a 2-level array using symmetric eigenvalue
    decomposition.  

    """
    return _oalib.Defficiency(orthogonal_array, verbose)

def Defficiencies(array, arrayclass, verbose=0, addDs0=0):
    """
    Defficiencies(array_link array, arraydata_t arrayclass, int verbose=0, int addDs0=0) -> doubleVector
    Defficiencies(array_link array, arraydata_t arrayclass, int verbose=0) -> doubleVector
    Defficiencies(array_link array, arraydata_t arrayclass) -> doubleVector



    Calculate efficiencies for an array  

    Parameters
    ----------
    * `array` :  
        Array to use in calculation  
    * `arrayclass` :  
        Specification of the array class  
    * `verbose` :  
        Verbosity level  
    * `addDs0` :  
        If True, then add the Ds0-efficiency to the output  

    Returns
    -------
    Vector with the calculate D-efficiency, the main effect robustness (or Ds-
    optimality) and D1-efficiency for an orthogonal array  

    """
    return _oalib.Defficiencies(array, arrayclass, verbose, addDs0)

def VIFefficiency(orthogonal_array, verbose=0):
    """
    VIFefficiency(array_link orthogonal_array, int verbose=0) -> double
    VIFefficiency(array_link orthogonal_array) -> double



    Calculate VIF-efficiency of matrix.  

    """
    return _oalib.VIFefficiency(orthogonal_array, verbose)

def Aefficiency(orthogonal_array, verbose=0):
    """
    Aefficiency(array_link orthogonal_array, int verbose=0) -> double
    Aefficiency(array_link orthogonal_array) -> double



    Calculate A-efficiency of matrix.  

    """
    return _oalib.Aefficiency(orthogonal_array, verbose)

def Eefficiency(orthogonal_array, verbose=0):
    """
    Eefficiency(array_link orthogonal_array, int verbose=0) -> double
    Eefficiency(array_link orthogonal_array) -> double



    Calculate E-efficiency of matrix (1 over the VIF-efficiency)  

    """
    return _oalib.Eefficiency(orthogonal_array, verbose)

def Aefficiencies(orthogonal_array, verbose=0):
    """
    Aefficiencies(array_link orthogonal_array, int verbose=0) -> doubleVector
    Aefficiencies(array_link orthogonal_array) -> doubleVector



    calculate various A-efficiencies  

    """
    return _oalib.Aefficiencies(orthogonal_array, verbose)

def projDeff(array, number_of_factors, verbose=0):
    """
    projDeff(array_link array, int number_of_factors, int verbose=0) -> doubleVector
    projDeff(array_link array, int number_of_factors) -> doubleVector



    Calculate D-efficiencies for all projection designs  

    Parameters
    ----------
    * `array` :  
        Design to calculate D-efficiencies for  
    * `number_of_factors` :  
        Number of factors into which to project  
    * `verbose` :  
        Verbosity level  

    Returns
    -------
    Vector with calculated D-efficiencies  

    """
    return _oalib.projDeff(array, number_of_factors, verbose)

def PECsequence(array, verbose=0):
    """
    PECsequence(array_link array, int verbose=0) -> doubleVector
    PECsequence(array_link array) -> doubleVector



    Calculate the projection estimation capacity sequence for a design  

    Parameters
    ----------
    * `array` :  
        Input array  
    * `verbose` :  
        Verbosity level  

    Returns
    -------
    Vector with the caculated PEC sequence  

    The PECk of a design is the fraction of estimable second-order models in k
    factors. The vector (PEC1, PEC2, ..., ) is called the projection estimation
    capacity sequence. See "Ranking Non-regular Designs", J.L. Loeppky, 2004.  

    """
    return _oalib.PECsequence(array, verbose)

def PICsequence(array, verbose=0):
    """
    PICsequence(array_link array, int verbose=0) -> doubleVector
    PICsequence(array_link array) -> doubleVector



    Calculate the projection information capacity sequence for a design.  

    Parameters
    ----------
    * `array` :  
        Input array  
    * `verbose` :  
        Verbosity level  

    Returns
    -------
    Vector with the caculated PIC sequence  

    The PICk of a design is the average D-efficiency of estimable second-order
    models in k factors. The vector (PIC1, PIC2, ..., ) is called the PIC sequence.  

    """
    return _oalib.PICsequence(array, verbose)

def distance_distribution(array):
    """
    distance_distribution(array_link array) -> doubleVector



    Return the distance distribution of a design  

    The distance distribution is described in "Generalized minimum aberration for
    asymmetrical fractional factorial designs", Wu and Xu, 2001  

    """
    return _oalib.distance_distribution(array)

def Jcharacteristics(array, number_of_columns=4, verbose=0):
    """
    Jcharacteristics(array_link array, int number_of_columns=4, int verbose=0) -> intVector
    Jcharacteristics(array_link array, int number_of_columns=4) -> intVector
    Jcharacteristics(array_link array) -> intVector



    Calculate Jk-characteristics of a matrix  

    The calcualted Jk-values are signed.  

    Parameters
    ----------
    * `array` :  
        Array to calculate Jk-characteristics for  
    * `number_of_columns` :  
        Number of columns  
    * `verbose` :  
        Verbosity level  

    Returns
    -------
    Vector with calculated Jk-characteristics  

    """
    return _oalib.Jcharacteristics(array, number_of_columns, verbose)

def GWLP(array, verbose=0, truncate=1):
    """
    GWLP(array_link array, int verbose=0, int truncate=1) -> doubleVector
    GWLP(array_link array, int verbose=0) -> doubleVector
    GWLP(array_link array) -> doubleVector



    Calculate GWLP (generalized wordlength pattern)  

    The method used for calculation is from Xu and Wu (2001), "Generalized minimum
    aberration for asymmetrical
    fractional factorial desings". For non-symmetric arrays see "Algorithmic
    Construction of Efficient Fractional Factorial Designs With Large Run
    Sizes", Xu, Technometrics, 2009.  

    Parameters
    ----------
    * `array` :  
        Array to calculate the GWLP value for  
    * `verbose` :  
        Verbosity level  
    * `truncate` :  
        If True then round values near zero to solve double precision errors  

    Returns
    -------
    Vector with calculated generalized wordlength pattern  

    A more detailed description of the generalized wordlength pattern can also be
    found in the documentation at https://oapackage.readthedocs.io/.  

    """
    return _oalib.GWLP(array, verbose, truncate)

def GWLPmixed(array, verbose=0, truncate=1):
    """
    GWLPmixed(array_link array, int verbose=0, int truncate=1) -> doubleVector
    GWLPmixed(array_link array, int verbose=0) -> doubleVector
    GWLPmixed(array_link array) -> doubleVector



    Calculate GWLP (generalized wordlength pattern) for mixed-level arrays.  

    The method used for calculation is from "Algorithmic Construction of Efficient
    Fractional Factorial Designs With Large Run
    Sizes", Xu, Technometrics, 2009.  

    Parameters
    ----------
    * `array` :  
        Array to calculate the GWLP value for  
    * `verbose` :  
        Verbosity level  
    * `truncate` :  
        If True then round values near zero to solve double precision errors  

    Returns
    -------
    Vector with calculated generalized wordlength pattern  

    """
    return _oalib.GWLPmixed(array, verbose, truncate)

def projectionGWLPs(al):
    """
    projectionGWLPs(array_link al) -> vector_mvalue_t_double



    calculate delete-one-factor GWLP (generalized wordlength pattern) projections  

    """
    return _oalib.projectionGWLPs(al)

def sortGWLP(arg1):
    """
    sortGWLP(vector_mvalue_t_double arg1) -> vector_mvalue_t_double



    sort a list of GWLP values and return the sorted list  

    """
    return _oalib.sortGWLP(arg1)

def CL2discrepancy(array):
    """
    CL2discrepancy(array_link array) -> double



    Calculate centered L2-discrepancy of a design  

    The method is from "A connection between uniformity and aberration in regular
    fractions of two-level factorials", Fang and Mukerjee, 2000  

    """
    return _oalib.CL2discrepancy(array)

def array2secondorder(array):
    """
    array2secondorder(array_link array) -> array_link



    Calculate second order interaction model for 2-level array  

    Parameters
    ----------
    * `array` :  
        Array to calculate second order interaction model from  

    Returns
    -------
    Array interaction effects  

    """
    return _oalib.array2secondorder(array)

def array2xf(array):
    """
    array2xf(array_link array) -> array_link



    calculate second order interaction model for 2-level array  

    Parameters
    ----------
    * `array` :  
        Array to calculate second order interaction model from  

    Returns
    -------
    Array with intercept, main effects and interaction effects  

    """
    return _oalib.array2xf(array)
MODEL_CONSTANT = _oalib.MODEL_CONSTANT
MODEL_MAIN = _oalib.MODEL_MAIN
MODEL_INTERACTION = _oalib.MODEL_INTERACTION
MODEL_SECONDORDER = _oalib.MODEL_SECONDORDER
MODEL_INVALID = _oalib.MODEL_INVALID

def conference_design2modelmatrix(conference_design, mode, verbose=0):
    """
    conference_design2modelmatrix(array_link conference_design, char const * mode, int verbose=0) -> array_link
    conference_design2modelmatrix(array_link conference_design, char const * mode) -> array_link



    Calculate model matrix for a conference design  

    Parameters
    ----------
    * `conference_design` :  
        Conference design  
    * `mode` :  
        Can be 'm' for main effects, 'i' for interaction effects or 'q' for
        quadratic effects  
    * `verbose` :  
        Verbosity level  

    Returns
    -------
    Calculated model matrix  

    """
    return _oalib.conference_design2modelmatrix(conference_design, mode, verbose)

def array2modelmatrix(array, mode, verbose=0):
    """
    array2modelmatrix(array_link array, char const * mode, int verbose=0) -> Eigen::MatrixXd
    array2modelmatrix(array_link array, char const * mode) -> Eigen::MatrixXd



    Convert orthogonal array or conference design to model matrix  

    The model matrix consists of the intercept, main effects and (optionally) the
    interaction effects and quadratic effects. The order in the interaction effects
    is (c1, c2)=(0,0), (1,0), (2,0), (2,1), ... with c2<c1 for columns c1, c2. The
    size of the model matrix calculated by this function is given by
    array2modelmatrix_sizes.  

    Parameters
    ----------
    * `array` :  
        Orthogonal array or conference design  
    * `mode` :  
        Type of model matrix to calculate. Can be 'm' for main effects, 'i' for
        interaction effects or 'q' for quadratic effects  
    * `verbose` :  
        Verbosity level  

    Returns
    -------
    Calculated model matrix  

    For conference designs the method conference_design2modelmatrix is used. For
    orthogonal array the calculated is performed with array2eigenModelMatrixMixed.  

    """
    return _oalib.array2modelmatrix(array, mode, verbose)

def array2modelmatrix_sizes(array):
    """
    array2modelmatrix_sizes(array_link array) -> intVector



    Return the sizes of the model matrices calculated  

    Parameters
    ----------
    * `array` :  
        Orthogonal array or conference designs  

    Returns
    -------
    List with the sizes of the model matrix for: only intercept; intercept, main;
    intercept, main, and iteraction terms, intercept, main and full second order  

    """
    return _oalib.array2modelmatrix_sizes(array)

def array2xfeigen(array):
    """
    array2xfeigen(array_link array) -> Eigen::MatrixXd



    calculate second order interaction model for 2-level array  

    Parameters
    ----------
    * `array` :  
        Array to calculate second order interaction model from  

    Returns
    -------
    Array with intercept, main effects and interaction effects  

    """
    return _oalib.array2xfeigen(array)

def arrayrankFullPivQR(al, threshold=-1):
    """
    arrayrankFullPivQR(array_link al, double threshold=-1) -> int
    arrayrankFullPivQR(array_link al) -> int



    return rank of an array based on Eigen::FullPivHouseholderQR  

    """
    return _oalib.arrayrankFullPivQR(al, threshold)

def arrayrankColPivQR(al, threshold=-1):
    """
    arrayrankColPivQR(array_link al, double threshold=-1) -> int
    arrayrankColPivQR(array_link al) -> int



    return rank of an array based on Eigen::ColPivHouseholderQR  

    """
    return _oalib.arrayrankColPivQR(al, threshold)

def arrayrankFullPivLU(al, threshold=-1):
    """
    arrayrankFullPivLU(array_link al, double threshold=-1) -> int
    arrayrankFullPivLU(array_link al) -> int



    return rank of an array based on Eigen::FullPivLU  

    """
    return _oalib.arrayrankFullPivLU(al, threshold)

def arrayrankSVD(al, threshold=-1):
    """
    arrayrankSVD(array_link al, double threshold=-1) -> int
    arrayrankSVD(array_link al) -> int



    return rank of an array based on Eigen::JacobiSVD  

    """
    return _oalib.arrayrankSVD(al, threshold)

def arrayrank(array):
    """
    arrayrank(array_link array) -> int



    calculate the rank of an array  

    """
    return _oalib.arrayrank(array)

def arrayrankInfo(*args):
    """
    arrayrankInfo(Eigen::MatrixXd const & arg1, int verbose=1) -> int
    arrayrankInfo(Eigen::MatrixXd const & arg1) -> int
    arrayrankInfo(array_link array, int verbose=1) -> int
    arrayrankInfo(array_link array) -> int



    Return rank of an array. Information about the different methods for rank
    calculation is printed to stdout.  

    """
    return _oalib.arrayrankInfo(*args)

def arraylink2eigen(array):
    """
    arraylink2eigen(array_link array) -> Eigen::MatrixXd



    convert array_link to Eigen matrix  

    """
    return _oalib.arraylink2eigen(array)
class rankStructure(object):
    """


    Structure to efficiently calculate the rank of the second order interaction
    matrix of many arrays  

    The efficiency is obtained if the arrays share a common subarray. The theory is
    described in "Efficient rank calculation for matrices with a common
    submatrix", Eendebak, 2016  

    C++ includes: arrayproperties.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    alsub = _swig_property(_oalib.rankStructure_alsub_get, _oalib.rankStructure_alsub_set)
    r = _swig_property(_oalib.rankStructure_r_get, _oalib.rankStructure_r_set)
    verbose = _swig_property(_oalib.rankStructure_verbose_get, _oalib.rankStructure_verbose_set)
    ks = _swig_property(_oalib.rankStructure_ks_get, _oalib.rankStructure_ks_set)
    nsub = _swig_property(_oalib.rankStructure_nsub_get, _oalib.rankStructure_nsub_set)
    id = _swig_property(_oalib.rankStructure_id_get, _oalib.rankStructure_id_set)

    def __init__(self, *args):
        """
        __init__(rankStructure self, array_link al, int nsub=3, int verbose=0) -> rankStructure
        __init__(rankStructure self, array_link al, int nsub=3) -> rankStructure
        __init__(rankStructure self, array_link al) -> rankStructure
        __init__(rankStructure self, int nsub=3, int id=-1) -> rankStructure
        __init__(rankStructure self, int nsub=3) -> rankStructure
        __init__(rankStructure self) -> rankStructure



        constructor  

        """
        this = _oalib.new_rankStructure(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def info(self):
        """
        info(rankStructure self)



        print information about the rank structure  

        """
        return _oalib.rankStructure_info(self)


    def updateStructure(self, al):
        """
        updateStructure(rankStructure self, array_link al)



        update the structure cache with a new array  

        """
        return _oalib.rankStructure_updateStructure(self, al)


    def rankdirect(self, array):
        """
        rankdirect(rankStructure self, Eigen::MatrixXd const & array) -> int



        calculate the rank of an array directly, uses special threshold  

        """
        return _oalib.rankStructure_rankdirect(self, array)


    def rankxfdirect(self, array):
        """
        rankxfdirect(rankStructure self, array_link array) -> int



        calculate the rank of the second order interaction matrix of an array directly  

        """
        return _oalib.rankStructure_rankxfdirect(self, array)


    def rankxf(self, array):
        """
        rankxf(rankStructure self, array_link array) -> int



        calculate the rank of the second order interaction matrix of an array using the
        cache system  

        """
        return _oalib.rankStructure_rankxf(self, array)

    __swig_destroy__ = _oalib.delete_rankStructure
    __del__ = lambda self: None
rankStructure_swigregister = _oalib.rankStructure_swigregister
rankStructure_swigregister(rankStructure)


def conditionNumber(matrix):
    """
    conditionNumber(array_link matrix) -> double



    return the condition number of a matrix  

    """
    return _oalib.conditionNumber(matrix)
PARETOFUNCTION_DEFAULT = _oalib.PARETOFUNCTION_DEFAULT
PARETOFUNCTION_J5 = _oalib.PARETOFUNCTION_J5

def calculateParetoEvenOdd(*args):
    """
    calculateParetoEvenOdd(stringVector infiles, char const * outfile, int verbose=1, arrayfile::arrayfilemode_t afmode, int nrows=-1, int ncols=-1, paretomethod_t paretomethod=PARETOFUNCTION_DEFAULT)
    calculateParetoEvenOdd(stringVector infiles, char const * outfile, int verbose=1, arrayfile::arrayfilemode_t afmode, int nrows=-1, int ncols=-1)
    calculateParetoEvenOdd(stringVector infiles, char const * outfile, int verbose=1, arrayfile::arrayfilemode_t afmode, int nrows=-1)
    calculateParetoEvenOdd(stringVector infiles, char const * outfile, int verbose=1, arrayfile::arrayfilemode_t afmode)
    calculateParetoEvenOdd(stringVector infiles, char const * outfile, int verbose=1)
    calculateParetoEvenOdd(stringVector infiles, char const * outfile)



    Calculate the Pareto optimal arrays from a list of array files  

    Pareto optimality is calculated according to (rank; A3,A4; F4)  

    """
    return _oalib.calculateParetoEvenOdd(*args)

def parsePareto(arraylist, verbose, paretomethod=PARETOFUNCTION_DEFAULT):
    """
    parsePareto(arraylist_t arraylist, int verbose, paretomethod_t paretomethod=PARETOFUNCTION_DEFAULT) -> ParetoMultiLongLong
    parsePareto(arraylist_t arraylist, int verbose) -> ParetoMultiLongLong



    """
    return _oalib.parsePareto(arraylist, verbose, paretomethod)

def A3A4(al):
    """
    A3A4(array_link al) -> mvalue_t_long



    calculate A3 and A4 value for array  

    Parameters
    ----------
    * `al` :  
        Array for which to calculate A3 and A4  

    Returns
    -------
    Object with A3 and A4  

    """
    return _oalib.A3A4(al)

def F4(al, verbose=1):
    """
    F4(array_link al, int verbose=1) -> mvalue_t_long
    F4(array_link al) -> mvalue_t_long



    calculate F4 value for 2-level array  

    """
    return _oalib.F4(al, verbose)

def Cvalue2Dvalue(Cvalue, number_of_columns):
    """
    Cvalue2Dvalue(double Cvalue, int number_of_columns) -> double



    convert C value to D-efficiency value  

    """
    return _oalib.Cvalue2Dvalue(Cvalue, number_of_columns)

def Dvalue2Cvalue(Defficiency, number_of_columns):
    """
    Dvalue2Cvalue(double Defficiency, int number_of_columns) -> double



    convert D-efficiency value to C value  

    """
    return _oalib.Dvalue2Cvalue(Defficiency, number_of_columns)

def md5(*args):
    """
    md5(void * data, int number_of_bytes) -> std::string
    md5(std::string const filename) -> std::string



    calculate md5 sum of a file on disk  

    """
    return _oalib.md5(*args)

def scoreD(efficiencies, weights):
    """
    scoreD(doubleVector efficiencies, doubleVector weights) -> double



    Calculate score from a set of efficiencies  

    The score is the weighted sum of the efficiencies.  

    Parameters
    ----------
    * `efficiencies` :  
        Vector with calculated efficiencies  
    * `weights` :  
        Weights for the efficiencies  

    Returns
    -------
    Weighted sum of the efficiencies  

    """
    return _oalib.scoreD(efficiencies, weights)
DOPTIM_UPDATE = _oalib.DOPTIM_UPDATE
DOPTIM_SWAP = _oalib.DOPTIM_SWAP
DOPTIM_FLIP = _oalib.DOPTIM_FLIP
DOPTIM_AUTOMATIC = _oalib.DOPTIM_AUTOMATIC
DOPTIM_NONE = _oalib.DOPTIM_NONE
class DoptimReturn(object):
    """


    Structure containing results of the Doptimize function  

    C++ includes: Deff.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    dds = _swig_property(_oalib.DoptimReturn_dds_get, _oalib.DoptimReturn_dds_set)
    designs = _swig_property(_oalib.DoptimReturn_designs_get, _oalib.DoptimReturn_designs_set)
    nrestarts = _swig_property(_oalib.DoptimReturn_nrestarts_get, _oalib.DoptimReturn_nrestarts_set)
    _nimproved = _swig_property(_oalib.DoptimReturn__nimproved_get, _oalib.DoptimReturn__nimproved_set)

    def __init__(self):
        """
        __init__(DoptimReturn self) -> DoptimReturn



        Structure containing results of the Doptimize function  

        C++ includes: Deff.h

        """
        this = _oalib.new_DoptimReturn()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_DoptimReturn
    __del__ = lambda self: None
DoptimReturn_swigregister = _oalib.DoptimReturn_swigregister
DoptimReturn_swigregister(DoptimReturn)


def Doptimize(arrayclass, nrestarts, alpha, verbose, method=DOPTIM_AUTOMATIC, niter=300000, maxtime=100000, nabort=5000):
    """
    Doptimize(arraydata_t arrayclass, int nrestarts, doubleVector alpha, int verbose, coordinate_exchange_method_t method=DOPTIM_AUTOMATIC, int niter=300000, double maxtime=100000, int nabort=5000) -> DoptimReturn
    Doptimize(arraydata_t arrayclass, int nrestarts, doubleVector alpha, int verbose, coordinate_exchange_method_t method=DOPTIM_AUTOMATIC, int niter=300000, double maxtime=100000) -> DoptimReturn
    Doptimize(arraydata_t arrayclass, int nrestarts, doubleVector alpha, int verbose, coordinate_exchange_method_t method=DOPTIM_AUTOMATIC, int niter=300000) -> DoptimReturn
    Doptimize(arraydata_t arrayclass, int nrestarts, doubleVector alpha, int verbose, coordinate_exchange_method_t method=DOPTIM_AUTOMATIC) -> DoptimReturn
    Doptimize(arraydata_t arrayclass, int nrestarts, doubleVector alpha, int verbose) -> DoptimReturn



    Generates optimal designs for the specified class of designs  

    The method uses a coordinate-exchange algorithm to optimze a target function
    defined by the optimziation paramaters. The optimization is performed multiple
    times to prevent finding a design in a local minmum of the target function.  

    The method is described in more detail in "Two-Level Designs to Estimate All
    Main Effects and Two-Factor Interactions", Eendebak et al., 2015,
    Technometrics, https://doi.org/10.1080/00401706.2016.1142903.  

    Parameters
    ----------
    * `arrayclass` :  
        Class of designs to optimize  
    * `nrestarts` :  
        Number of restarts to perform  
    * `alpha` :  
        Optimization parameters. The target function is alpha_1 D + alpha_2 D_s +
        alpha D_1  
    * `verbose` :  
        Verbosity level  
    * `method` :  
        Method for optimization algorithm  
    * `niter` :  
        Maximum number of iterations for each restart  
    * `maxtime` :  
        Maximum calculation time. If this time is exceeded, the function is aborted  
    * `nabort` :  
        Maximum number of iterations when no improvement is found  

    Returns
    -------
    A structure with the generated optimal designs  

    """
    return _oalib.Doptimize(arrayclass, nrestarts, alpha, verbose, method, niter, maxtime, nabort)

def DoptimizeMixed(sols, arrayclass, alpha, verbose=1, nabort=-1):
    """
    DoptimizeMixed(arraylist_t sols, arraydata_t arrayclass, doubleVector alpha, int verbose=1, int nabort=-1) -> DoptimReturn
    DoptimizeMixed(arraylist_t sols, arraydata_t arrayclass, doubleVector alpha, int verbose=1) -> DoptimReturn
    DoptimizeMixed(arraylist_t sols, arraydata_t arrayclass, doubleVector alpha) -> DoptimReturn



    Function to generate optimal designs with mixed optimization approach  

    This function is beta code. See Doptimize for detauls of the parameters.  

    """
    return _oalib.DoptimizeMixed(sols, arrayclass, alpha, verbose, nabort)

def optimDeff(array, arrayclass, alpha, verbose=1, optimmethod=DOPTIM_AUTOMATIC, niter=100000, nabort=0):
    """
    optimDeff(array_link array, arraydata_t arrayclass, doubleVector alpha, int verbose=1, coordinate_exchange_method_t optimmethod=DOPTIM_AUTOMATIC, int niter=100000, int nabort=0) -> array_link
    optimDeff(array_link array, arraydata_t arrayclass, doubleVector alpha, int verbose=1, coordinate_exchange_method_t optimmethod=DOPTIM_AUTOMATIC, int niter=100000) -> array_link
    optimDeff(array_link array, arraydata_t arrayclass, doubleVector alpha, int verbose=1, coordinate_exchange_method_t optimmethod=DOPTIM_AUTOMATIC) -> array_link
    optimDeff(array_link array, arraydata_t arrayclass, doubleVector alpha, int verbose=1) -> array_link
    optimDeff(array_link array, arraydata_t arrayclass, doubleVector alpha) -> array_link



    Optimize a design according to the optimization function specified.  

    Arguments:  

    Parameters
    ----------
    * `array` :  
        Array to be optimized  
    * `arrayclass` :  
        Structure describing the design class  
    * `alpha` :  
        3x1 array with optimization parameters  
    * `verbose` :  
        Verbosity level  
    * `optimmethod` :  
        Optimization method to use  
    * `niter` :  
        Number of iterations  
    * `nabort` :  
        Number of iterations after which to abort when no improvements are found  

    Returns
    -------
    Optimized designs  

    """
    return _oalib.optimDeff(array, arrayclass, alpha, verbose, optimmethod, niter, nabort)
class OAextend(object):
    """


    Options for the extend code.  

    class containing parameters of the extension and LMC algorithm  

    C++ includes: extend.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    singleExtendTime = _swig_property(_oalib.OAextend_singleExtendTime_get, _oalib.OAextend_singleExtendTime_set)
    nLMC = _swig_property(_oalib.OAextend_nLMC_get, _oalib.OAextend_nLMC_set)
    checkarrays = _swig_property(_oalib.OAextend_checkarrays_get, _oalib.OAextend_checkarrays_set)
    check_maximal = _swig_property(_oalib.OAextend_check_maximal_get, _oalib.OAextend_check_maximal_set)
    use_row_symmetry = _swig_property(_oalib.OAextend_use_row_symmetry_get, _oalib.OAextend_use_row_symmetry_set)
    init_column_previous = _swig_property(_oalib.OAextend_init_column_previous_get, _oalib.OAextend_init_column_previous_set)
    APPENDEXTENSION = _oalib.OAextend_APPENDEXTENSION
    APPENDFULL = _oalib.OAextend_APPENDFULL
    STOREARRAY = _oalib.OAextend_STOREARRAY
    NONE = _oalib.OAextend_NONE
    extendarraymode = _swig_property(_oalib.OAextend_extendarraymode_get, _oalib.OAextend_extendarraymode_set)
    storefile = _swig_property(_oalib.OAextend_storefile_get, _oalib.OAextend_storefile_set)
    j5structure = _swig_property(_oalib.OAextend_j5structure_get, _oalib.OAextend_j5structure_set)

    def __init__(self, *args):
        """
        __init__(OAextend self) -> OAextend
        __init__(OAextend self, OAextend o) -> OAextend
        __init__(OAextend self, arraydata_t arrayclass) -> OAextend



        Options for the extension algorithm  

        The algorithm is automatically determined from the specified arrayclass.  

        """
        this = _oalib.new_OAextend(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def setAlgorithm(self, algorithm, ad=None):
        """
        setAlgorithm(OAextend self, algorithm_t algorithm, arraydata_t ad=None)
        setAlgorithm(OAextend self, algorithm_t algorithm)



        Set the algorithm to use for LMC checks.  

        """
        return _oalib.OAextend_setAlgorithm(self, algorithm, ad)


    def setAlgorithmAuto(self, ad=None):
        """
        setAlgorithmAuto(OAextend self, arraydata_t ad=None)
        setAlgorithmAuto(OAextend self)



        Set the algorithm automatically.  

        """
        return _oalib.OAextend_setAlgorithmAuto(self, ad)


    def getAlgorithm(self):
        """
        getAlgorithm(OAextend self) -> algorithm_t



        Return algorithm used.  

        """
        return _oalib.OAextend_getAlgorithm(self)


    def getAlgorithmName(self):
        """
        getAlgorithmName(OAextend self) -> std::string



        Return algorithm used (as string)  

        """
        return _oalib.OAextend_getAlgorithmName(self)


    def updateArraydata(self, arrayclass=None):
        """
        updateArraydata(OAextend self, arraydata_t arrayclass=None)
        updateArraydata(OAextend self)



        update the options structuer with the specified class of designs  

        """
        return _oalib.OAextend_updateArraydata(self, arrayclass)


    def getPreferredAlgorithm(arrayclass, verbose=0):
        """
        getPreferredAlgorithm(arraydata_t arrayclass, int verbose=0) -> algorithm_t
        getPreferredAlgorithm(arraydata_t arrayclass) -> algorithm_t



        return preferred extension algorithm  

               \param arrayclass Class of designs to extend
               \param verbose Verbosity level


        """
        return _oalib.OAextend_getPreferredAlgorithm(arrayclass, verbose)

    getPreferredAlgorithm = staticmethod(getPreferredAlgorithm)

    def info(self, verbose=1):
        """
        info(OAextend self, int verbose=1)
        info(OAextend self)



        print configuration to stdout  

        """
        return _oalib.OAextend_info(self, verbose)


    def __repr__(self):
        """
        __repr__(OAextend self) -> std::string



        """
        return _oalib.OAextend___repr__(self)

    __swig_destroy__ = _oalib.delete_OAextend
    __del__ = lambda self: None
OAextend_swigregister = _oalib.OAextend_swigregister
OAextend_swigregister(OAextend)

def OAextend_getPreferredAlgorithm(arrayclass, verbose=0):
    """
    getPreferredAlgorithm(arraydata_t arrayclass, int verbose=0) -> algorithm_t
    OAextend_getPreferredAlgorithm(arraydata_t arrayclass) -> algorithm_t



    return preferred extension algorithm  

           \param arrayclass Class of designs to extend
           \param verbose Verbosity level


    """
    return _oalib.OAextend_getPreferredAlgorithm(arrayclass, verbose)


def extend_arraylist(*args):
    """
    extend_arraylist(arraylist_t array_list, arraydata_t array_class, OAextend oaextend_options) -> arraylist_t
    extend_arraylist(arraylist_t array_list, arraydata_t arrayclass) -> arraylist_t
    extend_arraylist(arraylist_t array_list, arraydata_t array_class, OAextend oaextend_options, colindex_t extensioncol, arraylist_t extensions) -> int



    Extend a list of orthogonal arrays  

    Parameters
    ----------
    * `array_list` :  
        The list of arrays to be extended  
    * `array_class` :  
        Class of arrays to generate  
    * `oaextend_options` :  
        Parameters for the extension algorithm  

    Returns
    -------
    List of all generated arrays  

    See also: extend_array(const array_link &, arraydata_t &, OAextend const &)  

    Parameters
    ----------
    * `extensioncol` :  
        Index of column to be added to the designs  
    * `extensions` :  
        List to append generated designs to  

    Returns
    -------
    Number of candidate arrays generated  

    """
    return _oalib.extend_arraylist(*args)

def extend_array(*args):
    """
    extend_array(array_link array, arraydata_t array_class, OAextend oaextend) -> arraylist_t
    extend_array(array_link array, arraydata_t arrayclass) -> arraylist_t
    extend_array(array_link array, arraydata_t arrayclass, colindex_t const extension_column, arraylist_t extensions, OAextend oaextend) -> int



    Extend an orthogonal array with a single column  

    See also: extend_array(const array_link &, arraydata_t &, OAextend const &)  

    Parameters
    ----------
    * `array` :  
        Array to extend  
    * `arrayclass` :  
        Array data for the full array  
    * `extension_column` :  
        Column to extend  
    * `extensions` :  
        List to which generated valid extensions are added  
    * `oaextend` :  
        Structure with options  

    Returns
    -------
    Number of candidate extensions generated  

    """
    return _oalib.extend_array(*args)

def runExtendRoot(arrayclass, max_number_columns, verbose=0):
    """
    runExtendRoot(arraydata_t arrayclass, int max_number_columns, int verbose=0) -> arraylist_t
    runExtendRoot(arraydata_t arrayclass, int max_number_columns) -> arraylist_t



    Run the LMC extension algorithm starting with the root array  

    See also: extend_array(const array_link &, arraydata_t &, OAextend const &)  

    """
    return _oalib.runExtendRoot(arrayclass, max_number_columns, verbose)
DFILTER_NONE = _oalib.DFILTER_NONE
DFILTER_BASIC = _oalib.DFILTER_BASIC
DFILTER_MULTI = _oalib.DFILTER_MULTI
DCALC_ALWAYS = _oalib.DCALC_ALWAYS
DCALC_COND = _oalib.DCALC_COND
class dextend_t(object):
    """


    Structure for dynamic extension of arrays based on D-efficiencies.  

    C++ includes: extend.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    NO_VALUE = _oalib.dextend_t_NO_VALUE
    lmctype = _swig_property(_oalib.dextend_t_lmctype_get, _oalib.dextend_t_lmctype_set)
    lastcol = _swig_property(_oalib.dextend_t_lastcol_get, _oalib.dextend_t_lastcol_set)
    Deff = _swig_property(_oalib.dextend_t_Deff_get, _oalib.dextend_t_Deff_set)
    filter = _swig_property(_oalib.dextend_t_filter_get, _oalib.dextend_t_filter_set)
    filtermode = _swig_property(_oalib.dextend_t_filtermode_get, _oalib.dextend_t_filtermode_set)
    Dcheck = _swig_property(_oalib.dextend_t_Dcheck_get, _oalib.dextend_t_Dcheck_set)
    directcheck = _swig_property(_oalib.dextend_t_directcheck_get, _oalib.dextend_t_directcheck_set)

    def __init__(self):
        """
        __init__(dextend_t self) -> dextend_t



        """
        this = _oalib.new_dextend_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, nn):
        """
        resize(dextend_t self, int nn)



        """
        return _oalib.dextend_t_resize(self, nn)


    def DefficiencyFilter(self, Dfinal, k, kfinal, Lmax, verbose=1):
        """
        DefficiencyFilter(dextend_t self, double Dfinal, int k, int kfinal, double Lmax, int verbose=1)
        DefficiencyFilter(dextend_t self, double Dfinal, int k, int kfinal, double Lmax)



        perform filtering using D-efficiency  

        """
        return _oalib.dextend_t_DefficiencyFilter(self, Dfinal, k, kfinal, Lmax, verbose)


    def filterArrays(self, al, earrays, earraysout, edata, verbose=1):
        """
        filterArrays(dextend_t self, array_link al, arraylist_t earrays, arraylist_t earraysout, vector_vector_double edata, int verbose=1) -> intVector
        filterArrays(dextend_t self, array_link al, arraylist_t earrays, arraylist_t earraysout, vector_vector_double edata) -> intVector



        filter the arrays based on values in filter  

        """
        return _oalib.dextend_t_filterArrays(self, al, earrays, earraysout, edata, verbose)

    ntotal = _swig_property(_oalib.dextend_t_ntotal_get, _oalib.dextend_t_ntotal_set)
    nlmc = _swig_property(_oalib.dextend_t_nlmc_get, _oalib.dextend_t_nlmc_set)
    n = _swig_property(_oalib.dextend_t_n_get, _oalib.dextend_t_n_set)
    DmaxDiscard = _swig_property(_oalib.dextend_t_DmaxDiscard_get, _oalib.dextend_t_DmaxDiscard_set)
    nmaxrnktotal = _swig_property(_oalib.dextend_t_nmaxrnktotal_get, _oalib.dextend_t_nmaxrnktotal_set)
    __swig_destroy__ = _oalib.delete_dextend_t
    __del__ = lambda self: None
dextend_t_swigregister = _oalib.dextend_t_swigregister
dextend_t_swigregister(dextend_t)

LMC_LESS = _oalib.LMC_LESS
LMC_EQUAL = _oalib.LMC_EQUAL
LMC_MORE = _oalib.LMC_MORE
LMC_NONSENSE = _oalib.LMC_NONSENSE
MODE_LMC = _oalib.MODE_LMC
MODE_J4 = _oalib.MODE_J4
MODE_J5ORDER = _oalib.MODE_J5ORDER
MODE_J5ORDERX = _oalib.MODE_J5ORDERX
MODE_INVALID = _oalib.MODE_INVALID
MODE_AUTOSELECT = _oalib.MODE_AUTOSELECT
MODE_LMC_SYMMETRY = _oalib.MODE_LMC_SYMMETRY
MODE_LMC_2LEVEL = _oalib.MODE_LMC_2LEVEL
MODE_LMC_DEBUG = _oalib.MODE_LMC_DEBUG
MODE_J5ORDER_2LEVEL = _oalib.MODE_J5ORDER_2LEVEL

def algorithm_t_list():
    """
    algorithm_t_list() -> std::string



    """
    return _oalib.algorithm_t_list()
INITCOLUMN_ZERO = _oalib.INITCOLUMN_ZERO
INITCOLUMN_PREVIOUS = _oalib.INITCOLUMN_PREVIOUS
INITCOLUMN_J5 = _oalib.INITCOLUMN_J5
J5_ORIGINAL = _oalib.J5_ORIGINAL
J5_45 = _oalib.J5_45

def algnames(m):
    """
    algnames(algorithm_t m) -> std::string



    return name of the algorithm  

    """
    return _oalib.algnames(m)
class rowsort_t(object):
    """Proxy of C++ rowsort_t class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    r = _swig_property(_oalib.rowsort_t_r_get, _oalib.rowsort_t_r_set)
    val = _swig_property(_oalib.rowsort_t_val_get, _oalib.rowsort_t_val_set)

    def __init__(self):
        """__init__(rowsort_t self) -> rowsort_t"""
        this = _oalib.new_rowsort_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_rowsort_t
    __del__ = lambda self: None
rowsort_t_swigregister = _oalib.rowsort_t_swigregister
rowsort_t_swigregister(rowsort_t)
MODE_ORIGINAL = cvar.MODE_ORIGINAL


def __lt__(a, b):
    """__lt__(rowsort_t a, rowsort_t b) -> bool"""
    return _oalib.__lt__(a, b)

def __gt__(a, b):
    """__gt__(rowsort_t a, rowsort_t b) -> bool"""
    return _oalib.__gt__(a, b)

def apply_hadamard(al, hcolumn):
    """
    apply_hadamard(array_link al, colindex_t hcolumn)



    Apply Hadamard transformation to orthogonal array.  

    """
    return _oalib.apply_hadamard(al, hcolumn)
class LMCreduction_helper_t(object):
    """


    Contains structures used by the LMC reduction or LMC check.  

    Part of the allocations is for structures that are constant and are re-used each
    time an LMC calculation is performed. Some other structures are temporary
    buffers that are written to all the time.  

    C++ includes: lmc.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    LMC_non_root_init = _swig_property(_oalib.LMCreduction_helper_t_LMC_non_root_init_get, _oalib.LMCreduction_helper_t_LMC_non_root_init_set)
    LMC_root_init = _swig_property(_oalib.LMCreduction_helper_t_LMC_root_init_get, _oalib.LMCreduction_helper_t_LMC_root_init_set)
    LMC_reduce_root_rowperms_init = _swig_property(_oalib.LMCreduction_helper_t_LMC_reduce_root_rowperms_init_get, _oalib.LMCreduction_helper_t_LMC_reduce_root_rowperms_init_set)
    ad = _swig_property(_oalib.LMCreduction_helper_t_ad_get, _oalib.LMCreduction_helper_t_ad_set)
    LMC_root_rowperms_init = _swig_property(_oalib.LMCreduction_helper_t_LMC_root_rowperms_init_get, _oalib.LMCreduction_helper_t_LMC_root_rowperms_init_set)
    nrootrowperms = _swig_property(_oalib.LMCreduction_helper_t_nrootrowperms_get, _oalib.LMCreduction_helper_t_nrootrowperms_set)
    rootrowperms = _swig_property(_oalib.LMCreduction_helper_t_rootrowperms_get, _oalib.LMCreduction_helper_t_rootrowperms_set)
    LMC_root_rowperms_init_full = _swig_property(_oalib.LMCreduction_helper_t_LMC_root_rowperms_init_full_get, _oalib.LMCreduction_helper_t_LMC_root_rowperms_init_full_set)
    nrootrowperms_full = _swig_property(_oalib.LMCreduction_helper_t_nrootrowperms_full_get, _oalib.LMCreduction_helper_t_nrootrowperms_full_set)
    rootrowperms_full = _swig_property(_oalib.LMCreduction_helper_t_rootrowperms_full_get, _oalib.LMCreduction_helper_t_rootrowperms_full_set)
    colbuffer = _swig_property(_oalib.LMCreduction_helper_t_colbuffer_get, _oalib.LMCreduction_helper_t_colbuffer_set)
    dyndata_p = _swig_property(_oalib.LMCreduction_helper_t_dyndata_p_get, _oalib.LMCreduction_helper_t_dyndata_p_set)
    colperm_p = _swig_property(_oalib.LMCreduction_helper_t_colperm_p_get, _oalib.LMCreduction_helper_t_colperm_p_set)
    localcolperm_p = _swig_property(_oalib.LMCreduction_helper_t_localcolperm_p_get, _oalib.LMCreduction_helper_t_localcolperm_p_set)
    current_trans = _swig_property(_oalib.LMCreduction_helper_t_current_trans_get, _oalib.LMCreduction_helper_t_current_trans_set)

    def __init__(self):
        """
        __init__(LMCreduction_helper_t self) -> LMCreduction_helper_t



        """
        this = _oalib.new_LMCreduction_helper_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_LMCreduction_helper_t
    __del__ = lambda self: None

    def show(self, verbose=1):
        """
        show(LMCreduction_helper_t self, int verbose=1)
        show(LMCreduction_helper_t self)



        """
        return _oalib.LMCreduction_helper_t_show(self, verbose)


    def init(self, adp):
        """
        init(LMCreduction_helper_t self, arraydata_t adp)



        """
        return _oalib.LMCreduction_helper_t_init(self, adp)


    def freeall(self):
        """
        freeall(LMCreduction_helper_t self)



        """
        return _oalib.LMCreduction_helper_t_freeall(self)


    def update(self, adp):
        """
        update(LMCreduction_helper_t self, arraydata_t adp) -> int



        update structure with new design specification  

        """
        return _oalib.LMCreduction_helper_t_update(self, adp)


    def needUpdate(self, adp):
        """
        needUpdate(LMCreduction_helper_t self, arraydata_t adp) -> int



        """
        return _oalib.LMCreduction_helper_t_needUpdate(self, adp)


    def init_root_stage(self, lperm_p, colperm_p, adp):
        """
        init_root_stage(LMCreduction_helper_t self, levelperm_t *& lperm_p, colperm_t *& colperm_p, arraydata_t adp)



        """
        return _oalib.LMCreduction_helper_t_init_root_stage(self, lperm_p, colperm_p, adp)


    def init_nonroot_stage(self, lperm_p, colperm_p, localcolperm_p, dynd_p, dynd_p_nelem, colbuffer, adp):
        """
        init_nonroot_stage(LMCreduction_helper_t self, levelperm_t *& lperm_p, colperm_t *& colperm_p, colperm_t *& localcolperm_p, dyndata_t **& dynd_p, int & dynd_p_nelem, array_t *& colbuffer, arraydata_t adp)



        """
        return _oalib.LMCreduction_helper_t_init_nonroot_stage(self, lperm_p, colperm_p, localcolperm_p, dynd_p, dynd_p_nelem, colbuffer, adp)


    def init_rootrowperms(self, totalperms, rootrowperms, lperm_p):
        """
        init_rootrowperms(LMCreduction_helper_t self, int & totalperms, rowperm_t *& rootrowperms, levelperm_t *& lperm_p)



        Static initialization of root row permutations.  

        """
        return _oalib.LMCreduction_helper_t_init_rootrowperms(self, totalperms, rootrowperms, lperm_p)


    def init_rootrowperms_full(self, totalperms, rootrowperms, lperm_p):
        """
        init_rootrowperms_full(LMCreduction_helper_t self, int & totalperms, rowperm_t *& rootrowperms, levelperm_t *& lperm_p)



        Static initialization of root row permutations (full group)  

        """
        return _oalib.LMCreduction_helper_t_init_rootrowperms_full(self, totalperms, rootrowperms, lperm_p)

LMCreduction_helper_t_swigregister = _oalib.LMCreduction_helper_t_swigregister
LMCreduction_helper_t_swigregister(LMCreduction_helper_t)


def acquire_LMCreduction_object():
    """
    acquire_LMCreduction_object() -> LMCreduction_helper_t



    return static structure from dynamic global pool, return with
    releaseGlobalStatic  

    """
    return _oalib.acquire_LMCreduction_object()

def release_LMCreduction_object(p):
    """
    release_LMCreduction_object(LMCreduction_helper_t p)



    """
    return _oalib.release_LMCreduction_object(p)

def clear_LMCreduction_pool():
    """
    clear_LMCreduction_pool()



    release all objects in the pool  

    """
    return _oalib.clear_LMCreduction_pool()
REDUCTION_INITIAL = _oalib.REDUCTION_INITIAL
REDUCTION_CHANGED = _oalib.REDUCTION_CHANGED
OA_TEST = _oalib.OA_TEST
OA_REDUCE = _oalib.OA_REDUCE
OA_REDUCE_PARTIAL = _oalib.OA_REDUCE_PARTIAL
INIT_STATE_INVALID = _oalib.INIT_STATE_INVALID
COPY = _oalib.COPY
INIT = _oalib.INIT
SETROOT = _oalib.SETROOT
class LMCreduction_t(object):
    """


    Class to describe an LMC reduction.  

    The most important variable is the transformation itself, contained in
    transformation. The state contains information about how the reduction was
    performed.  

    C++ includes: lmc.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    array = _swig_property(_oalib.LMCreduction_t_array_get, _oalib.LMCreduction_t_array_set)
    transformation = _swig_property(_oalib.LMCreduction_t_transformation_get, _oalib.LMCreduction_t_transformation_set)
    mode = _swig_property(_oalib.LMCreduction_t_mode_get, _oalib.LMCreduction_t_mode_set)
    state = _swig_property(_oalib.LMCreduction_t_state_get, _oalib.LMCreduction_t_state_set)
    init_state = _swig_property(_oalib.LMCreduction_t_init_state_get, _oalib.LMCreduction_t_init_state_set)
    maxdepth = _swig_property(_oalib.LMCreduction_t_maxdepth_get, _oalib.LMCreduction_t_maxdepth_set)
    lastcol = _swig_property(_oalib.LMCreduction_t_lastcol_get, _oalib.LMCreduction_t_lastcol_set)
    nred = _swig_property(_oalib.LMCreduction_t_nred_get, _oalib.LMCreduction_t_nred_set)
    targetcol = _swig_property(_oalib.LMCreduction_t_targetcol_get, _oalib.LMCreduction_t_targetcol_set)
    mincol = _swig_property(_oalib.LMCreduction_t_mincol_get, _oalib.LMCreduction_t_mincol_set)
    nrows = _swig_property(_oalib.LMCreduction_t_nrows_get, _oalib.LMCreduction_t_nrows_set)
    ncols = _swig_property(_oalib.LMCreduction_t_ncols_get, _oalib.LMCreduction_t_ncols_set)
    staticdata = _swig_property(_oalib.LMCreduction_t_staticdata_get, _oalib.LMCreduction_t_staticdata_set)
    sd = _swig_property(_oalib.LMCreduction_t_sd_get, _oalib.LMCreduction_t_sd_set)

    def __init__(self, *args):
        """
        __init__(LMCreduction_t self, LMCreduction_t at) -> LMCreduction_t
        __init__(LMCreduction_t self, arraydata_t arrayclass) -> LMCreduction_t



        copy constructor  

        """
        this = _oalib.new_LMCreduction_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_LMCreduction_t
    __del__ = lambda self: None

    def getArray(self):
        """
        getArray(LMCreduction_t self) -> array_link



        Assignment operator.  

        """
        return _oalib.LMCreduction_t_getArray(self)


    def setArray(self, *args):
        """
        setArray(LMCreduction_t self, array_link al)
        setArray(LMCreduction_t self, array_t const * array, int nrows, int ncols)



        """
        return _oalib.LMCreduction_t_setArray(self, *args)


    def updateSDpointer(self, al, cache=False):
        """
        updateSDpointer(LMCreduction_t self, array_link al, bool cache=False)
        updateSDpointer(LMCreduction_t self, array_link al)



        update the pointer to the symmetry data based on the specified array  

        """
        return _oalib.LMCreduction_t_updateSDpointer(self, al, cache)


    def releaseStatic(self):
        """
        releaseStatic(LMCreduction_t self)



        release internal LMCreduction_helper_t object  

        """
        return _oalib.LMCreduction_t_releaseStatic(self)


    def initStatic(self):
        """
        initStatic(LMCreduction_t self)



        acquire a reference to a LMCreduction_helper_t object  

        """
        return _oalib.LMCreduction_t_initStatic(self)


    def getReferenceReductionHelper(self):
        """
        getReferenceReductionHelper(LMCreduction_t self) -> LMCreduction_helper_t



        return a reference to a object with LMC reduction data  

        """
        return _oalib.LMCreduction_t_getReferenceReductionHelper(self)


    def reset(self):
        """
        reset(LMCreduction_t self)



        reset the reduction: clears the symmetries and sets the transformation to zero  

        """
        return _oalib.LMCreduction_t_reset(self)


    def show(self, verbose=2):
        """
        show(LMCreduction_t self, int verbose=2)
        show(LMCreduction_t self)



        """
        return _oalib.LMCreduction_t_show(self, verbose)


    def __repr__(self):
        """
        __repr__(LMCreduction_t self) -> std::string



        """
        return _oalib.LMCreduction_t___repr__(self)


    def updateFromLoop(self, ad, dynd, lperms, original):
        """
        updateFromLoop(LMCreduction_t self, arraydata_t ad, dyndata_t dynd, levelperm_t * lperms, array_t const * original)



        called whenever we find a reduction  

        """
        return _oalib.LMCreduction_t_updateFromLoop(self, ad, dynd, lperms, original)


    def updateTransformation(self, ad, dynd, lperms, original):
        """
        updateTransformation(LMCreduction_t self, arraydata_t ad, dyndata_t dynd, levelperm_t * lperms, array_t const * original)



        """
        return _oalib.LMCreduction_t_updateTransformation(self, ad, dynd, lperms, original)


    def updateLastCol(self, col):
        """
        updateLastCol(LMCreduction_t self, int col)



        """
        return _oalib.LMCreduction_t_updateLastCol(self, col)

LMCreduction_t_swigregister = _oalib.LMCreduction_t_swigregister
LMCreduction_t_swigregister(LMCreduction_t)

class rowsorter_t(object):
    """


    Structure to sort rows of arrays.  

    C++ includes: lmc.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    number_of_rows = _swig_property(_oalib.rowsorter_t_number_of_rows_get, _oalib.rowsorter_t_number_of_rows_set)
    rowsort = _swig_property(_oalib.rowsorter_t_rowsort_get, _oalib.rowsorter_t_rowsort_set)

    def __init__(self, number_of_rows):
        """
        __init__(rowsorter_t self, int number_of_rows) -> rowsorter_t



        """
        this = _oalib.new_rowsorter_t(number_of_rows)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_rowsorter_t
    __del__ = lambda self: None
rowsorter_t_swigregister = _oalib.rowsorter_t_swigregister
rowsorter_t_swigregister(rowsorter_t)

class dyndata_t(object):
    """


    Contains dynamic data of an array.  

    The dynamic data are used in the inner loops of the LMC algorithm. In particular
    they keep track of the current row ordering and column permutation. By not
    applying these transformations to the array we can save calculation time.  

    We try to prevent copying the object, so it is re-used at different levels in
    the algorithm.  

    *   N: static
        -   col: changes at each column level  
    *   rowsort: changes at each column level, used mainly in non-root stage  
    *   colperm: changes at all levels  

        See also: arraydata_t  

    C++ includes: lmc.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    col = _swig_property(_oalib.dyndata_t_col_get, _oalib.dyndata_t_col_set)
    N = _swig_property(_oalib.dyndata_t_N_get, _oalib.dyndata_t_N_set)
    rowsort = _swig_property(_oalib.dyndata_t_rowsort_get, _oalib.dyndata_t_rowsort_set)
    rowsortl = _swig_property(_oalib.dyndata_t_rowsortl_get, _oalib.dyndata_t_rowsortl_set)
    colperm = _swig_property(_oalib.dyndata_t_colperm_get, _oalib.dyndata_t_colperm_set)

    def __init__(self, *args):
        """
        __init__(dyndata_t self, int N, int col=0) -> dyndata_t
        __init__(dyndata_t self, int N) -> dyndata_t
        __init__(dyndata_t self, dyndata_t dd) -> dyndata_t



        """
        this = _oalib.new_dyndata_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_dyndata_t
    __del__ = lambda self: None

    def show(self):
        """
        show(dyndata_t self)



        """
        return _oalib.dyndata_t_show(self)


    def reset(self):
        """
        reset(dyndata_t self)



        """
        return _oalib.dyndata_t_reset(self)


    def setColperm(self, *args):
        """
        setColperm(dyndata_t self, colperm_t const perm, int n)
        setColperm(dyndata_t self, larray< colindex_t > const & perm)
        setColperm(dyndata_t self, intVector perm)



        """
        return _oalib.dyndata_t_setColperm(self, *args)


    def getRowperm(self, *args):
        """
        getRowperm(dyndata_t self, rowpermtypelight & rp)
        getRowperm(dyndata_t self, rowperm_t & rperm)
        getRowperm(dyndata_t self) -> rowpermtypelight



        return lightweight row permutation  

        """
        return _oalib.dyndata_t_getRowperm(self, *args)


    def getColperm(self, *args):
        """
        getColperm(dyndata_t self) -> colpermtypelight
        getColperm(dyndata_t self, colpermtypelight & cp)



        set column permutation  

        """
        return _oalib.dyndata_t_getColperm(self, *args)


    def allocate_rowsortl(self):
        """
        allocate_rowsortl(dyndata_t self)



        allocate lightweight rowsort structure  

        """
        return _oalib.dyndata_t_allocate_rowsortl(self)


    def deleterowsortl(self):
        """
        deleterowsortl(dyndata_t self)



        """
        return _oalib.dyndata_t_deleterowsortl(self)


    def initrowsortl(self):
        """
        initrowsortl(dyndata_t self)



        initialize rowsortl from rowsort  

        """
        return _oalib.dyndata_t_initrowsortl(self)


    def rowsortl2rowsort(self):
        """
        rowsortl2rowsort(dyndata_t self)



        copy rowsortl variable to rowsrt  

        """
        return _oalib.dyndata_t_rowsortl2rowsort(self)


    def copydata(self, dd):
        """
        copydata(dyndata_t self, dyndata_t dd)



        """
        return _oalib.dyndata_t_copydata(self, dd)

dyndata_t_swigregister = _oalib.dyndata_t_swigregister
dyndata_t_swigregister(dyndata_t)


def is_root_form(array, strength):
    """
    is_root_form(array_link array, int strength) -> bool



    Return True if the array is in root form  

    Parameters
    ----------
    * `array` :  
        Array to check  
    * `strength` :  
        Strength to use  

    Returns
    -------
    True if the array is in root form for the specified strength  

    """
    return _oalib.is_root_form(array, strength)

def LMCreduction_train(al, ad, reduction, oaextend):
    """
    LMCreduction_train(array_link al, arraydata_t ad, LMCreduction_t reduction, OAextend oaextend) -> lmc_t



    helper function for LMC reduction  

    """
    return _oalib.LMCreduction_train(al, ad, reduction, oaextend)

def LMCcheck(*args):
    """
    LMCcheck(array_t const * array, arraydata_t ad, OAextend oaextend, LMCreduction_t reduction) -> lmc_t
    LMCcheck(array_link array, arraydata_t ad, OAextend oaextend, LMCreduction_t reduction) -> lmc_t
    LMCcheck(array_link array) -> lmc_t



    Perform LMC check on an orthogonal array  

    Parameters
    ----------
    * `array` :  
        Array to be checked for LMC minimal form  

    Returns
    -------
    Result of the LMC check  

    """
    return _oalib.LMCcheck(*args)

def LMCcheckOriginal(array):
    """
    LMCcheckOriginal(array_link array) -> lmc_t



    Perform LMC check on a 2-level orthogonal array  

    The algorithm used is the original algorithm from "Complete enumeration of
    pure-level and mixed-level orthogonal arrays", Schoen et al, 2009  

    Parameters
    ----------
    * `array` :  
        Array to be checked for LMC minimal form  

    Returns
    -------
    Result of the LMC check  

    """
    return _oalib.LMCcheckOriginal(array)

def reduceArraysGWLP(input_arrays, reduced_arrays, verbose, dopruning=1, strength=2, dolmc=1):
    """
    reduceArraysGWLP(arraylist_t input_arrays, arraylist_t reduced_arrays, int verbose, int dopruning=1, int strength=2, int dolmc=1)
    reduceArraysGWLP(arraylist_t input_arrays, arraylist_t reduced_arrays, int verbose, int dopruning=1, int strength=2)
    reduceArraysGWLP(arraylist_t input_arrays, arraylist_t reduced_arrays, int verbose, int dopruning=1)
    reduceArraysGWLP(arraylist_t input_arrays, arraylist_t reduced_arrays, int verbose)



    reduce arrays to canonical form using delete-1-factor ordering  

    """
    return _oalib.reduceArraysGWLP(input_arrays, reduced_arrays, verbose, dopruning, strength, dolmc)

def reductionDOP(array, verbose=0):
    """
    reductionDOP(array_link array, int verbose=0) -> array_transformation_t
    reductionDOP(array_link array) -> array_transformation_t



    Caculate the transformation reducing an array to delete-on-factor normal  

    The normal form is described in "A canonical form for non-regular arrays based
    on generalized wordlength pattern values of delete-one-factor projections",
    Eendebak, 2014  

    Parameters
    ----------
    * `array` :  
        Orthogonal array  
    * `verbose` :  
        Verbosity level  

    Returns
    -------
    The transformation that reduces the array to normal form  

    """
    return _oalib.reductionDOP(array, verbose)

def reduceDOPform(array, verbose=0):
    """
    reduceDOPform(array_link array, int verbose=0) -> array_link
    reduceDOPform(array_link array) -> array_link



    Reduce an array to canonical form using delete-1-factor ordering  

    The normal form is described in "A canonical form for non-regular arrays based
    on generalized wordlength pattern values of delete-one-factor projections",
    Eendebak, 2014  

    Parameters
    ----------
    * `array` :  
        Orthogonal array  
    * `verbose` :  
        Verbosity level  

    Returns
    -------
    The array transformed to normal form  

    """
    return _oalib.reduceDOPform(array, verbose)

def selectUniqueArrays(input_arrays, output_arrays, verbose=1):
    """
    selectUniqueArrays(arraylist_t input_arrays, arraylist_t output_arrays, int verbose=1)
    selectUniqueArrays(arraylist_t input_arrays, arraylist_t output_arrays)



    select the unique arrays in a list, the original list is sorted in place. the
    unique arrays are append to the output list  

    """
    return _oalib.selectUniqueArrays(input_arrays, output_arrays, verbose)

def projectionDOFvalues(array, verbose=0):
    """
    projectionDOFvalues(array_link array, int verbose=0) -> vector_mvalue_t_double
    projectionDOFvalues(array_link array) -> vector_mvalue_t_double



    Calculate projection values for delete-of-factor algorithm  

    """
    return _oalib.projectionDOFvalues(array, verbose)

def reduceLMCform(array):
    """
    reduceLMCform(array_link array) -> array_link



    reduce an array to canonical form using LMC ordering  

    """
    return _oalib.reduceLMCform(array)

def LMCcheckLex(*args):
    """
    LMCcheckLex(arraylist_t list, arraydata_t ad, int verbose=0) -> intVector
    LMCcheckLex(arraylist_t list, arraydata_t ad) -> intVector
    LMCcheckLex(array_link array, arraydata_t arrayclass) -> lmc_t



    Perform minimal form check with LMC orderin.  

    """
    return _oalib.LMCcheckLex(*args)

def LMCcheckj4(array, arrayclass, reduction, oaextend, jj=4):
    """
    LMCcheckj4(array_link array, arraydata_t arrayclass, LMCreduction_t reduction, OAextend oaextend, int jj=4) -> lmc_t
    LMCcheckj4(array_link array, arraydata_t arrayclass, LMCreduction_t reduction, OAextend oaextend) -> lmc_t



    Perform minimal form check with J4 ordering.  

    """
    return _oalib.LMCcheckj4(array, arrayclass, reduction, oaextend, jj)

def LMCcheckj5(array, arrayclass, reduction, oaextend):
    """
    LMCcheckj5(array_link array, arraydata_t arrayclass, LMCreduction_t reduction, OAextend oaextend) -> lmc_t



    Perform minimal form check for J5 ordering.  

    """
    return _oalib.LMCcheckj5(array, arrayclass, reduction, oaextend)

def print_rowsort(rowsort, N):
    """
    print_rowsort(rowsort_t rowsort, int N)



    Print the contents of a rowsort structure.  

    Parameters
    ----------
    * `rowsort` :  
        Pointer to rowsort structure  
    * `N` :  
        Number of elements  

    """
    return _oalib.print_rowsort(rowsort, N)

def print_column_rowsort(arraycol, rowsort, N):
    """
    print_column_rowsort(array_t const * arraycol, rowsort_t rowsort, int N)



    """
    return _oalib.print_column_rowsort(arraycol, rowsort, N)
ISOTOPY = _oalib.ISOTOPY
MATRIX_ISOMORPHISM = _oalib.MATRIX_ISOMORPHISM
CONFERENCE_ISOMORPHISM = _oalib.CONFERENCE_ISOMORPHISM
OA_ISOMORPHISM = _oalib.OA_ISOMORPHISM

def reduceNauty(graph, colors, verbose=0):
    """
    reduceNauty(array_link graph, intVector colors, int verbose=0) -> intVector
    reduceNauty(array_link graph, intVector colors) -> intVector



    Reduce a colored graph to Nauty minimal form  

    The transformation returned is from the normal form to the specified graph.  

    Parameters
    ----------
    * `graph` :  
        Graph in incidence matrix form  
    * `colors` :  
        Colors of the graph nodes  
    * `verbose` :  
        Verbosity level  

    Returns
    -------
    Relabelling of the graph vertices  

    """
    return _oalib.reduceNauty(graph, colors, verbose)

def transformGraph(graph, vertex_permutation, verbose=1):
    """
    transformGraph(array_link graph, intVector vertex_permutation, int verbose=1) -> array_link
    transformGraph(array_link graph, intVector vertex_permutation) -> array_link
    """
    return _oalib.transformGraph(graph, vertex_permutation, verbose)

def reduceOAnauty(*args):
    """
    reduceOAnauty(array_link array, int verbose=0) -> array_transformation_t
    reduceOAnauty(array_link array) -> array_transformation_t
    reduceOAnauty(array_link array, int verbose, arraydata_t arrayclass) -> array_transformation_t
    """
    return _oalib.reduceOAnauty(*args)

def array2graph(*args):
    """
    array2graph(array_link array, int verbose=1) -> pairGraphColors
    array2graph(array_link array) -> pairGraphColors
    array2graph(array_link array, int verbose, arraydata_t arrayclass) -> pairGraphColors
    """
    return _oalib.array2graph(*args)

def oagraph2transformation(pp, arrayclass, verbose=1):
    """
    oagraph2transformation(intVector pp, arraydata_t arrayclass, int verbose=1) -> array_transformation_t
    oagraph2transformation(intVector pp, arraydata_t arrayclass) -> array_transformation_t
    """
    return _oalib.oagraph2transformation(pp, arrayclass, verbose)
class depth_path_t(object):
    """


    structure containing current position in search tree  

    C++ includes: evenodd.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ncurr = _swig_property(_oalib.depth_path_t_ncurr_get, _oalib.depth_path_t_ncurr_set)
    nmax = _swig_property(_oalib.depth_path_t_nmax_get, _oalib.depth_path_t_nmax_set)
    necols = _swig_property(_oalib.depth_path_t_necols_get, _oalib.depth_path_t_necols_set)
    ngecols = _swig_property(_oalib.depth_path_t_ngecols_get, _oalib.depth_path_t_ngecols_set)
    depthstart = _swig_property(_oalib.depth_path_t_depthstart_get, _oalib.depth_path_t_depthstart_set)

    def __init__(self):
        """
        __init__(depth_path_t self) -> depth_path_t



        """
        this = _oalib.new_depth_path_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def updatePositionGEC(self, k, goodextensioncols):
        """
        updatePositionGEC(depth_path_t self, int k, int goodextensioncols)



        """
        return _oalib.depth_path_t_updatePositionGEC(self, k, goodextensioncols)


    def updatePosition(self, k, c, m, extensioncols, goodextensioncols):
        """
        updatePosition(depth_path_t self, int k, int c, int m, int extensioncols, int goodextensioncols)



        """
        return _oalib.depth_path_t_updatePosition(self, k, c, m, extensioncols, goodextensioncols)


    def show(self, depth, maxentries=8):
        """
        show(depth_path_t self, int depth, int maxentries=8)
        show(depth_path_t self, int depth)



        """
        return _oalib.depth_path_t_show(self, depth, maxentries)


    def init(self, ncols, _depthstart=9):
        """
        init(depth_path_t self, int ncols, int _depthstart=9)
        init(depth_path_t self, int ncols)



        """
        return _oalib.depth_path_t_init(self, ncols, _depthstart)

    __swig_destroy__ = _oalib.delete_depth_path_t
    __del__ = lambda self: None
depth_path_t_swigregister = _oalib.depth_path_t_swigregister
depth_path_t_swigregister(depth_path_t)
CONFERENCE_RESTRICTED_ISOMORPHISM = cvar.CONFERENCE_RESTRICTED_ISOMORPHISM

class counter_t(object):
    """


    structure to count and show number of arrays generated, the structure is thread
    safe  

    C++ includes: evenodd.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    nfound = _swig_property(_oalib.counter_t_nfound_get, _oalib.counter_t_nfound_set)

    def __init__(self, n):
        """
        __init__(counter_t self, int n) -> counter_t



        """
        this = _oalib.new_counter_t(n)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def addNfound(self, col, num):
        """
        addNfound(counter_t self, int col, int num)



        """
        return _oalib.counter_t_addNfound(self, col, num)


    def nArrays(self):
        """
        nArrays(counter_t self) -> long



        """
        return _oalib.counter_t_nArrays(self)


    def clearNumberFound(self):
        """
        clearNumberFound(counter_t self)



        """
        return _oalib.counter_t_clearNumberFound(self)


    def addNumberFound(self, *args):
        """
        addNumberFound(counter_t self, int n, int k)
        addNumberFound(counter_t self, counter_t de)



        """
        return _oalib.counter_t_addNumberFound(self, *args)


    def showcountscompact(self):
        """
        showcountscompact(counter_t self)



        show information about the number of arrays found  

        """
        return _oalib.counter_t_showcountscompact(self)


    def showcounts(self, *args):
        """
        showcounts(counter_t self, arraydata_t ad)
        showcounts(counter_t self, char const * str, int first, int last)



        show information about the number of arrays found  

        """
        return _oalib.counter_t_showcounts(self, *args)

    __swig_destroy__ = _oalib.delete_counter_t
    __del__ = lambda self: None
counter_t_swigregister = _oalib.counter_t_swigregister
counter_t_swigregister(counter_t)

class depth_extend_sub_t(object):
    """


    Helper structure for dynamic extension  

    In this structure we keep track of pointers to valid column extensions  

    C++ includes: evenodd.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    lmctype = _swig_property(_oalib.depth_extend_sub_t_lmctype_get, _oalib.depth_extend_sub_t_lmctype_set)
    lastcol = _swig_property(_oalib.depth_extend_sub_t_lastcol_get, _oalib.depth_extend_sub_t_lastcol_set)
    strengthcheck = _swig_property(_oalib.depth_extend_sub_t_strengthcheck_get, _oalib.depth_extend_sub_t_strengthcheck_set)
    valididx = _swig_property(_oalib.depth_extend_sub_t_valididx_get, _oalib.depth_extend_sub_t_valididx_set)
    verbose = _swig_property(_oalib.depth_extend_sub_t_verbose_get, _oalib.depth_extend_sub_t_verbose_set)

    def __init__(self, nn=0):
        """
        __init__(depth_extend_sub_t self, int nn=0) -> depth_extend_sub_t
        __init__(depth_extend_sub_t self) -> depth_extend_sub_t



        """
        this = _oalib.new_depth_extend_sub_t(nn)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def resize(self, nn):
        """
        resize(depth_extend_sub_t self, int nn)



        """
        return _oalib.depth_extend_sub_t_resize(self, nn)


    def n(self):
        """
        n(depth_extend_sub_t self) -> size_t



        """
        return _oalib.depth_extend_sub_t_n(self)


    def updateExtensionPointers(self, extcol):
        """
        updateExtensionPointers(depth_extend_sub_t self, int extcol) -> intVector



        """
        return _oalib.depth_extend_sub_t_updateExtensionPointers(self, extcol)


    def initialize(self, alist, adf, oaextend):
        """
        initialize(depth_extend_sub_t self, arraylist_t alist, arraydata_t adf, OAextend oaextend) -> arraylist_t



        initialize the new list of extension columns  

        """
        return _oalib.depth_extend_sub_t_initialize(self, alist, adf, oaextend)


    def selectArraysZ(self, alist):
        """
        selectArraysZ(depth_extend_sub_t self, arraylist_t alist) -> arraylist_t



        select the arrays with are LMC and hence need to be written to disk  

        """
        return _oalib.depth_extend_sub_t_selectArraysZ(self, alist)


    def selectArraysXX(self, al, elist):
        """
        selectArraysXX(depth_extend_sub_t self, array_link al, arraylist_t elist) -> arraylist_t



        """
        return _oalib.depth_extend_sub_t_selectArraysXX(self, al, elist)


    def info(self):
        """
        info(depth_extend_sub_t self)



        """
        return _oalib.depth_extend_sub_t_info(self)

    __swig_destroy__ = _oalib.delete_depth_extend_sub_t
    __del__ = lambda self: None
depth_extend_sub_t_swigregister = _oalib.depth_extend_sub_t_swigregister
depth_extend_sub_t_swigregister(depth_extend_sub_t)

class depth_extend_t(object):
    """


    Helper structure for dynamic extension.  

    This structure allows for writing the generated arrays to disk. It also contains
    functions to print progress of the extension.  

    Multiple copies of this class are made, but they all share the same counter_t
    and arraywriter_t object. Also t0 and tp are shared  

    C++ includes: evenodd.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    verbose = _swig_property(_oalib.depth_extend_t_verbose_get, _oalib.depth_extend_t_verbose_set)
    oaextend = _swig_property(_oalib.depth_extend_t_oaextend_get, _oalib.depth_extend_t_oaextend_set)
    ad = _swig_property(_oalib.depth_extend_t_ad_get, _oalib.depth_extend_t_ad_set)
    loglevelcol = _swig_property(_oalib.depth_extend_t_loglevelcol_get, _oalib.depth_extend_t_loglevelcol_set)
    logtime = _swig_property(_oalib.depth_extend_t_logtime_get, _oalib.depth_extend_t_logtime_set)
    extension_column_list = _swig_property(_oalib.depth_extend_t_extension_column_list_get, _oalib.depth_extend_t_extension_column_list_set)
    writearrays = _swig_property(_oalib.depth_extend_t_writearrays_get, _oalib.depth_extend_t_writearrays_set)
    discardJ5 = _swig_property(_oalib.depth_extend_t_discardJ5_get, _oalib.depth_extend_t_discardJ5_set)
    discardJ5number = _swig_property(_oalib.depth_extend_t_discardJ5number_get, _oalib.depth_extend_t_discardJ5number_set)
    arraywriter = _swig_property(_oalib.depth_extend_t_arraywriter_get, _oalib.depth_extend_t_arraywriter_set)
    counter = _swig_property(_oalib.depth_extend_t_counter_get, _oalib.depth_extend_t_counter_set)
    t0 = _swig_property(_oalib.depth_extend_t_t0_get, _oalib.depth_extend_t_t0_set)
    tp = _swig_property(_oalib.depth_extend_t_tp_get, _oalib.depth_extend_t_tp_set)

    def __init__(self, *args):
        """
        __init__(depth_extend_t self, arraydata_t ad_, double _logtime=10000000, int _discardJ5=-1) -> depth_extend_t
        __init__(depth_extend_t self, arraydata_t ad_, double _logtime=10000000) -> depth_extend_t
        __init__(depth_extend_t self, arraydata_t ad_) -> depth_extend_t
        __init__(depth_extend_t self, depth_extend_t de) -> depth_extend_t



        """
        this = _oalib.new_depth_extend_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_depth_extend_t
    __del__ = lambda self: None

    def show(self):
        """
        show(depth_extend_t self)



        """
        return _oalib.depth_extend_t_show(self)


    def setNarraysMax(self, n):
        """
        setNarraysMax(depth_extend_t self, long n)



        """
        return _oalib.depth_extend_t_setNarraysMax(self, n)


    def maxArrayCheck(self):
        """
        maxArrayCheck(depth_extend_t self)



        """
        return _oalib.depth_extend_t_maxArrayCheck(self)


    def showsearchpath(self, depth):
        """
        showsearchpath(depth_extend_t self, int depth)



        """
        return _oalib.depth_extend_t_showsearchpath(self, depth)


    def showprogress(self, showtime=1, depth=0, forcelog=0):
        """
        showprogress(depth_extend_t self, int showtime=1, int depth=0, int forcelog=0) -> bool
        showprogress(depth_extend_t self, int showtime=1, int depth=0) -> bool
        showprogress(depth_extend_t self, int showtime=1) -> bool
        showprogress(depth_extend_t self) -> bool



        show information about the progress of the loop  

        """
        return _oalib.depth_extend_t_showprogress(self, showtime, depth, forcelog)


    def info(self):
        """
        info(depth_extend_t self)



        """
        return _oalib.depth_extend_t_info(self)


    def setposition(self, k, c, m, extensioncols=-1, goodextensioncols=-1):
        """
        setposition(depth_extend_t self, int k, int c, int m, int extensioncols=-1, int goodextensioncols=-1)
        setposition(depth_extend_t self, int k, int c, int m, int extensioncols=-1)
        setposition(depth_extend_t self, int k, int c, int m)



        set the position in the dextend structure  

        """
        return _oalib.depth_extend_t_setposition(self, k, c, m, extensioncols, goodextensioncols)


    def setpositionGEC(self, k, goodextensioncols):
        """
        setpositionGEC(depth_extend_t self, int k, int goodextensioncols)



        set the position in the dextend structure  

        """
        return _oalib.depth_extend_t_setpositionGEC(self, k, goodextensioncols)

depth_extend_t_swigregister = _oalib.depth_extend_t_swigregister
depth_extend_t_swigregister(depth_extend_t)

DEPTH_DIRECT = _oalib.DEPTH_DIRECT
DEPTH_EXTENSIONS = _oalib.DEPTH_EXTENSIONS
class depth_extensions_storage_t(object):
    """


    Helper structure for the even-odd depth extension.  

    C++ includes: evenodd.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def resize(self, s):
        """
        resize(depth_extensions_storage_t self, size_t s)



        """
        return _oalib.depth_extensions_storage_t_resize(self, s)


    def set(self, ai, goodarrays, extension_column_list, depthalg, dextendsub):
        """
        set(depth_extensions_storage_t self, int ai, arraylist_t goodarrays, arraylist_t extension_column_list, depth_alg_t depthalg, depth_extend_sub_t dextendsub)



        """
        return _oalib.depth_extensions_storage_t_set(self, ai, goodarrays, extension_column_list, depthalg, dextendsub)

    columnextensionsList = _swig_property(_oalib.depth_extensions_storage_t_columnextensionsList_get, _oalib.depth_extensions_storage_t_columnextensionsList_set)
    goodarrayslist = _swig_property(_oalib.depth_extensions_storage_t_goodarrayslist_get, _oalib.depth_extensions_storage_t_goodarrayslist_set)
    depthalglist = _swig_property(_oalib.depth_extensions_storage_t_depthalglist_get, _oalib.depth_extensions_storage_t_depthalglist_set)
    dextendsubList = _swig_property(_oalib.depth_extensions_storage_t_dextendsubList_get, _oalib.depth_extensions_storage_t_dextendsubList_set)

    def __init__(self):
        """
        __init__(depth_extensions_storage_t self) -> depth_extensions_storage_t



        Helper structure for the even-odd depth extension.  

        C++ includes: evenodd.h

        """
        this = _oalib.new_depth_extensions_storage_t()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_depth_extensions_storage_t
    __del__ = lambda self: None
depth_extensions_storage_t_swigregister = _oalib.depth_extensions_storage_t_swigregister
depth_extensions_storage_t_swigregister(depth_extensions_storage_t)


def processDepth(goodarrays, depthalg, dextend, dextendsublight, extensioncol, verbose=0):
    """
    processDepth(arraylist_t goodarrays, depth_alg_t depthalg, depth_extend_t dextend, depth_extend_sub_t dextendsublight, int extensioncol, int verbose=0)
    processDepth(arraylist_t goodarrays, depth_alg_t depthalg, depth_extend_t dextend, depth_extend_sub_t dextendsublight, int extensioncol)



    Extend arrays using a depth-first or breadth-first approach  

    Parameters
    ----------
    * `goodarrays` :  
        List of arrays to extend  
    * `depthalg` :  
        Extend using depth-first or breadth-first  
    * `dextend` :  
        Option structure for the extension  
    * `dextendsublight` :  
        Data structure for the extensions  
    * `extensioncol` :  
        Column to extend  
    * `verbose` :  
        Verbosity level  

    """
    return _oalib.processDepth(goodarrays, depthalg, dextend, dextendsublight, extensioncol, verbose)

def depth_extend_hybrid(alist, dextend, extcol, oaextendx, verbose):
    """
    depth_extend_hybrid(arraylist_t alist, depth_extend_t dextend, int extcol, OAextend oaextendx, int verbose)



    depth-first extension of arrays. depending on the symmetry group of the array to
    be extended a direct method is used or a method with caching of candidate
    columns  

    """
    return _oalib.depth_extend_hybrid(alist, dextend, extcol, oaextendx, verbose)

def depth_extend_direct(alist, dextend, extcol, oaextendx, verbose):
    """
    depth_extend_direct(arraylist_t alist, depth_extend_t dextend, int extcol, OAextend oaextendx, int verbose)



    variation of depth_extend for arrays with large symmetry groups  

    """
    return _oalib.depth_extend_direct(alist, dextend, extcol, oaextendx, verbose)

def depth_extend_array(al, dextend, adfull, verbose, ds=None, arg6=0):
    """
    depth_extend_array(array_link al, depth_extend_t dextend, arraydata_t adfull, int verbose, depth_extensions_storage_t ds=None, int arg6=0)
    depth_extend_array(array_link al, depth_extend_t dextend, arraydata_t adfull, int verbose, depth_extensions_storage_t ds=None)
    depth_extend_array(array_link al, depth_extend_t dextend, arraydata_t adfull, int verbose)



    depth extend a single array  

    """
    return _oalib.depth_extend_array(al, dextend, adfull, verbose, ds, arg6)

def addArraysToPareto(*args):
    """
    addArraysToPareto(Pareto< mvalue_t< long >,array_link > & pset, pareto_cb paretofunction, arraylist_t arraylist, int jj, int verbose)
    addArraysToPareto(Pareto< mvalue_t< long >,array_link > & pset, pareto_cb_cache paretofunction, arraylist_t arraylist, int jj, int verbose)



    add arrays to set of Pareto results  

    """
    return _oalib.addArraysToPareto(*args)
class jindex_t(object):
    """


    helper class for indexing statistics of designs  

    The index consists of the number of columns and the value for the
    J-characteristic  

    C++ includes: evenodd.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    k = _swig_property(_oalib.jindex_t_k_get, _oalib.jindex_t_k_set)
    j = _swig_property(_oalib.jindex_t_j_get, _oalib.jindex_t_j_set)

    def __init__(self, colindex, jvalue):
        """
        __init__(jindex_t self, int colindex, int jvalue) -> jindex_t



        """
        this = _oalib.new_jindex_t(colindex, jvalue)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __lt__(self, rhs):
        """__lt__(jindex_t self, jindex_t rhs) -> bool"""
        return _oalib.jindex_t___lt__(self, rhs)


    def toString(self):
        """
        toString(jindex_t self) -> std::string



        """
        return _oalib.jindex_t_toString(self)

    __swig_destroy__ = _oalib.delete_jindex_t
    __del__ = lambda self: None
jindex_t_swigregister = _oalib.jindex_t_swigregister
jindex_t_swigregister(jindex_t)

class Jcounter(object):
    """


    object to hold counts of maximum J_k-values  

    C++ includes: evenodd.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    N = _swig_property(_oalib.Jcounter_N_get, _oalib.Jcounter_N_set)
    jj = _swig_property(_oalib.Jcounter_jj_get, _oalib.Jcounter_jj_set)
    fvals = _swig_property(_oalib.Jcounter_fvals_get, _oalib.Jcounter_fvals_set)
    maxJcounts = _swig_property(_oalib.Jcounter_maxJcounts_get, _oalib.Jcounter_maxJcounts_set)
    dt = _swig_property(_oalib.Jcounter_dt_get, _oalib.Jcounter_dt_set)

    def __init__(self, *args):
        """
        __init__(Jcounter self) -> Jcounter
        __init__(Jcounter self, int N, int jj=5, int k=-1) -> Jcounter
        __init__(Jcounter self, int N, int jj=5) -> Jcounter
        __init__(Jcounter self, int N) -> Jcounter



        """
        this = _oalib.new_Jcounter(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def validData(self):
        """
        validData(Jcounter self) -> bool



        """
        return _oalib.Jcounter_validData(self)


    def hasColumn(self, col):
        """
        hasColumn(Jcounter self, int col) -> bool



        return true if specified column is in the data  

        """
        return _oalib.Jcounter_hasColumn(self, col)


    def isOpen(self):
        """
        isOpen(Jcounter self) -> bool



        """
        return _oalib.Jcounter_isOpen(self)


    def showPerformance(self):
        """
        showPerformance(Jcounter self)



        """
        return _oalib.Jcounter_showPerformance(self)


    def narrays(self):
        """
        narrays(Jcounter self) -> long



        """
        return _oalib.Jcounter_narrays(self)


    def show(self):
        """
        show(Jcounter self)



        show statistics of the object  

        """
        return _oalib.Jcounter_show(self)


    def maxCols(self):
        """
        maxCols(Jcounter self) -> int



        """
        return _oalib.Jcounter_maxCols(self)


    def getCount(self, k, j):
        """
        getCount(Jcounter self, int k, int j) -> long



        """
        return _oalib.Jcounter_getCount(self, k, j)


    def getTotalsJvalue(self, jval):
        """
        getTotalsJvalue(Jcounter self, int jval) -> longVector



        """
        return _oalib.Jcounter_getTotalsJvalue(self, jval)


    def getTotals(self):
        """
        getTotals(Jcounter self) -> longVector



        """
        return _oalib.Jcounter_getTotals(self)


    def showcompact(self):
        """
        showcompact(Jcounter self)



        show statistics of the object  

        """
        return _oalib.Jcounter_showcompact(self)


    def __iadd__(self, jc):
        """__iadd__(Jcounter self, Jcounter jc) -> Jcounter"""
        return _oalib.Jcounter___iadd__(self, jc)


    def addArrays(self, arraylist, verbose=0):
        """
        addArrays(Jcounter self, arraylist_t arraylist, int verbose=0)
        addArrays(Jcounter self, arraylist_t arraylist)



        add list of arrays to object  

        """
        return _oalib.Jcounter_addArrays(self, arraylist, verbose)


    def addArray(self, al, verbose=0):
        """
        addArray(Jcounter self, array_link al, int verbose=0)
        addArray(Jcounter self, array_link al)



        add single array to statistics object  

        """
        return _oalib.Jcounter_addArray(self, al, verbose)

    __swig_destroy__ = _oalib.delete_Jcounter
    __del__ = lambda self: None
Jcounter_swigregister = _oalib.Jcounter_swigregister
Jcounter_swigregister(Jcounter)


def readStatisticsFile(numbersfile, verbose):
    """
    readStatisticsFile(char const * numbersfile, int verbose) -> Jcounter



    read statistics object from disk  

    """
    return _oalib.readStatisticsFile(numbersfile, verbose)

def writeStatisticsFile(numbersfile, jc, verbose):
    """
    writeStatisticsFile(char const * numbersfile, Jcounter jc, int verbose)



    write statistics object to disk  

    """
    return _oalib.writeStatisticsFile(numbersfile, jc, verbose)

def calculateJstatistics(afile, jj=5, verbose=1):
    """
    calculateJstatistics(char const * afile, int jj=5, int verbose=1) -> Jcounter
    calculateJstatistics(char const * afile, int jj=5) -> Jcounter
    calculateJstatistics(char const * afile) -> Jcounter



    calculate J-value statistics  

    """
    return _oalib.calculateJstatistics(afile, jj, verbose)

def print_column(column, msg=None):
    """
    print_column(charVector column, char const * msg=None)
    print_column(charVector column)



    print a candidate extension  

    """
    return _oalib.print_column(column, msg)

def showCandidates(column_candidates):
    """
    showCandidates(conference_columnVector column_candidates)



    Show a list of candidate extensions  

    Parameters
    ----------
    * `column_candidates` :  
        List of candidates to show  

    """
    return _oalib.showCandidates(column_candidates)

def conference2DSD(conference_design, add_zeros=True):
    """
    conference2DSD(array_link conference_design, bool add_zeros=True) -> array_link
    conference2DSD(array_link conference_design) -> array_link



    Convert conference design to definitive screening design  

    The DSD is created by appending the negated design to the conference design and
    then appending a row of zeros.  

    Parameters
    ----------
    * `conference_design` :  
        Array with the conference design  
    * `add_zeros` :  
        If True, then append a row of zeros  

    Returns
    -------
    The DSD generated from the conference design  

    """
    return _oalib.conference2DSD(conference_design, add_zeros)
class conference_t(object):
    """


    Structure representing the type of conference designs.  

    C++ includes: conference.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    N = _swig_property(_oalib.conference_t_N_get, _oalib.conference_t_N_set)
    ncols = _swig_property(_oalib.conference_t_ncols_get, _oalib.conference_t_ncols_set)
    CONFERENCE_NORMAL = _oalib.conference_t_CONFERENCE_NORMAL
    CONFERENCE_DIAGONAL = _oalib.conference_t_CONFERENCE_DIAGONAL
    DCONFERENCE = _oalib.conference_t_DCONFERENCE
    ctype = _swig_property(_oalib.conference_t_ctype_get, _oalib.conference_t_ctype_set)
    itype = _swig_property(_oalib.conference_t_itype_get, _oalib.conference_t_itype_set)
    j1zero = _swig_property(_oalib.conference_t_j1zero_get, _oalib.conference_t_j1zero_set)
    j3zero = _swig_property(_oalib.conference_t_j3zero_get, _oalib.conference_t_j3zero_set)

    def __init__(self, *args):
        """
        __init__(conference_t self) -> conference_t
        __init__(conference_t self, int N, int k, int j1zero) -> conference_t
        __init__(conference_t self, conference_t rhs) -> conference_t



        """
        this = _oalib.new_conference_t(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def idstr(self):
        """
        idstr(conference_t self) -> std::string



        """
        return _oalib.conference_t_idstr(self)


    def create_root(self):
        """
        create_root(conference_t self) -> array_link



        create the unique representative of the 2 column conference design in LMC0 form  

        """
        return _oalib.conference_t_create_root(self)


    def create_root_three_columns(self):
        """
        create_root_three_columns(conference_t self) -> array_link



        create the unique representative of the 3 column conference design in LMC0 form  

        """
        return _oalib.conference_t_create_root_three_columns(self)


    def createDoubleConferenceRootArrays(self):
        """
        createDoubleConferenceRootArrays(conference_t self) -> arraylist_t



        create the root arrays with 1 column for the double conference matrices  

        """
        return _oalib.conference_t_createDoubleConferenceRootArrays(self)


    def createRootArrays(self):
        """
        createRootArrays(conference_t self) -> arraylist_t



        return the list of root arrays for the class of conference designs  

        """
        return _oalib.conference_t_createRootArrays(self)


    def __repr__(self):
        """
        __repr__(conference_t self) -> std::string



        return string representation of the object  

        """
        return _oalib.conference_t___repr__(self)

    __swig_destroy__ = _oalib.delete_conference_t
    __del__ = lambda self: None
conference_t_swigregister = _oalib.conference_t_swigregister
conference_t_swigregister(conference_t)


def reduceConference(arg1, verbose=0):
    """
    reduceConference(array_link arg1, int verbose=0) -> array_link
    reduceConference(array_link arg1) -> array_link



    Reduce conference matrix to normal form using Nauty  

    See also: reduceConferenceTransformation  

    """
    return _oalib.reduceConference(arg1, verbose)

def reduceConferenceTransformation(conference_design, verbose):
    """
    reduceConferenceTransformation(array_link conference_design, int verbose) -> conference_transformation_t



    Reduce conference matrix to normal form using Nauty  

    The design is converted to a graph representation. The graph is then reduced
    using Nauty to normal form and the resulting graph translated back to a
    conference design.  

    Parameters
    ----------
    * `conference_design` :  
        Design to be reduced to normal form  
    * `verbose` :  
        Verbosity level  

    Returns
    -------
    A transformation that converts the input design to normal form  

    """
    return _oalib.reduceConferenceTransformation(conference_design, verbose)
class CandidateGeneratorConference(object):
    """


    Class to generate conference candidate extensions.  

    C++ includes: conference.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, al, ct):
        """
        __init__(CandidateGeneratorConference self, array_link al, conference_t ct) -> CandidateGeneratorConference



        """
        this = _oalib.new_CandidateGeneratorConference(al, ct)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def generateCandidates(self, al):
        """
        generateCandidates(CandidateGeneratorConference self, array_link al) -> conference_columnVector



        Generate a list of candidate extensions for the specified design.  

        """
        return _oalib.CandidateGeneratorConference_generateCandidates(self, al)


    def generateCandidatesZero(self, al, kz):
        """
        generateCandidatesZero(CandidateGeneratorConference self, array_link al, int kz) -> conference_columnVector



        generate all candidate extensions with a zero at the specified position  

        """
        return _oalib.CandidateGeneratorConference_generateCandidatesZero(self, al, kz)

    __swig_destroy__ = _oalib.delete_CandidateGeneratorConference
    __del__ = lambda self: None
CandidateGeneratorConference_swigregister = _oalib.CandidateGeneratorConference_swigregister
CandidateGeneratorConference_swigregister(CandidateGeneratorConference)

class CandidateGeneratorDouble(object):
    """


    Class to generate double conference candidate extensions with caching.  

    C++ includes: conference.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, al, ct):
        """
        __init__(CandidateGeneratorDouble self, array_link al, conference_t ct) -> CandidateGeneratorDouble



        """
        this = _oalib.new_CandidateGeneratorDouble(al, ct)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def generateCandidates(self, al):
        """
        generateCandidates(CandidateGeneratorDouble self, array_link al) -> conference_columnVector



        Generate a list of candidate extensions for the specified design  

        This method uses symmetry inflation, assumes j1=0 and j2=0. Optimal performance
        is achieved when the arrays to be extended have identical first columns.  

        """
        return _oalib.CandidateGeneratorDouble_generateCandidates(self, al)

    __swig_destroy__ = _oalib.delete_CandidateGeneratorDouble
    __del__ = lambda self: None
CandidateGeneratorDouble_swigregister = _oalib.CandidateGeneratorDouble_swigregister
CandidateGeneratorDouble_swigregister(CandidateGeneratorDouble)


def extend_conference(lst, conference_type, verbose, select_isomorphism_classes=0):
    """
    extend_conference(arraylist_t lst, conference_t conference_type, int verbose, int select_isomorphism_classes=0) -> arraylist_t
    extend_conference(arraylist_t lst, conference_t conference_type, int verbose) -> arraylist_t



    Extend a list of conference designs with a single column.  

    The list of conference designs is extended by adding to each design the
    candidate extentions generated by CandidateGenerator.  

    Parameters
    ----------
    * `lst` :  
        List of conference designs  
    * `conference_type` :  
        Type specification for the conference designs  
    * `verbose` :  
        Verbosity level  
    * `select_isomorphism_classes` :  
        If True then select only a single design for each isomorphism class
        specified by the conference type.  

    Returns
    -------
    List of generated conference designs  

    The extension algorithm tried to generate designs in LMC0 normal form and prune
    any designs that are not in LMC0 form.  

    """
    return _oalib.extend_conference(lst, conference_type, verbose, select_isomorphism_classes)

def extend_conference_plain(lst, conference_type, verbose, select_isomorphism_classes=0):
    """
    extend_conference_plain(arraylist_t lst, conference_t conference_type, int verbose, int select_isomorphism_classes=0) -> arraylist_t
    extend_conference_plain(arraylist_t lst, conference_t conference_type, int verbose) -> arraylist_t



    Extend a list of conference designs with a single column, plain version without
    caching  

    Research function.  

    """
    return _oalib.extend_conference_plain(lst, conference_type, verbose, select_isomorphism_classes)

def extend_conference_restricted(lst, conference_type, verbose):
    """
    extend_conference_restricted(arraylist_t lst, conference_t conference_type, int verbose) -> arraylist_t



    Extend a list of conference designs with a single column  

    Research function.  

    """
    return _oalib.extend_conference_restricted(lst, conference_type, verbose)

def extend_double_conference(lst, conference_type, verbose):
    """
    extend_double_conference(arraylist_t lst, conference_t conference_type, int verbose) -> arraylist_t



    Extend a list of double conference matrices with an additional column  

    The list of designs is extended by adding each design with the candidate
    extentions generated by CandidateGeneratorDouble.  

    Parameters
    ----------
    * `lst` :  
        List of double conference designs  
    * `conference_type` :  
        Type specification for the double conference designs  
    * `verbose` :  
        Verbosity level  

    Returns
    -------
    List of generated double conference designs  

    """
    return _oalib.extend_double_conference(lst, conference_type, verbose)

def selectConferenceIsomorpismClasses(list, verbose, itype=CONFERENCE_ISOMORPHISM):
    """
    selectConferenceIsomorpismClasses(arraylist_t list, int verbose, matrix_isomorphism_t itype=CONFERENCE_ISOMORPHISM) -> arraylist_t
    selectConferenceIsomorpismClasses(arraylist_t list, int verbose) -> arraylist_t



    select representatives for the isomorphism classes of a list of conference
    arrays  

    """
    return _oalib.selectConferenceIsomorpismClasses(list, verbose, itype)

def selectConferenceIsomorpismIndices(lst, verbose, itype=CONFERENCE_ISOMORPHISM):
    """
    selectConferenceIsomorpismIndices(arraylist_t lst, int verbose, matrix_isomorphism_t itype=CONFERENCE_ISOMORPHISM) -> intVector
    selectConferenceIsomorpismIndices(arraylist_t lst, int verbose) -> intVector



    select representatives for the isomorphism classes of a list of conference
    arrays, return indices of classes  

    """
    return _oalib.selectConferenceIsomorpismIndices(lst, verbose, itype)

def selectLMC0doubleconference(list, verbose, ctype):
    """
    selectLMC0doubleconference(arraylist_t list, int verbose, conference_t ctype) -> arraylist_t



    Select double conference designs in LMC0 form  

    Parameters
    ----------
    * `list` :  
        List of double conference designs  
    * `verbose` :  
        Verbosity level  
    * `ctype` :  
        Specifiation of the class of designs  

    Returns
    -------
    List with only the designs in the input list that are in LMC0 normal form.  

    """
    return _oalib.selectLMC0doubleconference(list, verbose, ctype)

def selectLMC0(list, verbose, ctype):
    """
    selectLMC0(arraylist_t list, int verbose, conference_t ctype) -> arraylist_t



    Select conference designs in LMC0 form  

    Parameters
    ----------
    * `list` :  
        List of conference designs  
    * `verbose` :  
        Verbosity level  
    * `ctype` :  
        Specifiation of the class of designs  

    Returns
    -------
    List with only the designs in the input list that are in LMC0 normal form.  

    """
    return _oalib.selectLMC0(list, verbose, ctype)

def generateConferenceExtensions(array, conference_type, zero_index, verbose=1, filter_symmetry=1, filterj2=1):
    """
    generateConferenceExtensions(array_link array, conference_t conference_type, int zero_index, int verbose=1, int filter_symmetry=1, int filterj2=1) -> conference_columnVector
    generateConferenceExtensions(array_link array, conference_t conference_type, int zero_index, int verbose=1, int filter_symmetry=1) -> conference_columnVector
    generateConferenceExtensions(array_link array, conference_t conference_type, int zero_index, int verbose=1) -> conference_columnVector
    generateConferenceExtensions(array_link array, conference_t conference_type, int zero_index) -> conference_columnVector



    Generate candidate extensions for a conference design  

    Parameters
    ----------
    * `array` :  
        Design to be extended  
    * `conference_type` :  
        Class of conference designs  
    * `zero_index` :  
        index of zero in candidate column  
    * `verbose` :  
        Verbosity level  
    * `filtersymm` :  
        If True, filter based on symmetry  
    * `filterj2` :  
        If True, filter based on J2 values  

    Returns
    -------
    List of generated extensions  

    """
    return _oalib.generateConferenceExtensions(array, conference_type, zero_index, verbose, filter_symmetry, filterj2)

def generateConferenceRestrictedExtensions(array, conference_type, zero_index, verbose=1, filter_symmetry=1, filterip=1):
    """
    generateConferenceRestrictedExtensions(array_link array, conference_t conference_type, int zero_index, int verbose=1, int filter_symmetry=1, int filterip=1) -> conference_columnVector
    generateConferenceRestrictedExtensions(array_link array, conference_t conference_type, int zero_index, int verbose=1, int filter_symmetry=1) -> conference_columnVector
    generateConferenceRestrictedExtensions(array_link array, conference_t conference_type, int zero_index, int verbose=1) -> conference_columnVector
    generateConferenceRestrictedExtensions(array_link array, conference_t conference_type, int zero_index) -> conference_columnVector



    Generate candidate extensions for restricted isomorphism classes  

    """
    return _oalib.generateConferenceRestrictedExtensions(array, conference_type, zero_index, verbose, filter_symmetry, filterip)

def generateDoubleConferenceExtensions(array, conference_type, verbose=1, filter_symmetry=1, filterip=1, filterJ3=0, filter_symmetry_inline=1):
    """
    generateDoubleConferenceExtensions(array_link array, conference_t conference_type, int verbose=1, int filter_symmetry=1, int filterip=1, int filterJ3=0, int filter_symmetry_inline=1) -> conference_columnVector
    generateDoubleConferenceExtensions(array_link array, conference_t conference_type, int verbose=1, int filter_symmetry=1, int filterip=1, int filterJ3=0) -> conference_columnVector
    generateDoubleConferenceExtensions(array_link array, conference_t conference_type, int verbose=1, int filter_symmetry=1, int filterip=1) -> conference_columnVector
    generateDoubleConferenceExtensions(array_link array, conference_t conference_type, int verbose=1, int filter_symmetry=1) -> conference_columnVector
    generateDoubleConferenceExtensions(array_link array, conference_t conference_type, int verbose=1) -> conference_columnVector
    generateDoubleConferenceExtensions(array_link array, conference_t conference_type) -> conference_columnVector



    generate extensions for double conference matrices in LMC0 form  

    """
    return _oalib.generateDoubleConferenceExtensions(array, conference_type, verbose, filter_symmetry, filterip, filterJ3, filter_symmetry_inline)

def generateSingleConferenceExtensions(array, conference_type, zero_index, verbose, filter_symmetry, filterj2, filterj3, filter_symmetry_inline=0):
    """
    generateSingleConferenceExtensions(array_link array, conference_t conference_type, int zero_index, int verbose, int filter_symmetry, int filterj2, int filterj3, int filter_symmetry_inline=0) -> conference_columnVector
    generateSingleConferenceExtensions(array_link array, conference_t conference_type, int zero_index, int verbose, int filter_symmetry, int filterj2, int filterj3) -> conference_columnVector



    generate extensions for conference matrices in LMC0 form  

    """
    return _oalib.generateSingleConferenceExtensions(array, conference_type, zero_index, verbose, filter_symmetry, filterj2, filterj3, filter_symmetry_inline)

def maxz(al, column_index=-1):
    """
    maxz(array_link al, int column_index=-1) -> int
    maxz(array_link al) -> int



    return max position of zero in array, returns -1 if no zero is found  

    The parameter k specifies the column to search in. For k=-1 all columns are
    searched.  

    """
    return _oalib.maxz(al, column_index)

def compareLMC0(array_first, array_second):
    """
    compareLMC0(array_link array_first, array_link array_second) -> bool



    Return true if the first array is smaller in LMC-0 ordering than the second
    array  

    """
    return _oalib.compareLMC0(array_first, array_second)

def sortLMC0(arrays):
    """
    sortLMC0(arraylist_t arrays) -> arraylist_t



    sort list of conference designs according to LMC0 ordering  

    """
    return _oalib.sortLMC0(arrays)

def LMC0checkDC(al, verbose=0):
    """
    LMC0checkDC(array_link al, int verbose=0) -> lmc_t
    LMC0checkDC(array_link al) -> lmc_t



    """
    return _oalib.LMC0checkDC(al, verbose)

def LMC0check(array, verbose=0):
    """
    LMC0check(array_link array, int verbose=0) -> lmc_t
    LMC0check(array_link array) -> lmc_t



    """
    return _oalib.LMC0check(array, verbose)

def isConferenceFoldover(array, verbose=0):
    """
    isConferenceFoldover(array_link array, int verbose=0) -> bool
    isConferenceFoldover(array_link array) -> bool



    return true if the design is a foldover array  

    """
    return _oalib.isConferenceFoldover(array, verbose)

def double_conference_foldover_permutation(double_conference):
    """
    double_conference_foldover_permutation(array_link double_conference) -> intVector



    For a double conference design return a row permutation to a single conference
    design  

    If the design is not a foldover design then the first element of the returned
    permutation is -1.  

    Parameters
    ----------
    * `double_conference` :  
        A double conference design  

    Returns
    -------
    Permutation  

    """
    return _oalib.double_conference_foldover_permutation(double_conference)

def minz(al, column_index):
    """
    minz(array_link al, int column_index) -> int



    return minimal position of zero in specified column of a design  

    """
    return _oalib.minz(al, column_index)
class DconferenceFilter(object):
    """


    class to filter single or double conference designs  

    C++ includes: conference.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    als = _swig_property(_oalib.DconferenceFilter_als_get, _oalib.DconferenceFilter_als_set)
    filtersymm = _swig_property(_oalib.DconferenceFilter_filtersymm_get, _oalib.DconferenceFilter_filtersymm_set)
    filterj2 = _swig_property(_oalib.DconferenceFilter_filterj2_get, _oalib.DconferenceFilter_filterj2_set)
    filterj3 = _swig_property(_oalib.DconferenceFilter_filterj3_get, _oalib.DconferenceFilter_filterj3_set)
    filterfirst = _swig_property(_oalib.DconferenceFilter_filterfirst_get, _oalib.DconferenceFilter_filterfirst_set)
    filterzero = _swig_property(_oalib.DconferenceFilter_filterzero_get, _oalib.DconferenceFilter_filterzero_set)
    ngood = _swig_property(_oalib.DconferenceFilter_ngood_get, _oalib.DconferenceFilter_ngood_set)
    inline_row = _swig_property(_oalib.DconferenceFilter_inline_row_get, _oalib.DconferenceFilter_inline_row_set)
    sd = _swig_property(_oalib.DconferenceFilter_sd_get, _oalib.DconferenceFilter_sd_set)

    def __init__(self, _als, filter_symmetry, filterj2_, filterj3_=1):
        """
        __init__(DconferenceFilter self, array_link _als, int filter_symmetry, int filterj2_, int filterj3_=1) -> DconferenceFilter
        __init__(DconferenceFilter self, array_link _als, int filter_symmetry, int filterj2_) -> DconferenceFilter



        """
        this = _oalib.new_DconferenceFilter(_als, filter_symmetry, filterj2_, filterj3_)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def show(self):
        """
        show(DconferenceFilter self)



        print object to stdout  

        """
        return _oalib.DconferenceFilter_show(self)


    def filterList(self, lst, verbose=0):
        """
        filterList(DconferenceFilter self, conference_columnVector lst, int verbose=0) -> conference_columnVector
        filterList(DconferenceFilter self, conference_columnVector lst) -> conference_columnVector



        filter a list of columns using the filter method  

        """
        return _oalib.DconferenceFilter_filterList(self, lst, verbose)


    def filterListJ2last(self, column_list):
        """
        filterListJ2last(DconferenceFilter self, conference_columnVector column_list) -> conference_columnVector



        """
        return _oalib.DconferenceFilter_filterListJ2last(self, column_list)


    def filterListZero(self, lst):
        """
        filterListZero(DconferenceFilter self, conference_columnVector lst) -> conference_columnVector



        filter a list of cperms using the filterZero method  

        """
        return _oalib.DconferenceFilter_filterListZero(self, lst)


    def filter(self, c):
        """
        filter(DconferenceFilter self, charVector c) -> bool



        return True if the extension satisfies all checks  

        """
        return _oalib.DconferenceFilter_filter(self, c)


    def filterJpartial(self, column, maxrow):
        """
        filterJpartial(DconferenceFilter self, charVector column, int maxrow) -> bool



        Filter on partial column (only last col)  

        Parameters
        ----------
        * `column` :  
            Extension column  
        * `maxrow` :  
            the number of rows that are valid  

        """
        return _oalib.DconferenceFilter_filterJpartial(self, column, maxrow)


    def filterJ(self, column, j2start=0):
        """
        filterJ(DconferenceFilter self, charVector column, int j2start=0) -> bool
        filterJ(DconferenceFilter self, charVector column) -> bool



        return True if the extension satisfies all J-characteristic checks  

        """
        return _oalib.DconferenceFilter_filterJ(self, column, j2start)


    def filterJlast(self, c, j2start=0):
        """
        filterJlast(DconferenceFilter self, charVector c, int j2start=0) -> bool
        filterJlast(DconferenceFilter self, charVector c) -> bool



        return True if the extension satisfies all J-characteristic checks for the last
        columns  

        """
        return _oalib.DconferenceFilter_filterJlast(self, c, j2start)


    def filterReason(self, column):
        """
        filterReason(DconferenceFilter self, charVector column) -> bool



        return True if the extension satisfies all checks. prints the reason for
        returning True or False to stdout  

        """
        return _oalib.DconferenceFilter_filterReason(self, column)


    def filterJ3(self, column):
        """
        filterJ3(DconferenceFilter self, charVector column) -> bool



        return True if the candidate satisfies the J3 check  

        """
        return _oalib.DconferenceFilter_filterJ3(self, column)


    def filterJ3s(self, column, idxstart):
        """
        filterJ3s(DconferenceFilter self, charVector column, int idxstart) -> bool



        return True if the candidate satisfies the J3 check for specified pairs  

        """
        return _oalib.DconferenceFilter_filterJ3s(self, column, idxstart)


    def filterJ3inline(self, column):
        """
        filterJ3inline(DconferenceFilter self, charVector column) -> bool



        return True if the candidate satisfies the J3 check  

        """
        return _oalib.DconferenceFilter_filterJ3inline(self, column)


    def filterSymmetry(self, column):
        """
        filterSymmetry(DconferenceFilter self, charVector column) -> bool



        return True of the candidate satisfies the symmetry check  

        """
        return _oalib.DconferenceFilter_filterSymmetry(self, column)


    def filterJ2(self, c):
        """
        filterJ2(DconferenceFilter self, charVector c) -> bool



        return True of the candidate extension satisfies the J2 check  

        """
        return _oalib.DconferenceFilter_filterJ2(self, c)


    def filterJ2last(self, c):
        """
        filterJ2last(DconferenceFilter self, charVector c) -> bool



        return True of the candidate extension satisfies the J2 check for the last
        column of the array checked against  

        """
        return _oalib.DconferenceFilter_filterJ2last(self, c)


    def filterZero(self, c):
        """
        filterZero(DconferenceFilter self, charVector c) -> bool



        return True of the candidate extension satisfies the zero check  

        This means that the first entries of the extension do not contain a zero.  

        """
        return _oalib.DconferenceFilter_filterZero(self, c)

    __swig_destroy__ = _oalib.delete_DconferenceFilter
    __del__ = lambda self: None
DconferenceFilter_swigregister = _oalib.DconferenceFilter_swigregister
DconferenceFilter_swigregister(DconferenceFilter)


def unittest_reduceConferenceTransformation():
    """
    unittest_reduceConferenceTransformation() -> int



    """
    return _oalib.unittest_reduceConferenceTransformation()

def unittest_nautynormalform(al, verbose):
    """
    unittest_nautynormalform(array_link al, int verbose) -> int



    """
    return _oalib.unittest_nautynormalform(al, verbose)

def checkTransformationComposition(al, verbose=0):
    """
    checkTransformationComposition(array_link al, int verbose=0) -> int
    checkTransformationComposition(array_link al) -> int



    """
    return _oalib.checkTransformationComposition(al, verbose)

def test_array_manipulation(verbose=1):
    """
    test_array_manipulation(int verbose=1)
    test_array_manipulation()



    """
    return _oalib.test_array_manipulation(verbose)

def checkConferenceComposition(al, verbose=0):
    """
    checkConferenceComposition(array_link al, int verbose=0) -> int
    checkConferenceComposition(array_link al) -> int



    """
    return _oalib.checkConferenceComposition(al, verbose)

def test_conference_candidate_generators(verbose=1):
    """
    test_conference_candidate_generators(int verbose=1)
    test_conference_candidate_generators()



    """
    return _oalib.test_conference_candidate_generators(verbose)

def checkTransformationInverse(al):
    """
    checkTransformationInverse(array_link al) -> int



    """
    return _oalib.checkTransformationInverse(al)

def checkConferenceInverse(array):
    """
    checkConferenceInverse(array_link array) -> int



    """
    return _oalib.checkConferenceInverse(array)

def testLMC0checkDC(al, verbose=1):
    """
    testLMC0checkDC(array_link al, int verbose=1) -> bool
    testLMC0checkDC(array_link al) -> bool



    """
    return _oalib.testLMC0checkDC(al, verbose)
class pairDoptimize(object):
    """Proxy of C++ std::pair<(std::vector<(std::vector<(double)>)>,arraylist_t)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(std::vector<(std::vector<(double)>)>,arraylist_t)> self) -> pairDoptimize
        __init__(std::pair<(std::vector<(std::vector<(double)>)>,arraylist_t)> self, vector_vector_double first, arraylist_t second) -> pairDoptimize
        __init__(std::pair<(std::vector<(std::vector<(double)>)>,arraylist_t)> self, pairDoptimize p) -> pairDoptimize
        """
        this = _oalib.new_pairDoptimize(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    first = _swig_property(_oalib.pairDoptimize_first_get, _oalib.pairDoptimize_first_set)
    second = _swig_property(_oalib.pairDoptimize_second_get, _oalib.pairDoptimize_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _oalib.delete_pairDoptimize
    __del__ = lambda self: None
pairDoptimize_swigregister = _oalib.pairDoptimize_swigregister
pairDoptimize_swigregister(pairDoptimize)

class pairGraphColors(object):
    """Proxy of C++ std::pair<(array_link,std::vector<(int)>)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(array_link,std::vector<(int)>)> self) -> pairGraphColors
        __init__(std::pair<(array_link,std::vector<(int)>)> self, array_link first, intVector second) -> pairGraphColors
        __init__(std::pair<(array_link,std::vector<(int)>)> self, pairGraphColors p) -> pairGraphColors
        """
        this = _oalib.new_pairGraphColors(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    first = _swig_property(_oalib.pairGraphColors_first_get, _oalib.pairGraphColors_first_set)
    second = _swig_property(_oalib.pairGraphColors_second_get, _oalib.pairGraphColors_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _oalib.delete_pairGraphColors
    __del__ = lambda self: None
pairGraphColors_swigregister = _oalib.pairGraphColors_swigregister
pairGraphColors_swigregister(pairGraphColors)

class pairEigenMatrix(object):
    """Proxy of C++ std::pair<(MatrixFloat,MatrixFloat)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(std::pair<(MatrixFloat,MatrixFloat)> self) -> pairEigenMatrix
        __init__(std::pair<(MatrixFloat,MatrixFloat)> self, Eigen::MatrixXd first, Eigen::MatrixXd second) -> pairEigenMatrix
        __init__(std::pair<(MatrixFloat,MatrixFloat)> self, pairEigenMatrix p) -> pairEigenMatrix
        """
        this = _oalib.new_pairEigenMatrix(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    first = _swig_property(_oalib.pairEigenMatrix_first_get, _oalib.pairEigenMatrix_first_set)
    second = _swig_property(_oalib.pairEigenMatrix_second_get, _oalib.pairEigenMatrix_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _oalib.delete_pairEigenMatrix
    __del__ = lambda self: None
pairEigenMatrix_swigregister = _oalib.pairEigenMatrix_swigregister
pairEigenMatrix_swigregister(pairEigenMatrix)

class mvalue_t_long(object):
    """


    Multi-value type.  

    This object represents a multi-valued object. The objects are ordered using
    lexicographic ordering.  

    C++ includes: mathtools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    values = _swig_property(_oalib.mvalue_t_long_values_get, _oalib.mvalue_t_long_values_set)
    HIGH = _oalib.mvalue_t_long_HIGH
    LOW = _oalib.mvalue_t_long_LOW
    ordering = _swig_property(_oalib.mvalue_t_long_ordering_get, _oalib.mvalue_t_long_ordering_set)
    __swig_destroy__ = _oalib.delete_mvalue_t_long
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(mvalue_t<(long)> self) -> mvalue_t_long
        __init__(mvalue_t<(long)> self, long element, mvalue_t< long >::direction_t dd) -> mvalue_t_long
        __init__(mvalue_t<(long)> self, long element) -> mvalue_t_long
        __init__(mvalue_t<(long)> self, longVector elements, mvalue_t< long >::direction_t dd) -> mvalue_t_long
        __init__(mvalue_t<(long)> self, longVector elements) -> mvalue_t_long



        Create multi-valued object  

        The object consists of a vector of elements.  

        Parameters
        ----------
        * `elements` :  
            Vector to use for initalization of the object  
        * `dd` :  
            Ordering to use  

        """
        this = _oalib.new_mvalue_t_long(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def raw_values(self):
        """
        raw_values(mvalue_t_long self) -> longVector



        Return vector with the raw values in this object.  

        """
        return _oalib.mvalue_t_long_raw_values(self)


    def size(self):
        """
        size(mvalue_t_long self) -> size_t



        """
        return _oalib.mvalue_t_long_size(self)


    def __eq__(self, rhs):
        """__eq__(mvalue_t_long self, mvalue_t_long rhs) -> bool"""
        return _oalib.mvalue_t_long___eq__(self, rhs)


    def __ne__(self, rhs):
        """__ne__(mvalue_t_long self, mvalue_t_long rhs) -> bool"""
        return _oalib.mvalue_t_long___ne__(self, rhs)


    def __le__(self, rhs):
        """__le__(mvalue_t_long self, mvalue_t_long rhs) -> bool"""
        return _oalib.mvalue_t_long___le__(self, rhs)


    def __lt__(self, rhs):
        """__lt__(mvalue_t_long self, mvalue_t_long rhs) -> bool"""
        return _oalib.mvalue_t_long___lt__(self, rhs)


    def __gt__(self, rhs):
        """__gt__(mvalue_t_long self, mvalue_t_long rhs) -> bool"""
        return _oalib.mvalue_t_long___gt__(self, rhs)


    def __ge__(self, rhs):
        """__ge__(mvalue_t_long self, mvalue_t_long rhs) -> bool"""
        return _oalib.mvalue_t_long___ge__(self, rhs)


    def show_integer(self):
        """
        show_integer(mvalue_t_long self)



        Show the object on stdout by casting to integer type objects.  

        """
        return _oalib.mvalue_t_long_show_integer(self)


    def string_representation(self, *args):
        """
        string_representation(mvalue_t_long self, char const * separator) -> std::string
        string_representation(mvalue_t_long self) -> std::string



        return a string representation of the object  

        """
        return _oalib.mvalue_t_long_string_representation(self, *args)

mvalue_t_long_swigregister = _oalib.mvalue_t_long_swigregister
mvalue_t_long_swigregister(mvalue_t_long)

class mvalue_t_double(object):
    """


    Multi-value type.  

    This object represents a multi-valued object. The objects are ordered using
    lexicographic ordering.  

    C++ includes: mathtools.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    values = _swig_property(_oalib.mvalue_t_double_values_get, _oalib.mvalue_t_double_values_set)
    HIGH = _oalib.mvalue_t_double_HIGH
    LOW = _oalib.mvalue_t_double_LOW
    ordering = _swig_property(_oalib.mvalue_t_double_ordering_get, _oalib.mvalue_t_double_ordering_set)
    __swig_destroy__ = _oalib.delete_mvalue_t_double
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        __init__(mvalue_t<(double)> self) -> mvalue_t_double
        __init__(mvalue_t<(double)> self, double element, mvalue_t< double >::direction_t dd) -> mvalue_t_double
        __init__(mvalue_t<(double)> self, double element) -> mvalue_t_double
        __init__(mvalue_t<(double)> self, doubleVector elements, mvalue_t< double >::direction_t dd) -> mvalue_t_double
        __init__(mvalue_t<(double)> self, doubleVector elements) -> mvalue_t_double



        Create multi-valued object  

        The object consists of a vector of elements.  

        Parameters
        ----------
        * `elements` :  
            Vector to use for initalization of the object  
        * `dd` :  
            Ordering to use  

        """
        this = _oalib.new_mvalue_t_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def raw_values(self):
        """
        raw_values(mvalue_t_double self) -> doubleVector



        Return vector with the raw values in this object.  

        """
        return _oalib.mvalue_t_double_raw_values(self)


    def size(self):
        """
        size(mvalue_t_double self) -> size_t



        """
        return _oalib.mvalue_t_double_size(self)


    def __eq__(self, rhs):
        """__eq__(mvalue_t_double self, mvalue_t_double rhs) -> bool"""
        return _oalib.mvalue_t_double___eq__(self, rhs)


    def __ne__(self, rhs):
        """__ne__(mvalue_t_double self, mvalue_t_double rhs) -> bool"""
        return _oalib.mvalue_t_double___ne__(self, rhs)


    def __le__(self, rhs):
        """__le__(mvalue_t_double self, mvalue_t_double rhs) -> bool"""
        return _oalib.mvalue_t_double___le__(self, rhs)


    def __lt__(self, rhs):
        """__lt__(mvalue_t_double self, mvalue_t_double rhs) -> bool"""
        return _oalib.mvalue_t_double___lt__(self, rhs)


    def __gt__(self, rhs):
        """__gt__(mvalue_t_double self, mvalue_t_double rhs) -> bool"""
        return _oalib.mvalue_t_double___gt__(self, rhs)


    def __ge__(self, rhs):
        """__ge__(mvalue_t_double self, mvalue_t_double rhs) -> bool"""
        return _oalib.mvalue_t_double___ge__(self, rhs)


    def show_integer(self):
        """
        show_integer(mvalue_t_double self)



        Show the object on stdout by casting to integer type objects.  

        """
        return _oalib.mvalue_t_double_show_integer(self)


    def string_representation(self, *args):
        """
        string_representation(mvalue_t_double self, char const * separator) -> std::string
        string_representation(mvalue_t_double self) -> std::string



        return a string representation of the object  

        """
        return _oalib.mvalue_t_double_string_representation(self, *args)



    def __getattr__(self, attr):
        if attr=='__array_interface__':
          a = dict()
          a['version']=3
          a['shape']=(x.size(), )
          sizeofdata=_oalib.sizeof_array_t()
          a['typestr']='<f%d' % sizeof(double)
          a['data']=np.array(self.v)
    #a['strides']=??
          return a
        else:
          raise AttributeError("%r object has no attribute %r" %
                             (self.__class__, attr))


mvalue_t_double_swigregister = _oalib.mvalue_t_double_swigregister
mvalue_t_double_swigregister(mvalue_t_double)

class ParetoLongLong(object):
    """


    Class to the calculate Pareto optimal elements.  

    The class is templated by the type of values to be compared and an index type.
    The index type is used to index the elements.  

    For elements added to the Pareto structure larger is better.  

    C++ includes: pareto.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    verbose = _swig_property(_oalib.ParetoLongLong_verbose_get, _oalib.ParetoLongLong_verbose_set)
    elements = _swig_property(_oalib.ParetoLongLong_elements_get, _oalib.ParetoLongLong_elements_set)

    def __init__(self):
        """
        __init__(Pareto<(long,long)> self) -> ParetoLongLong



        constructor  

        """
        this = _oalib.new_ParetoLongLong()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_ParetoLongLong
    __del__ = lambda self: None

    def number(self):
        """
        number(ParetoLongLong self) -> int



        return the total number of Pareto optimal values  

        """
        return _oalib.ParetoLongLong_number(self)


    def numberindices(self):
        """
        numberindices(ParetoLongLong self) -> int



        return the toal number Pareto optimal objects  

        """
        return _oalib.ParetoLongLong_numberindices(self)


    def __repr__(self):
        """
        __repr__(ParetoLongLong self) -> std::string



        """
        return _oalib.ParetoLongLong___repr__(self)


    def showvalue(p):
        """
        showvalue(longVector p)



        """
        return _oalib.ParetoLongLong_showvalue(p)

    showvalue = staticmethod(showvalue)

    def show(self, verbose=1):
        """
        show(ParetoLongLong self, int verbose=1)
        show(ParetoLongLong self)



        show the current set of Pareto optimal elements  

        """
        return _oalib.ParetoLongLong_show(self, verbose)


    def allindicesdeque(self):
        """
        allindicesdeque(ParetoLongLong self) -> longDeque



        return all indices of the Pareto optimal elements as a std::deque  

        """
        return _oalib.ParetoLongLong_allindicesdeque(self)


    def allindices(self):
        """
        allindices(ParetoLongLong self) -> longVector



        return all indices of the Pareto optimal elements  

        """
        return _oalib.ParetoLongLong_allindices(self)


    def allvalues(self):
        """
        allvalues(ParetoLongLong self) -> std::vector< Pareto< long,long >::pValue,std::allocator< Pareto< long,long >::pValue > >



        return all Paretop optimal elements  

        """
        return _oalib.ParetoLongLong_allvalues(self)


    def addvalue(self, value, idx):
        """
        addvalue(ParetoLongLong self, longVector value, long const idx) -> bool



        add a new element  

        """
        return _oalib.ParetoLongLong_addvalue(self, value, idx)

ParetoLongLong_swigregister = _oalib.ParetoLongLong_swigregister
ParetoLongLong_swigregister(ParetoLongLong)

def ParetoLongLong_showvalue(p):
    """
    ParetoLongLong_showvalue(longVector p)



    """
    return _oalib.ParetoLongLong_showvalue(p)

class ParetoMultiLongLong(object):
    """


    Class to the calculate Pareto optimal elements.  

    The class is templated by the type of values to be compared and an index type.
    The index type is used to index the elements.  

    For elements added to the Pareto structure larger is better.  

    C++ includes: pareto.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    verbose = _swig_property(_oalib.ParetoMultiLongLong_verbose_get, _oalib.ParetoMultiLongLong_verbose_set)
    elements = _swig_property(_oalib.ParetoMultiLongLong_elements_get, _oalib.ParetoMultiLongLong_elements_set)

    def __init__(self):
        """
        __init__(Pareto<(mvalue_t<(long)>,long)> self) -> ParetoMultiLongLong



        constructor  

        """
        this = _oalib.new_ParetoMultiLongLong()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_ParetoMultiLongLong
    __del__ = lambda self: None

    def number(self):
        """
        number(ParetoMultiLongLong self) -> int



        return the total number of Pareto optimal values  

        """
        return _oalib.ParetoMultiLongLong_number(self)


    def numberindices(self):
        """
        numberindices(ParetoMultiLongLong self) -> int



        return the toal number Pareto optimal objects  

        """
        return _oalib.ParetoMultiLongLong_numberindices(self)


    def __repr__(self):
        """
        __repr__(ParetoMultiLongLong self) -> std::string



        """
        return _oalib.ParetoMultiLongLong___repr__(self)


    def showvalue(p):
        """
        showvalue(vector_mvalue_t_long p)



        """
        return _oalib.ParetoMultiLongLong_showvalue(p)

    showvalue = staticmethod(showvalue)

    def show(self, verbose=1):
        """
        show(ParetoMultiLongLong self, int verbose=1)
        show(ParetoMultiLongLong self)



        show the current set of Pareto optimal elements  

        """
        return _oalib.ParetoMultiLongLong_show(self, verbose)


    def allindicesdeque(self):
        """
        allindicesdeque(ParetoMultiLongLong self) -> longDeque



        return all indices of the Pareto optimal elements as a std::deque  

        """
        return _oalib.ParetoMultiLongLong_allindicesdeque(self)


    def allindices(self):
        """
        allindices(ParetoMultiLongLong self) -> longVector



        return all indices of the Pareto optimal elements  

        """
        return _oalib.ParetoMultiLongLong_allindices(self)


    def allvalues(self):
        """
        allvalues(ParetoMultiLongLong self) -> std::vector< Pareto< mvalue_t< long >,long >::pValue,std::allocator< Pareto< mvalue_t< long >,long >::pValue > >



        return all Paretop optimal elements  

        """
        return _oalib.ParetoMultiLongLong_allvalues(self)


    def addvalue(self, value, idx):
        """
        addvalue(ParetoMultiLongLong self, vector_mvalue_t_long value, long const idx) -> bool



        add a new element  

        """
        return _oalib.ParetoMultiLongLong_addvalue(self, value, idx)

ParetoMultiLongLong_swigregister = _oalib.ParetoMultiLongLong_swigregister
ParetoMultiLongLong_swigregister(ParetoMultiLongLong)

def ParetoMultiLongLong_showvalue(p):
    """
    ParetoMultiLongLong_showvalue(vector_mvalue_t_long p)



    """
    return _oalib.ParetoMultiLongLong_showvalue(p)

class ParetoMultiDoubleLong(object):
    """


    Class to the calculate Pareto optimal elements.  

    The class is templated by the type of values to be compared and an index type.
    The index type is used to index the elements.  

    For elements added to the Pareto structure larger is better.  

    C++ includes: pareto.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    verbose = _swig_property(_oalib.ParetoMultiDoubleLong_verbose_get, _oalib.ParetoMultiDoubleLong_verbose_set)
    elements = _swig_property(_oalib.ParetoMultiDoubleLong_elements_get, _oalib.ParetoMultiDoubleLong_elements_set)

    def __init__(self):
        """
        __init__(Pareto<(mvalue_t<(double)>,long)> self) -> ParetoMultiDoubleLong



        constructor  

        """
        this = _oalib.new_ParetoMultiDoubleLong()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_ParetoMultiDoubleLong
    __del__ = lambda self: None

    def number(self):
        """
        number(ParetoMultiDoubleLong self) -> int



        return the total number of Pareto optimal values  

        """
        return _oalib.ParetoMultiDoubleLong_number(self)


    def numberindices(self):
        """
        numberindices(ParetoMultiDoubleLong self) -> int



        return the toal number Pareto optimal objects  

        """
        return _oalib.ParetoMultiDoubleLong_numberindices(self)


    def __repr__(self):
        """
        __repr__(ParetoMultiDoubleLong self) -> std::string



        """
        return _oalib.ParetoMultiDoubleLong___repr__(self)


    def showvalue(p):
        """
        showvalue(vector_mvalue_t_double p)



        """
        return _oalib.ParetoMultiDoubleLong_showvalue(p)

    showvalue = staticmethod(showvalue)

    def show(self, verbose=1):
        """
        show(ParetoMultiDoubleLong self, int verbose=1)
        show(ParetoMultiDoubleLong self)



        show the current set of Pareto optimal elements  

        """
        return _oalib.ParetoMultiDoubleLong_show(self, verbose)


    def allindicesdeque(self):
        """
        allindicesdeque(ParetoMultiDoubleLong self) -> longDeque



        return all indices of the Pareto optimal elements as a std::deque  

        """
        return _oalib.ParetoMultiDoubleLong_allindicesdeque(self)


    def allindices(self):
        """
        allindices(ParetoMultiDoubleLong self) -> longVector



        return all indices of the Pareto optimal elements  

        """
        return _oalib.ParetoMultiDoubleLong_allindices(self)


    def allvalues(self):
        """
        allvalues(ParetoMultiDoubleLong self) -> std::vector< Pareto< mvalue_t< double >,long >::pValue,std::allocator< Pareto< mvalue_t< double >,long >::pValue > >



        return all Paretop optimal elements  

        """
        return _oalib.ParetoMultiDoubleLong_allvalues(self)


    def addvalue(self, value, idx):
        """
        addvalue(ParetoMultiDoubleLong self, vector_mvalue_t_double value, long const idx) -> bool



        add a new element  

        """
        return _oalib.ParetoMultiDoubleLong_addvalue(self, value, idx)

ParetoMultiDoubleLong_swigregister = _oalib.ParetoMultiDoubleLong_swigregister
ParetoMultiDoubleLong_swigregister(ParetoMultiDoubleLong)

def ParetoMultiDoubleLong_showvalue(p):
    """
    ParetoMultiDoubleLong_showvalue(vector_mvalue_t_double p)



    """
    return _oalib.ParetoMultiDoubleLong_showvalue(p)

class ParetoDoubleLong(object):
    """


    Class to the calculate Pareto optimal elements.  

    The class is templated by the type of values to be compared and an index type.
    The index type is used to index the elements.  

    For elements added to the Pareto structure larger is better.  

    C++ includes: pareto.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    verbose = _swig_property(_oalib.ParetoDoubleLong_verbose_get, _oalib.ParetoDoubleLong_verbose_set)
    elements = _swig_property(_oalib.ParetoDoubleLong_elements_get, _oalib.ParetoDoubleLong_elements_set)

    def __init__(self):
        """
        __init__(Pareto<(double,long)> self) -> ParetoDoubleLong



        constructor  

        """
        this = _oalib.new_ParetoDoubleLong()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_ParetoDoubleLong
    __del__ = lambda self: None

    def number(self):
        """
        number(ParetoDoubleLong self) -> int



        return the total number of Pareto optimal values  

        """
        return _oalib.ParetoDoubleLong_number(self)


    def numberindices(self):
        """
        numberindices(ParetoDoubleLong self) -> int



        return the toal number Pareto optimal objects  

        """
        return _oalib.ParetoDoubleLong_numberindices(self)


    def __repr__(self):
        """
        __repr__(ParetoDoubleLong self) -> std::string



        """
        return _oalib.ParetoDoubleLong___repr__(self)


    def showvalue(p):
        """
        showvalue(doubleVector p)



        """
        return _oalib.ParetoDoubleLong_showvalue(p)

    showvalue = staticmethod(showvalue)

    def show(self, verbose=1):
        """
        show(ParetoDoubleLong self, int verbose=1)
        show(ParetoDoubleLong self)



        show the current set of Pareto optimal elements  

        """
        return _oalib.ParetoDoubleLong_show(self, verbose)


    def allindicesdeque(self):
        """
        allindicesdeque(ParetoDoubleLong self) -> longDeque



        return all indices of the Pareto optimal elements as a std::deque  

        """
        return _oalib.ParetoDoubleLong_allindicesdeque(self)


    def allindices(self):
        """
        allindices(ParetoDoubleLong self) -> longVector



        return all indices of the Pareto optimal elements  

        """
        return _oalib.ParetoDoubleLong_allindices(self)


    def allvalues(self):
        """
        allvalues(ParetoDoubleLong self) -> vector_vector_double



        return all Paretop optimal elements  

        """
        return _oalib.ParetoDoubleLong_allvalues(self)


    def addvalue(self, value, idx):
        """
        addvalue(ParetoDoubleLong self, doubleVector value, long const idx) -> bool



        add a new element  

        """
        return _oalib.ParetoDoubleLong_addvalue(self, value, idx)

ParetoDoubleLong_swigregister = _oalib.ParetoDoubleLong_swigregister
ParetoDoubleLong_swigregister(ParetoDoubleLong)

def ParetoDoubleLong_showvalue(p):
    """
    ParetoDoubleLong_showvalue(doubleVector p)



    """
    return _oalib.ParetoDoubleLong_showvalue(p)

class ParetoElementLong(object):
    """


    helper class for the Pareto class to hold elements  

    C++ includes: pareto.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    value = _swig_property(_oalib.ParetoElementLong_value_get, _oalib.ParetoElementLong_value_set)
    indices = _swig_property(_oalib.ParetoElementLong_indices_get, _oalib.ParetoElementLong_indices_set)

    def dominates(self, v):
        """
        dominates(ParetoElementLong self, vector_mvalue_t_long v) -> bool



        return true of the argument element dominates this value  

        """
        return _oalib.ParetoElementLong_dominates(self, v)


    def isdominated(self, v):
        """
        isdominated(ParetoElementLong self, vector_mvalue_t_long v) -> bool



        return true of the argument element is dominated by this value  

        """
        return _oalib.ParetoElementLong_isdominated(self, v)


    def equal(self, v):
        """
        equal(ParetoElementLong self, vector_mvalue_t_long v) -> bool



        return true of the argument element is equal to this element  

        """
        return _oalib.ParetoElementLong_equal(self, v)


    def __init__(self):
        """
        __init__(pareto_element<(mvalue_t<(long)>,long)> self) -> ParetoElementLong



        helper class for the Pareto class to hold elements  

        C++ includes: pareto.h

        """
        this = _oalib.new_ParetoElementLong()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_ParetoElementLong
    __del__ = lambda self: None
ParetoElementLong_swigregister = _oalib.ParetoElementLong_swigregister
ParetoElementLong_swigregister(ParetoElementLong)

class ParetoMElementLong(object):
    """


    helper class for the Pareto class to hold elements  

    C++ includes: pareto.h

    """

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    value = _swig_property(_oalib.ParetoMElementLong_value_get, _oalib.ParetoMElementLong_value_set)
    indices = _swig_property(_oalib.ParetoMElementLong_indices_get, _oalib.ParetoMElementLong_indices_set)

    def dominates(self, v):
        """
        dominates(ParetoMElementLong self, vector_mvalue_t_long v) -> bool



        return true of the argument element dominates this value  

        """
        return _oalib.ParetoMElementLong_dominates(self, v)


    def isdominated(self, v):
        """
        isdominated(ParetoMElementLong self, vector_mvalue_t_long v) -> bool



        return true of the argument element is dominated by this value  

        """
        return _oalib.ParetoMElementLong_isdominated(self, v)


    def equal(self, v):
        """
        equal(ParetoMElementLong self, vector_mvalue_t_long v) -> bool



        return true of the argument element is equal to this element  

        """
        return _oalib.ParetoMElementLong_equal(self, v)


    def __init__(self):
        """
        __init__(pareto_element<(mvalue_t<(long)>,long)> self) -> ParetoMElementLong



        helper class for the Pareto class to hold elements  

        C++ includes: pareto.h

        """
        this = _oalib.new_ParetoMElementLong()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _oalib.delete_ParetoMElementLong
    __del__ = lambda self: None
ParetoMElementLong_swigregister = _oalib.ParetoMElementLong_swigregister
ParetoMElementLong_swigregister(ParetoMElementLong)

class vector_mvalue_t_double(object):
    """Proxy of C++ std::vector<(mvalue_t<(double)>)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_mvalue_t_double self) -> SwigPyIterator"""
        return _oalib.vector_mvalue_t_double_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_mvalue_t_double self) -> bool"""
        return _oalib.vector_mvalue_t_double___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_mvalue_t_double self) -> bool"""
        return _oalib.vector_mvalue_t_double___bool__(self)


    def __len__(self):
        """__len__(vector_mvalue_t_double self) -> std::vector< mvalue_t< double > >::size_type"""
        return _oalib.vector_mvalue_t_double___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::difference_type i, std::vector< mvalue_t< double > >::difference_type j) -> vector_mvalue_t_double"""
        return _oalib.vector_mvalue_t_double___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::difference_type i, std::vector< mvalue_t< double > >::difference_type j)
        __setslice__(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::difference_type i, std::vector< mvalue_t< double > >::difference_type j, vector_mvalue_t_double v)
        """
        return _oalib.vector_mvalue_t_double___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::difference_type i, std::vector< mvalue_t< double > >::difference_type j)"""
        return _oalib.vector_mvalue_t_double___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::difference_type i)
        __delitem__(vector_mvalue_t_double self, PySliceObject * slice)
        """
        return _oalib.vector_mvalue_t_double___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_mvalue_t_double self, PySliceObject * slice) -> vector_mvalue_t_double
        __getitem__(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::difference_type i) -> mvalue_t_double
        """
        return _oalib.vector_mvalue_t_double___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_mvalue_t_double self, PySliceObject * slice, vector_mvalue_t_double v)
        __setitem__(vector_mvalue_t_double self, PySliceObject * slice)
        __setitem__(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::difference_type i, mvalue_t_double x)
        """
        return _oalib.vector_mvalue_t_double___setitem__(self, *args)


    def pop(self):
        """pop(vector_mvalue_t_double self) -> mvalue_t_double"""
        return _oalib.vector_mvalue_t_double_pop(self)


    def append(self, x):
        """append(vector_mvalue_t_double self, mvalue_t_double x)"""
        return _oalib.vector_mvalue_t_double_append(self, x)


    def empty(self):
        """empty(vector_mvalue_t_double self) -> bool"""
        return _oalib.vector_mvalue_t_double_empty(self)


    def size(self):
        """size(vector_mvalue_t_double self) -> std::vector< mvalue_t< double > >::size_type"""
        return _oalib.vector_mvalue_t_double_size(self)


    def swap(self, v):
        """swap(vector_mvalue_t_double self, vector_mvalue_t_double v)"""
        return _oalib.vector_mvalue_t_double_swap(self, v)


    def begin(self):
        """begin(vector_mvalue_t_double self) -> std::vector< mvalue_t< double > >::iterator"""
        return _oalib.vector_mvalue_t_double_begin(self)


    def end(self):
        """end(vector_mvalue_t_double self) -> std::vector< mvalue_t< double > >::iterator"""
        return _oalib.vector_mvalue_t_double_end(self)


    def rbegin(self):
        """rbegin(vector_mvalue_t_double self) -> std::vector< mvalue_t< double > >::reverse_iterator"""
        return _oalib.vector_mvalue_t_double_rbegin(self)


    def rend(self):
        """rend(vector_mvalue_t_double self) -> std::vector< mvalue_t< double > >::reverse_iterator"""
        return _oalib.vector_mvalue_t_double_rend(self)


    def clear(self):
        """clear(vector_mvalue_t_double self)"""
        return _oalib.vector_mvalue_t_double_clear(self)


    def get_allocator(self):
        """get_allocator(vector_mvalue_t_double self) -> std::vector< mvalue_t< double > >::allocator_type"""
        return _oalib.vector_mvalue_t_double_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_mvalue_t_double self)"""
        return _oalib.vector_mvalue_t_double_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::iterator pos) -> std::vector< mvalue_t< double > >::iterator
        erase(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::iterator first, std::vector< mvalue_t< double > >::iterator last) -> std::vector< mvalue_t< double > >::iterator
        """
        return _oalib.vector_mvalue_t_double_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(mvalue_t<(double)>)> self) -> vector_mvalue_t_double
        __init__(std::vector<(mvalue_t<(double)>)> self, vector_mvalue_t_double arg2) -> vector_mvalue_t_double
        __init__(std::vector<(mvalue_t<(double)>)> self, std::vector< mvalue_t< double > >::size_type size) -> vector_mvalue_t_double
        __init__(std::vector<(mvalue_t<(double)>)> self, std::vector< mvalue_t< double > >::size_type size, mvalue_t_double value) -> vector_mvalue_t_double
        """
        this = _oalib.new_vector_mvalue_t_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_mvalue_t_double self, mvalue_t_double x)"""
        return _oalib.vector_mvalue_t_double_push_back(self, x)


    def front(self):
        """front(vector_mvalue_t_double self) -> mvalue_t_double"""
        return _oalib.vector_mvalue_t_double_front(self)


    def back(self):
        """back(vector_mvalue_t_double self) -> mvalue_t_double"""
        return _oalib.vector_mvalue_t_double_back(self)


    def assign(self, n, x):
        """assign(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::size_type n, mvalue_t_double x)"""
        return _oalib.vector_mvalue_t_double_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::size_type new_size)
        resize(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::size_type new_size, mvalue_t_double x)
        """
        return _oalib.vector_mvalue_t_double_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::iterator pos, mvalue_t_double x) -> std::vector< mvalue_t< double > >::iterator
        insert(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::iterator pos, std::vector< mvalue_t< double > >::size_type n, mvalue_t_double x)
        """
        return _oalib.vector_mvalue_t_double_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_mvalue_t_double self, std::vector< mvalue_t< double > >::size_type n)"""
        return _oalib.vector_mvalue_t_double_reserve(self, n)


    def capacity(self):
        """capacity(vector_mvalue_t_double self) -> std::vector< mvalue_t< double > >::size_type"""
        return _oalib.vector_mvalue_t_double_capacity(self)

    __swig_destroy__ = _oalib.delete_vector_mvalue_t_double
    __del__ = lambda self: None
vector_mvalue_t_double_swigregister = _oalib.vector_mvalue_t_double_swigregister
vector_mvalue_t_double_swigregister(vector_mvalue_t_double)

class vector_mvalue_t_int(object):
    """Proxy of C++ std::vector<(mvalue_t<(int)>)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_mvalue_t_int self) -> SwigPyIterator"""
        return _oalib.vector_mvalue_t_int_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_mvalue_t_int self) -> bool"""
        return _oalib.vector_mvalue_t_int___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_mvalue_t_int self) -> bool"""
        return _oalib.vector_mvalue_t_int___bool__(self)


    def __len__(self):
        """__len__(vector_mvalue_t_int self) -> std::vector< mvalue_t< int > >::size_type"""
        return _oalib.vector_mvalue_t_int___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::difference_type i, std::vector< mvalue_t< int > >::difference_type j) -> vector_mvalue_t_int"""
        return _oalib.vector_mvalue_t_int___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::difference_type i, std::vector< mvalue_t< int > >::difference_type j)
        __setslice__(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::difference_type i, std::vector< mvalue_t< int > >::difference_type j, vector_mvalue_t_int v)
        """
        return _oalib.vector_mvalue_t_int___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::difference_type i, std::vector< mvalue_t< int > >::difference_type j)"""
        return _oalib.vector_mvalue_t_int___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::difference_type i)
        __delitem__(vector_mvalue_t_int self, PySliceObject * slice)
        """
        return _oalib.vector_mvalue_t_int___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_mvalue_t_int self, PySliceObject * slice) -> vector_mvalue_t_int
        __getitem__(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::difference_type i) -> std::vector< mvalue_t< int > >::value_type const &
        """
        return _oalib.vector_mvalue_t_int___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_mvalue_t_int self, PySliceObject * slice, vector_mvalue_t_int v)
        __setitem__(vector_mvalue_t_int self, PySliceObject * slice)
        __setitem__(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::difference_type i, std::vector< mvalue_t< int > >::value_type const & x)
        """
        return _oalib.vector_mvalue_t_int___setitem__(self, *args)


    def pop(self):
        """pop(vector_mvalue_t_int self) -> std::vector< mvalue_t< int > >::value_type"""
        return _oalib.vector_mvalue_t_int_pop(self)


    def append(self, x):
        """append(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::value_type const & x)"""
        return _oalib.vector_mvalue_t_int_append(self, x)


    def empty(self):
        """empty(vector_mvalue_t_int self) -> bool"""
        return _oalib.vector_mvalue_t_int_empty(self)


    def size(self):
        """size(vector_mvalue_t_int self) -> std::vector< mvalue_t< int > >::size_type"""
        return _oalib.vector_mvalue_t_int_size(self)


    def swap(self, v):
        """swap(vector_mvalue_t_int self, vector_mvalue_t_int v)"""
        return _oalib.vector_mvalue_t_int_swap(self, v)


    def begin(self):
        """begin(vector_mvalue_t_int self) -> std::vector< mvalue_t< int > >::iterator"""
        return _oalib.vector_mvalue_t_int_begin(self)


    def end(self):
        """end(vector_mvalue_t_int self) -> std::vector< mvalue_t< int > >::iterator"""
        return _oalib.vector_mvalue_t_int_end(self)


    def rbegin(self):
        """rbegin(vector_mvalue_t_int self) -> std::vector< mvalue_t< int > >::reverse_iterator"""
        return _oalib.vector_mvalue_t_int_rbegin(self)


    def rend(self):
        """rend(vector_mvalue_t_int self) -> std::vector< mvalue_t< int > >::reverse_iterator"""
        return _oalib.vector_mvalue_t_int_rend(self)


    def clear(self):
        """clear(vector_mvalue_t_int self)"""
        return _oalib.vector_mvalue_t_int_clear(self)


    def get_allocator(self):
        """get_allocator(vector_mvalue_t_int self) -> std::vector< mvalue_t< int > >::allocator_type"""
        return _oalib.vector_mvalue_t_int_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_mvalue_t_int self)"""
        return _oalib.vector_mvalue_t_int_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::iterator pos) -> std::vector< mvalue_t< int > >::iterator
        erase(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::iterator first, std::vector< mvalue_t< int > >::iterator last) -> std::vector< mvalue_t< int > >::iterator
        """
        return _oalib.vector_mvalue_t_int_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(mvalue_t<(int)>)> self) -> vector_mvalue_t_int
        __init__(std::vector<(mvalue_t<(int)>)> self, vector_mvalue_t_int arg2) -> vector_mvalue_t_int
        __init__(std::vector<(mvalue_t<(int)>)> self, std::vector< mvalue_t< int > >::size_type size) -> vector_mvalue_t_int
        __init__(std::vector<(mvalue_t<(int)>)> self, std::vector< mvalue_t< int > >::size_type size, std::vector< mvalue_t< int > >::value_type const & value) -> vector_mvalue_t_int
        """
        this = _oalib.new_vector_mvalue_t_int(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::value_type const & x)"""
        return _oalib.vector_mvalue_t_int_push_back(self, x)


    def front(self):
        """front(vector_mvalue_t_int self) -> std::vector< mvalue_t< int > >::value_type const &"""
        return _oalib.vector_mvalue_t_int_front(self)


    def back(self):
        """back(vector_mvalue_t_int self) -> std::vector< mvalue_t< int > >::value_type const &"""
        return _oalib.vector_mvalue_t_int_back(self)


    def assign(self, n, x):
        """assign(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::size_type n, std::vector< mvalue_t< int > >::value_type const & x)"""
        return _oalib.vector_mvalue_t_int_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::size_type new_size)
        resize(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::size_type new_size, std::vector< mvalue_t< int > >::value_type const & x)
        """
        return _oalib.vector_mvalue_t_int_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::iterator pos, std::vector< mvalue_t< int > >::value_type const & x) -> std::vector< mvalue_t< int > >::iterator
        insert(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::iterator pos, std::vector< mvalue_t< int > >::size_type n, std::vector< mvalue_t< int > >::value_type const & x)
        """
        return _oalib.vector_mvalue_t_int_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_mvalue_t_int self, std::vector< mvalue_t< int > >::size_type n)"""
        return _oalib.vector_mvalue_t_int_reserve(self, n)


    def capacity(self):
        """capacity(vector_mvalue_t_int self) -> std::vector< mvalue_t< int > >::size_type"""
        return _oalib.vector_mvalue_t_int_capacity(self)

    __swig_destroy__ = _oalib.delete_vector_mvalue_t_int
    __del__ = lambda self: None
vector_mvalue_t_int_swigregister = _oalib.vector_mvalue_t_int_swigregister
vector_mvalue_t_int_swigregister(vector_mvalue_t_int)

class vector_mvalue_t_long(object):
    """Proxy of C++ std::vector<(mvalue_t<(long)>)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_mvalue_t_long self) -> SwigPyIterator"""
        return _oalib.vector_mvalue_t_long_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_mvalue_t_long self) -> bool"""
        return _oalib.vector_mvalue_t_long___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_mvalue_t_long self) -> bool"""
        return _oalib.vector_mvalue_t_long___bool__(self)


    def __len__(self):
        """__len__(vector_mvalue_t_long self) -> std::vector< mvalue_t< long > >::size_type"""
        return _oalib.vector_mvalue_t_long___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::difference_type i, std::vector< mvalue_t< long > >::difference_type j) -> vector_mvalue_t_long"""
        return _oalib.vector_mvalue_t_long___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::difference_type i, std::vector< mvalue_t< long > >::difference_type j)
        __setslice__(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::difference_type i, std::vector< mvalue_t< long > >::difference_type j, vector_mvalue_t_long v)
        """
        return _oalib.vector_mvalue_t_long___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::difference_type i, std::vector< mvalue_t< long > >::difference_type j)"""
        return _oalib.vector_mvalue_t_long___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::difference_type i)
        __delitem__(vector_mvalue_t_long self, PySliceObject * slice)
        """
        return _oalib.vector_mvalue_t_long___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_mvalue_t_long self, PySliceObject * slice) -> vector_mvalue_t_long
        __getitem__(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::difference_type i) -> mvalue_t_long
        """
        return _oalib.vector_mvalue_t_long___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_mvalue_t_long self, PySliceObject * slice, vector_mvalue_t_long v)
        __setitem__(vector_mvalue_t_long self, PySliceObject * slice)
        __setitem__(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::difference_type i, mvalue_t_long x)
        """
        return _oalib.vector_mvalue_t_long___setitem__(self, *args)


    def pop(self):
        """pop(vector_mvalue_t_long self) -> mvalue_t_long"""
        return _oalib.vector_mvalue_t_long_pop(self)


    def append(self, x):
        """append(vector_mvalue_t_long self, mvalue_t_long x)"""
        return _oalib.vector_mvalue_t_long_append(self, x)


    def empty(self):
        """empty(vector_mvalue_t_long self) -> bool"""
        return _oalib.vector_mvalue_t_long_empty(self)


    def size(self):
        """size(vector_mvalue_t_long self) -> std::vector< mvalue_t< long > >::size_type"""
        return _oalib.vector_mvalue_t_long_size(self)


    def swap(self, v):
        """swap(vector_mvalue_t_long self, vector_mvalue_t_long v)"""
        return _oalib.vector_mvalue_t_long_swap(self, v)


    def begin(self):
        """begin(vector_mvalue_t_long self) -> std::vector< mvalue_t< long > >::iterator"""
        return _oalib.vector_mvalue_t_long_begin(self)


    def end(self):
        """end(vector_mvalue_t_long self) -> std::vector< mvalue_t< long > >::iterator"""
        return _oalib.vector_mvalue_t_long_end(self)


    def rbegin(self):
        """rbegin(vector_mvalue_t_long self) -> std::vector< mvalue_t< long > >::reverse_iterator"""
        return _oalib.vector_mvalue_t_long_rbegin(self)


    def rend(self):
        """rend(vector_mvalue_t_long self) -> std::vector< mvalue_t< long > >::reverse_iterator"""
        return _oalib.vector_mvalue_t_long_rend(self)


    def clear(self):
        """clear(vector_mvalue_t_long self)"""
        return _oalib.vector_mvalue_t_long_clear(self)


    def get_allocator(self):
        """get_allocator(vector_mvalue_t_long self) -> std::vector< mvalue_t< long > >::allocator_type"""
        return _oalib.vector_mvalue_t_long_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_mvalue_t_long self)"""
        return _oalib.vector_mvalue_t_long_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::iterator pos) -> std::vector< mvalue_t< long > >::iterator
        erase(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::iterator first, std::vector< mvalue_t< long > >::iterator last) -> std::vector< mvalue_t< long > >::iterator
        """
        return _oalib.vector_mvalue_t_long_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(mvalue_t<(long)>)> self) -> vector_mvalue_t_long
        __init__(std::vector<(mvalue_t<(long)>)> self, vector_mvalue_t_long arg2) -> vector_mvalue_t_long
        __init__(std::vector<(mvalue_t<(long)>)> self, std::vector< mvalue_t< long > >::size_type size) -> vector_mvalue_t_long
        __init__(std::vector<(mvalue_t<(long)>)> self, std::vector< mvalue_t< long > >::size_type size, mvalue_t_long value) -> vector_mvalue_t_long
        """
        this = _oalib.new_vector_mvalue_t_long(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_mvalue_t_long self, mvalue_t_long x)"""
        return _oalib.vector_mvalue_t_long_push_back(self, x)


    def front(self):
        """front(vector_mvalue_t_long self) -> mvalue_t_long"""
        return _oalib.vector_mvalue_t_long_front(self)


    def back(self):
        """back(vector_mvalue_t_long self) -> mvalue_t_long"""
        return _oalib.vector_mvalue_t_long_back(self)


    def assign(self, n, x):
        """assign(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::size_type n, mvalue_t_long x)"""
        return _oalib.vector_mvalue_t_long_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::size_type new_size)
        resize(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::size_type new_size, mvalue_t_long x)
        """
        return _oalib.vector_mvalue_t_long_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::iterator pos, mvalue_t_long x) -> std::vector< mvalue_t< long > >::iterator
        insert(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::iterator pos, std::vector< mvalue_t< long > >::size_type n, mvalue_t_long x)
        """
        return _oalib.vector_mvalue_t_long_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_mvalue_t_long self, std::vector< mvalue_t< long > >::size_type n)"""
        return _oalib.vector_mvalue_t_long_reserve(self, n)


    def capacity(self):
        """capacity(vector_mvalue_t_long self) -> std::vector< mvalue_t< long > >::size_type"""
        return _oalib.vector_mvalue_t_long_capacity(self)

    __swig_destroy__ = _oalib.delete_vector_mvalue_t_long
    __del__ = lambda self: None
vector_mvalue_t_long_swigregister = _oalib.vector_mvalue_t_long_swigregister
vector_mvalue_t_long_swigregister(vector_mvalue_t_long)

class DequeParetoElementLong(object):
    """Proxy of C++ std::deque<(pareto_element<(mvalue_t<(long)>,long)>)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(DequeParetoElementLong self) -> SwigPyIterator"""
        return _oalib.DequeParetoElementLong_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(DequeParetoElementLong self) -> bool"""
        return _oalib.DequeParetoElementLong___nonzero__(self)


    def __bool__(self):
        """__bool__(DequeParetoElementLong self) -> bool"""
        return _oalib.DequeParetoElementLong___bool__(self)


    def __len__(self):
        """__len__(DequeParetoElementLong self) -> std::deque< pareto_element< mvalue_t< long >,long > >::size_type"""
        return _oalib.DequeParetoElementLong___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::difference_type i, std::deque< pareto_element< mvalue_t< long >,long > >::difference_type j) -> DequeParetoElementLong"""
        return _oalib.DequeParetoElementLong___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::difference_type i, std::deque< pareto_element< mvalue_t< long >,long > >::difference_type j)
        __setslice__(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::difference_type i, std::deque< pareto_element< mvalue_t< long >,long > >::difference_type j, DequeParetoElementLong v)
        """
        return _oalib.DequeParetoElementLong___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::difference_type i, std::deque< pareto_element< mvalue_t< long >,long > >::difference_type j)"""
        return _oalib.DequeParetoElementLong___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::difference_type i)
        __delitem__(DequeParetoElementLong self, PySliceObject * slice)
        """
        return _oalib.DequeParetoElementLong___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(DequeParetoElementLong self, PySliceObject * slice) -> DequeParetoElementLong
        __getitem__(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::difference_type i) -> ParetoElementLong
        """
        return _oalib.DequeParetoElementLong___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(DequeParetoElementLong self, PySliceObject * slice, DequeParetoElementLong v)
        __setitem__(DequeParetoElementLong self, PySliceObject * slice)
        __setitem__(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::difference_type i, ParetoElementLong x)
        """
        return _oalib.DequeParetoElementLong___setitem__(self, *args)


    def pop(self):
        """pop(DequeParetoElementLong self) -> ParetoElementLong"""
        return _oalib.DequeParetoElementLong_pop(self)


    def append(self, x):
        """append(DequeParetoElementLong self, ParetoElementLong x)"""
        return _oalib.DequeParetoElementLong_append(self, x)


    def empty(self):
        """empty(DequeParetoElementLong self) -> bool"""
        return _oalib.DequeParetoElementLong_empty(self)


    def size(self):
        """size(DequeParetoElementLong self) -> std::deque< pareto_element< mvalue_t< long >,long > >::size_type"""
        return _oalib.DequeParetoElementLong_size(self)


    def swap(self, v):
        """swap(DequeParetoElementLong self, DequeParetoElementLong v)"""
        return _oalib.DequeParetoElementLong_swap(self, v)


    def begin(self):
        """begin(DequeParetoElementLong self) -> std::deque< pareto_element< mvalue_t< long >,long > >::iterator"""
        return _oalib.DequeParetoElementLong_begin(self)


    def end(self):
        """end(DequeParetoElementLong self) -> std::deque< pareto_element< mvalue_t< long >,long > >::iterator"""
        return _oalib.DequeParetoElementLong_end(self)


    def rbegin(self):
        """rbegin(DequeParetoElementLong self) -> std::deque< pareto_element< mvalue_t< long >,long > >::reverse_iterator"""
        return _oalib.DequeParetoElementLong_rbegin(self)


    def rend(self):
        """rend(DequeParetoElementLong self) -> std::deque< pareto_element< mvalue_t< long >,long > >::reverse_iterator"""
        return _oalib.DequeParetoElementLong_rend(self)


    def clear(self):
        """clear(DequeParetoElementLong self)"""
        return _oalib.DequeParetoElementLong_clear(self)


    def get_allocator(self):
        """get_allocator(DequeParetoElementLong self) -> std::deque< pareto_element< mvalue_t< long >,long > >::allocator_type"""
        return _oalib.DequeParetoElementLong_get_allocator(self)


    def pop_back(self):
        """pop_back(DequeParetoElementLong self)"""
        return _oalib.DequeParetoElementLong_pop_back(self)


    def erase(self, *args):
        """
        erase(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::iterator pos) -> std::deque< pareto_element< mvalue_t< long >,long > >::iterator
        erase(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::iterator first, std::deque< pareto_element< mvalue_t< long >,long > >::iterator last) -> std::deque< pareto_element< mvalue_t< long >,long > >::iterator
        """
        return _oalib.DequeParetoElementLong_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::deque<(pareto_element<(mvalue_t<(long)>,long)>)> self) -> DequeParetoElementLong
        __init__(std::deque<(pareto_element<(mvalue_t<(long)>,long)>)> self, DequeParetoElementLong arg2) -> DequeParetoElementLong
        __init__(std::deque<(pareto_element<(mvalue_t<(long)>,long)>)> self, std::deque< pareto_element< mvalue_t< long >,long > >::size_type size) -> DequeParetoElementLong
        __init__(std::deque<(pareto_element<(mvalue_t<(long)>,long)>)> self, std::deque< pareto_element< mvalue_t< long >,long > >::size_type size, ParetoElementLong value) -> DequeParetoElementLong
        """
        this = _oalib.new_DequeParetoElementLong(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(DequeParetoElementLong self, ParetoElementLong x)"""
        return _oalib.DequeParetoElementLong_push_back(self, x)


    def front(self):
        """front(DequeParetoElementLong self) -> ParetoElementLong"""
        return _oalib.DequeParetoElementLong_front(self)


    def back(self):
        """back(DequeParetoElementLong self) -> ParetoElementLong"""
        return _oalib.DequeParetoElementLong_back(self)


    def assign(self, n, x):
        """assign(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::size_type n, ParetoElementLong x)"""
        return _oalib.DequeParetoElementLong_assign(self, n, x)


    def resize(self, *args):
        """
        resize(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::size_type new_size)
        resize(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::size_type new_size, ParetoElementLong x)
        """
        return _oalib.DequeParetoElementLong_resize(self, *args)


    def insert(self, *args):
        """
        insert(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::iterator pos, ParetoElementLong x) -> std::deque< pareto_element< mvalue_t< long >,long > >::iterator
        insert(DequeParetoElementLong self, std::deque< pareto_element< mvalue_t< long >,long > >::iterator pos, std::deque< pareto_element< mvalue_t< long >,long > >::size_type n, ParetoElementLong x)
        """
        return _oalib.DequeParetoElementLong_insert(self, *args)


    def pop_front(self):
        """pop_front(DequeParetoElementLong self)"""
        return _oalib.DequeParetoElementLong_pop_front(self)


    def push_front(self, x):
        """push_front(DequeParetoElementLong self, ParetoElementLong x)"""
        return _oalib.DequeParetoElementLong_push_front(self, x)

    __swig_destroy__ = _oalib.delete_DequeParetoElementLong
    __del__ = lambda self: None
DequeParetoElementLong_swigregister = _oalib.DequeParetoElementLong_swigregister
DequeParetoElementLong_swigregister(DequeParetoElementLong)


# for legacy reasons and for name consistency
GWLPvalueVector = vector_mvalue_t_double
mvalueVector = vector_mvalue_t_long
#%template(mvalueVector) std::vector<mvalue_t<long> >;

class conference_columnVector(object):
    """Proxy of C++ std::vector<(conference_column)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(conference_columnVector self) -> SwigPyIterator"""
        return _oalib.conference_columnVector_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(conference_columnVector self) -> bool"""
        return _oalib.conference_columnVector___nonzero__(self)


    def __bool__(self):
        """__bool__(conference_columnVector self) -> bool"""
        return _oalib.conference_columnVector___bool__(self)


    def __len__(self):
        """__len__(conference_columnVector self) -> std::vector< std::vector< signed char,std::allocator< signed char > > >::size_type"""
        return _oalib.conference_columnVector___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::difference_type i, std::vector< std::vector< signed char,std::allocator< signed char > > >::difference_type j) -> conference_columnVector"""
        return _oalib.conference_columnVector___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::difference_type i, std::vector< std::vector< signed char,std::allocator< signed char > > >::difference_type j)
        __setslice__(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::difference_type i, std::vector< std::vector< signed char,std::allocator< signed char > > >::difference_type j, conference_columnVector v)
        """
        return _oalib.conference_columnVector___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::difference_type i, std::vector< std::vector< signed char,std::allocator< signed char > > >::difference_type j)"""
        return _oalib.conference_columnVector___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::difference_type i)
        __delitem__(conference_columnVector self, PySliceObject * slice)
        """
        return _oalib.conference_columnVector___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(conference_columnVector self, PySliceObject * slice) -> conference_columnVector
        __getitem__(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::difference_type i) -> charVector
        """
        return _oalib.conference_columnVector___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(conference_columnVector self, PySliceObject * slice, conference_columnVector v)
        __setitem__(conference_columnVector self, PySliceObject * slice)
        __setitem__(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::difference_type i, charVector x)
        """
        return _oalib.conference_columnVector___setitem__(self, *args)


    def pop(self):
        """pop(conference_columnVector self) -> charVector"""
        return _oalib.conference_columnVector_pop(self)


    def append(self, x):
        """append(conference_columnVector self, charVector x)"""
        return _oalib.conference_columnVector_append(self, x)


    def empty(self):
        """empty(conference_columnVector self) -> bool"""
        return _oalib.conference_columnVector_empty(self)


    def size(self):
        """size(conference_columnVector self) -> std::vector< std::vector< signed char,std::allocator< signed char > > >::size_type"""
        return _oalib.conference_columnVector_size(self)


    def swap(self, v):
        """swap(conference_columnVector self, conference_columnVector v)"""
        return _oalib.conference_columnVector_swap(self, v)


    def begin(self):
        """begin(conference_columnVector self) -> std::vector< std::vector< signed char,std::allocator< signed char > > >::iterator"""
        return _oalib.conference_columnVector_begin(self)


    def end(self):
        """end(conference_columnVector self) -> std::vector< std::vector< signed char,std::allocator< signed char > > >::iterator"""
        return _oalib.conference_columnVector_end(self)


    def rbegin(self):
        """rbegin(conference_columnVector self) -> std::vector< std::vector< signed char,std::allocator< signed char > > >::reverse_iterator"""
        return _oalib.conference_columnVector_rbegin(self)


    def rend(self):
        """rend(conference_columnVector self) -> std::vector< std::vector< signed char,std::allocator< signed char > > >::reverse_iterator"""
        return _oalib.conference_columnVector_rend(self)


    def clear(self):
        """clear(conference_columnVector self)"""
        return _oalib.conference_columnVector_clear(self)


    def get_allocator(self):
        """get_allocator(conference_columnVector self) -> std::vector< std::vector< signed char,std::allocator< signed char > > >::allocator_type"""
        return _oalib.conference_columnVector_get_allocator(self)


    def pop_back(self):
        """pop_back(conference_columnVector self)"""
        return _oalib.conference_columnVector_pop_back(self)


    def erase(self, *args):
        """
        erase(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::iterator pos) -> std::vector< std::vector< signed char,std::allocator< signed char > > >::iterator
        erase(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::iterator first, std::vector< std::vector< signed char,std::allocator< signed char > > >::iterator last) -> std::vector< std::vector< signed char,std::allocator< signed char > > >::iterator
        """
        return _oalib.conference_columnVector_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(conference_column)> self) -> conference_columnVector
        __init__(std::vector<(conference_column)> self, conference_columnVector arg2) -> conference_columnVector
        __init__(std::vector<(conference_column)> self, std::vector< std::vector< signed char,std::allocator< signed char > > >::size_type size) -> conference_columnVector
        __init__(std::vector<(conference_column)> self, std::vector< std::vector< signed char,std::allocator< signed char > > >::size_type size, charVector value) -> conference_columnVector
        """
        this = _oalib.new_conference_columnVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(conference_columnVector self, charVector x)"""
        return _oalib.conference_columnVector_push_back(self, x)


    def front(self):
        """front(conference_columnVector self) -> charVector"""
        return _oalib.conference_columnVector_front(self)


    def back(self):
        """back(conference_columnVector self) -> charVector"""
        return _oalib.conference_columnVector_back(self)


    def assign(self, n, x):
        """assign(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::size_type n, charVector x)"""
        return _oalib.conference_columnVector_assign(self, n, x)


    def resize(self, *args):
        """
        resize(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::size_type new_size)
        resize(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::size_type new_size, charVector x)
        """
        return _oalib.conference_columnVector_resize(self, *args)


    def insert(self, *args):
        """
        insert(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::iterator pos, charVector x) -> std::vector< std::vector< signed char,std::allocator< signed char > > >::iterator
        insert(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::iterator pos, std::vector< std::vector< signed char,std::allocator< signed char > > >::size_type n, charVector x)
        """
        return _oalib.conference_columnVector_insert(self, *args)


    def reserve(self, n):
        """reserve(conference_columnVector self, std::vector< std::vector< signed char,std::allocator< signed char > > >::size_type n)"""
        return _oalib.conference_columnVector_reserve(self, n)


    def capacity(self):
        """capacity(conference_columnVector self) -> std::vector< std::vector< signed char,std::allocator< signed char > > >::size_type"""
        return _oalib.conference_columnVector_capacity(self)

    __swig_destroy__ = _oalib.delete_conference_columnVector
    __del__ = lambda self: None
conference_columnVector_swigregister = _oalib.conference_columnVector_swigregister
conference_columnVector_swigregister(conference_columnVector)


def calculateArrayParetoJ5(al, verbose):
    """
    calculateArrayParetoJ5(array_link al, int verbose) -> Pareto< mvalue_t< long >,array_link >::pValue



    Calculate Pareto element with J5 criterium.  

    """
    return _oalib.calculateArrayParetoJ5(al, verbose)

def calculateArrayParetoJ5int(al, verbose):
    """
    calculateArrayParetoJ5int(array_link al, int verbose) -> Pareto< mvalue_t< long >,int >::pValue



    Calculate Pareto element with J5 criterium.  

    """
    return _oalib.calculateArrayParetoJ5int(al, verbose)

def calculateArrayParetoJ5long(al, verbose):
    """
    calculateArrayParetoJ5long(array_link al, int verbose) -> vector_mvalue_t_long



    Calculate Pareto element with J5 criterium.  

    """
    return _oalib.calculateArrayParetoJ5long(al, verbose)
class vector_vector_double(object):
    """Proxy of C++ std::vector<(std::vector<(double)>)> class."""

    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr

    def iterator(self):
        """iterator(vector_vector_double self) -> SwigPyIterator"""
        return _oalib.vector_vector_double_iterator(self)

    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        """__nonzero__(vector_vector_double self) -> bool"""
        return _oalib.vector_vector_double___nonzero__(self)


    def __bool__(self):
        """__bool__(vector_vector_double self) -> bool"""
        return _oalib.vector_vector_double___bool__(self)


    def __len__(self):
        """__len__(vector_vector_double self) -> std::vector< std::vector< double > >::size_type"""
        return _oalib.vector_vector_double___len__(self)


    def __getslice__(self, i, j):
        """__getslice__(vector_vector_double self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j) -> vector_vector_double"""
        return _oalib.vector_vector_double___getslice__(self, i, j)


    def __setslice__(self, *args):
        """
        __setslice__(vector_vector_double self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)
        __setslice__(vector_vector_double self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j, vector_vector_double v)
        """
        return _oalib.vector_vector_double___setslice__(self, *args)


    def __delslice__(self, i, j):
        """__delslice__(vector_vector_double self, std::vector< std::vector< double > >::difference_type i, std::vector< std::vector< double > >::difference_type j)"""
        return _oalib.vector_vector_double___delslice__(self, i, j)


    def __delitem__(self, *args):
        """
        __delitem__(vector_vector_double self, std::vector< std::vector< double > >::difference_type i)
        __delitem__(vector_vector_double self, PySliceObject * slice)
        """
        return _oalib.vector_vector_double___delitem__(self, *args)


    def __getitem__(self, *args):
        """
        __getitem__(vector_vector_double self, PySliceObject * slice) -> vector_vector_double
        __getitem__(vector_vector_double self, std::vector< std::vector< double > >::difference_type i) -> doubleVector
        """
        return _oalib.vector_vector_double___getitem__(self, *args)


    def __setitem__(self, *args):
        """
        __setitem__(vector_vector_double self, PySliceObject * slice, vector_vector_double v)
        __setitem__(vector_vector_double self, PySliceObject * slice)
        __setitem__(vector_vector_double self, std::vector< std::vector< double > >::difference_type i, doubleVector x)
        """
        return _oalib.vector_vector_double___setitem__(self, *args)


    def pop(self):
        """pop(vector_vector_double self) -> doubleVector"""
        return _oalib.vector_vector_double_pop(self)


    def append(self, x):
        """append(vector_vector_double self, doubleVector x)"""
        return _oalib.vector_vector_double_append(self, x)


    def empty(self):
        """empty(vector_vector_double self) -> bool"""
        return _oalib.vector_vector_double_empty(self)


    def size(self):
        """size(vector_vector_double self) -> std::vector< std::vector< double > >::size_type"""
        return _oalib.vector_vector_double_size(self)


    def swap(self, v):
        """swap(vector_vector_double self, vector_vector_double v)"""
        return _oalib.vector_vector_double_swap(self, v)


    def begin(self):
        """begin(vector_vector_double self) -> std::vector< std::vector< double > >::iterator"""
        return _oalib.vector_vector_double_begin(self)


    def end(self):
        """end(vector_vector_double self) -> std::vector< std::vector< double > >::iterator"""
        return _oalib.vector_vector_double_end(self)


    def rbegin(self):
        """rbegin(vector_vector_double self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _oalib.vector_vector_double_rbegin(self)


    def rend(self):
        """rend(vector_vector_double self) -> std::vector< std::vector< double > >::reverse_iterator"""
        return _oalib.vector_vector_double_rend(self)


    def clear(self):
        """clear(vector_vector_double self)"""
        return _oalib.vector_vector_double_clear(self)


    def get_allocator(self):
        """get_allocator(vector_vector_double self) -> std::vector< std::vector< double > >::allocator_type"""
        return _oalib.vector_vector_double_get_allocator(self)


    def pop_back(self):
        """pop_back(vector_vector_double self)"""
        return _oalib.vector_vector_double_pop_back(self)


    def erase(self, *args):
        """
        erase(vector_vector_double self, std::vector< std::vector< double > >::iterator pos) -> std::vector< std::vector< double > >::iterator
        erase(vector_vector_double self, std::vector< std::vector< double > >::iterator first, std::vector< std::vector< double > >::iterator last) -> std::vector< std::vector< double > >::iterator
        """
        return _oalib.vector_vector_double_erase(self, *args)


    def __init__(self, *args):
        """
        __init__(std::vector<(std::vector<(double)>)> self) -> vector_vector_double
        __init__(std::vector<(std::vector<(double)>)> self, vector_vector_double arg2) -> vector_vector_double
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size) -> vector_vector_double
        __init__(std::vector<(std::vector<(double)>)> self, std::vector< std::vector< double > >::size_type size, doubleVector value) -> vector_vector_double
        """
        this = _oalib.new_vector_vector_double(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x):
        """push_back(vector_vector_double self, doubleVector x)"""
        return _oalib.vector_vector_double_push_back(self, x)


    def front(self):
        """front(vector_vector_double self) -> doubleVector"""
        return _oalib.vector_vector_double_front(self)


    def back(self):
        """back(vector_vector_double self) -> doubleVector"""
        return _oalib.vector_vector_double_back(self)


    def assign(self, n, x):
        """assign(vector_vector_double self, std::vector< std::vector< double > >::size_type n, doubleVector x)"""
        return _oalib.vector_vector_double_assign(self, n, x)


    def resize(self, *args):
        """
        resize(vector_vector_double self, std::vector< std::vector< double > >::size_type new_size)
        resize(vector_vector_double self, std::vector< std::vector< double > >::size_type new_size, doubleVector x)
        """
        return _oalib.vector_vector_double_resize(self, *args)


    def insert(self, *args):
        """
        insert(vector_vector_double self, std::vector< std::vector< double > >::iterator pos, doubleVector x) -> std::vector< std::vector< double > >::iterator
        insert(vector_vector_double self, std::vector< std::vector< double > >::iterator pos, std::vector< std::vector< double > >::size_type n, doubleVector x)
        """
        return _oalib.vector_vector_double_insert(self, *args)


    def reserve(self, n):
        """reserve(vector_vector_double self, std::vector< std::vector< double > >::size_type n)"""
        return _oalib.vector_vector_double_reserve(self, n)


    def capacity(self):
        """capacity(vector_vector_double self) -> std::vector< std::vector< double > >::size_type"""
        return _oalib.vector_vector_double_capacity(self)

    __swig_destroy__ = _oalib.delete_vector_vector_double
    __del__ = lambda self: None
vector_vector_double_swigregister = _oalib.vector_vector_double_swigregister
vector_vector_double_swigregister(vector_vector_double)


__doc__ = """
Python Orthogonal Array Interface 
"""



