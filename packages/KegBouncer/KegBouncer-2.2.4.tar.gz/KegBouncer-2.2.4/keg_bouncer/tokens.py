"""Tools for building and working with password-reset tokens.

This file is a modified version of a similar one in Flask-User and the original
has the following copyright information:
    :copyright: (c) 2013 by Ling Thio
    :author: Ling Thio (ling.thio@gmail.com)
    :license: Simplified BSD License, see LICENSE.txt for more details.
"""

import base64
from cryptography.hazmat.primitives.ciphers import (
    Cipher,
    algorithms as cipher_algos,
    modes as cipher_modes,
)
from cryptography.hazmat.backends import default_backend as crypto_backend
from itsdangerous import BadSignature, SignatureExpired, TimestampSigner


class TokenManager(object):
    def __init__(self, secret, timestamp_signer=TimestampSigner):
        # Create cypher to encrypt IDs and ensure >=16 characters

        key = secret
        if not isinstance(key, bytes):
            key = secret.encode("utf-8")
        if len(key) < 16:
            raise ValueError('Key must be at least 16 bytes long')
        self.cipher = Cipher(cipher_algos.AES(key[:16]), cipher_modes.ECB(), crypto_backend())
        self.signer = timestamp_signer(secret)

    def encrypt(self, data):
        """Encrypts data to url-safe base64 string."""
        padded = data + (b' ' * (16 - (len(data) % 16)))
        encryptor = self.cipher.encryptor()
        encrypted = encryptor.update(padded)
        base64ed = base64.urlsafe_b64encode(encrypted)  # URL safe base64 string with '=='
        return base64ed[0:-2]                           # base64 string without '=='

    def decrypt(self, encrypted_data):
        """Decrypts url-safe base64 string to original data.

        :param encrypted_data: must be bytes.
        """
        try:
            base64ed = encrypted_data + b'=='               # base64 string with '=='
            encrypted = base64.urlsafe_b64decode(base64ed)  # encrypted data
            decryptor = self.cipher.decryptor()
            padded = decryptor.update(encrypted)
            return padded.strip()
        except Exception as e:  # pragma: no cover
            print('!!!Exception in decrypt!!!:', e)
            return None

    def generate_token(self, data):
        """Return token with data, timestamp, and signature"""
        # In Python3 we must make sure that bytes are converted to strings.
        # Hence the addition of '.decode()'
        return self.signer.sign(self.encrypt(data)).decode()

    def verify_token(self, token, expiration_timedelta):
        """Verify token and return (has_expired, data).

        :param token: is the full token string as generated by `generate_token`.
        :param expiration_timedelta: is a `datetime.timedelta` describing how old the toen
                                     may be.

        :returns: `(False, data)` on success.
                  `(False, None)` on bad data.
                  `(True,  None)` on expired token.
        """
        try:
            data = self.signer.unsign(token, max_age=expiration_timedelta.total_seconds())
            return (False, self.decrypt(data))
        except SignatureExpired:
            return (True, None)
        except BadSignature:
            return (False, None)
