import csv

from .card import Card


NO_TYPING = [['ASSISTED_PRODUCTION', 'PRODUCTION'],['ASSISTED_PRODUCTION', 'PRODUCTION']]
NO_TYPOS = ['NO_TYPOS', 'NO_TYPOS']


class Deck(object):
    """Data class for an Tinycards deck entity."""

    def __init__(self,
                 title,
                 description=None,
                 cover=None,
                 deck_id=None,
                 front_language=None,
                 back_language=None,
                 cards=None,
                 private=False,
                 shareable=False,
                 slug='',
                 compact_id='',
                 blacklisted_side_indices=None,
                 blacklisted_question_types=None,
                 grading_modes=None,
                 tts_languages=None):
        '''
        Initialize a new instance of the Deck class.
        Args:
            cover (string, optional):
                The cover image of this deck. If set to a local file path or an image URL, the corresponding file will be uploaded to Tinycards.
                This can also be done after Deck construction, simply by setting this attribute to a valid non-None value.
                After creating or updating a deck, the Tinycards URL of the cover image can be read from attributes:
                - cover_image_url (only set once a custom cover has been uploaded)
                - image_url (always set, either to the URL of the default cover, or the URL of the custom cover)
            private (bool, optional):
                If set to False (the default), the deck will be publicly available.
                If set to True, it will not. If you need a "shareable link", please also set shareable to True.
                See also below "Visibility of the deck" section.
            shareable (bool, optional):
                If set to False (the default), the deck will not have any "shareable link" associated to it.
                If set to True, it will. Once the deck has been created, the link generated by Tinycards is accessible via the shareable_link attribute.
                See also below "Visibility of the deck" section.
            slug (string, optional): short name for the Deck. Only returned by Tinycards upon Deck creation.
            compact_id (string, optional): short unique ID for the deck. Only returned by Tinycards upon Deck creation.
            blacklisted_side_indices (list, optional):
                Optional list of indices of sides to NOT use for knowledge testing, e.g.:
                - [0] to NOT use the front side (0) of the cards and only test knowledge with their back sides (1),
                - [1] to NOT use the back side (1) of the cards and only test knowledge with their front sides (0).
            blacklisted_question_types (list, optional):
                Optional list of lists containing the types of questions to skip for knowledge testing.
                When provided, the outer list should contain two inner lists:
                - one for the types of questions to skip for knowledge testing on the front side of cards,
                - one for the types of questions to skip for knowledge testing on the back side of cards.
                For example, to test knowledge without having to type answers, for both sides, one should pass:
                    [
                        ['ASSISTED_PRODUCTION', 'PRODUCTION'],
                        ['ASSISTED_PRODUCTION', 'PRODUCTION']
                    ]
                The constant tinycards.model.deck.NO_TYPING can be used for this.
            grading_modes (list, optional):
                Optional list of modes to evaluate the answers provided.
                When provided, the list should contain two values:
                - one for the grading of the front side of cards,
                - one for the grading of the back side of cards.
                For example, by default, Tinycards tolerate typos in typed answers. To disable this and have a stricter grading, one should pass:
                    ['NO_TYPOS', 'NO_TYPOS']
                The constant tinycards.model.deck.NO_TYPOS can be used for this.
            tts_languages (list, optional):
                Optional list of languages to enable text-to-speech.
                When provided, the list should contain two values:
                - one for the language of the front side of cards,
                - one for the language of the back side of cards.
                The following languages are currently supported by Tinycards:
                - Catalan:    'ca'
                - Danish:     'da'
                - Dutch:      'nl-NL'
                - English:    'en'
                - French:     'fr'
                - German:     'de'
                - Italian:    'it'
                - Japanese:   'ja'
                - Norwegian:  'no-BO'
                - Polish:     'pl'
                - Portuguese: 'pt'
                - Russian:    'ru'
                - Spanish:    'es'
                - Swedish:    'sv'
                - Turkish:    'tr'
                - Welsh:      'cy'
                For example, if the front side of cards is in English, and their back side is in Japanese, one should pass:
                    ['en', 'ja']

        Visibility of the deck:
            Tinycards' UI let's you specifiy that a deck is visible to:
            - Everyone
            - People with a private link
            - Only me
            To achieve the equivalent using Tinycards' API, one needs to correctly set the private and shareable flags:
            - Everyone:                     private=False,  shareable=False
            - People with a private link:   private=True,   shareable=True
            - Only me:                      private=True,   shareable=False

        '''
        # IDs:
        self.id = deck_id
        self.slug = slug
        self.compact_id = compact_id

        self.creation_timestamp = None
        self.title = title
        self.description = description
        self.cards = cards if cards else []
        # Cover:
        self.cover = cover
        self.cover_image_url = None  # Only set upon response from Tinycards' API.
        self.image_url = None  # Only set upon response from Tinycards' API.
        # Visibility:
        self.private = private
        self.shareable = shareable
        self.shareable_link = 'https://tiny.cards/decks/%s/%s' % (compact_id, slug) if private and shareable and compact_id and slug else ''
        # Knowledge testing:
        self.blacklisted_side_indices = blacklisted_side_indices if blacklisted_side_indices else []
        self.blacklisted_question_types = blacklisted_question_types if blacklisted_question_types else []
        self.grading_modes = grading_modes if grading_modes else []
        self.tts_languages = tts_languages if tts_languages else []

    def __str__(self):
        return str(self.__dict__)

    def __repr__(self):
        return self.__str__()

    def add_card(self, card):
        """Add a new card to the deck."""
        if isinstance(card, tuple) and len(card) == 2:
            new_card = Card(front=card[0], back=card[1])
        else:
            raise ValueError("Invalid card used as argument")
        self.cards.append(new_card)

    def add_cards_from_csv(self, csv_file,
                           front_column='front',
                           back_column='back'):
        """Add word pairs from a CSV file as cards to the deck.

        Args:
            csv_file: The file buffer that contains the CSV data.
            front_column (str): Optional name for the 'front' column.
            back_column (str): Optional name for the 'back' column.

        Example:
            >>> with open(csv_path, 'r') as csv_file:
            >>>     deck.add_cards_from_csv(csv_file)

        """
        csv_reader = csv.DictReader(csv_file)
        for row in csv_reader:
            current_word_pair = (row[front_column], row[back_column])
            self.add_card(current_word_pair)

    def save_cards_to_csv(self, csv_file,
                          front_column='front',
                          back_column='back'):
        """Save the word pairs from the deck's cards to a CSV file.

        Args:
            csv_file: The file buffer to store the CSV data in.
            front_column (str): Optional name for the 'front' column.
            back_column (str): Optional name for the 'back' column.

        Example:
            >>> with open(csv_path, 'w') as csv_file:
            >>>     deck.save_cards_to_csv(csv_file)

        """
        csv_writer = csv.DictWriter(csv_file,
                                    fieldnames=[front_column, back_column])
        # Add header row first.
        csv_writer.writeheader()
        # Then add all cards as rows.
        for card in self.cards:
            front_word = card.front.concepts[0].fact.text
            back_word = card.back.concepts[0].fact.text
            csv_writer.writerow({front_column: front_word,
                                 back_column: back_word})
